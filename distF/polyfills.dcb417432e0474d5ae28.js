/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 6258:
/*!**************************!*\
  !*** ./src/polyfills.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * This file includes polyfills needed by Angular and is loaded before the app.\n * You can add your own extra polyfills to this file.\n *\n * This file is divided into 2 sections:\n *   1. Browser polyfills. These are applied before loading ZoneJS and are sorted by browsers.\n *   2. Application imports. Files imported after ZoneJS that should be loaded before your main\n *      file.\n *\n * The current setup is for so-called \"evergreen\" browsers; the last versions of browsers that\n * automatically update themselves. This includes recent versions of Safari, Chrome (including\n * Opera), Edge on the desktop, and iOS and Chrome on mobile.\n *\n * Learn more in https://angular.io/guide/browser-support\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/***************************************************************************************************\n * BROWSER POLYFILLS\n */\n/**\n * By default, zone.js will patch all possible macroTask and DomEvents\n * user can disable parts of macroTask/DomEvents patch by setting following flags\n * because those flags need to be set before `zone.js` being loaded, and webpack\n * will put import in the top of bundle, so user need to create a separate file\n * in this directory (for example: zone-flags.ts), and put the following flags\n * into that file, and then add the following code before importing zone.js.\n * import './zone-flags';\n *\n * The flags allowed in zone-flags.ts are listed here.\n *\n * The following flags will work for all browsers.\n *\n * (window as any).__Zone_disable_requestAnimationFrame = true; // disable patch requestAnimationFrame\n * (window as any).__Zone_disable_on_property = true; // disable patch onProperty such as onclick\n * (window as any).__zone_symbol__UNPATCHED_EVENTS = ['scroll', 'mousemove']; // disable patch specified eventNames\n *\n *  in IE/Edge developer tools, the addEventListener will also be wrapped by zone.js\n *  with the following flag, it will bypass `zone.js` patch for IE/Edge\n *\n *  (window as any).__Zone_enable_cross_context_check = true;\n *\n */\n/***************************************************************************************************\n * Zone JS is required by default for Angular itself.\n */\n__webpack_require__(/*! zone.js */ 2014); // Included with Angular CLI.\n/***************************************************************************************************\n * APPLICATION IMPORTS\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI1OC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7O0dBY0c7O0FBRUg7O0dBRUc7QUFFSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNCRztBQUVIOztHQUVHO0FBQ0gseUNBQWlCLENBQUUsNkJBQTZCO0FBR2hEOztHQUVHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYTEzLXdlYnBhY2svLi9zcmMvcG9seWZpbGxzLnRzPzg0ZGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGlzIGZpbGUgaW5jbHVkZXMgcG9seWZpbGxzIG5lZWRlZCBieSBBbmd1bGFyIGFuZCBpcyBsb2FkZWQgYmVmb3JlIHRoZSBhcHAuXG4gKiBZb3UgY2FuIGFkZCB5b3VyIG93biBleHRyYSBwb2x5ZmlsbHMgdG8gdGhpcyBmaWxlLlxuICpcbiAqIFRoaXMgZmlsZSBpcyBkaXZpZGVkIGludG8gMiBzZWN0aW9uczpcbiAqICAgMS4gQnJvd3NlciBwb2x5ZmlsbHMuIFRoZXNlIGFyZSBhcHBsaWVkIGJlZm9yZSBsb2FkaW5nIFpvbmVKUyBhbmQgYXJlIHNvcnRlZCBieSBicm93c2Vycy5cbiAqICAgMi4gQXBwbGljYXRpb24gaW1wb3J0cy4gRmlsZXMgaW1wb3J0ZWQgYWZ0ZXIgWm9uZUpTIHRoYXQgc2hvdWxkIGJlIGxvYWRlZCBiZWZvcmUgeW91ciBtYWluXG4gKiAgICAgIGZpbGUuXG4gKlxuICogVGhlIGN1cnJlbnQgc2V0dXAgaXMgZm9yIHNvLWNhbGxlZCBcImV2ZXJncmVlblwiIGJyb3dzZXJzOyB0aGUgbGFzdCB2ZXJzaW9ucyBvZiBicm93c2VycyB0aGF0XG4gKiBhdXRvbWF0aWNhbGx5IHVwZGF0ZSB0aGVtc2VsdmVzLiBUaGlzIGluY2x1ZGVzIHJlY2VudCB2ZXJzaW9ucyBvZiBTYWZhcmksIENocm9tZSAoaW5jbHVkaW5nXG4gKiBPcGVyYSksIEVkZ2Ugb24gdGhlIGRlc2t0b3AsIGFuZCBpT1MgYW5kIENocm9tZSBvbiBtb2JpbGUuXG4gKlxuICogTGVhcm4gbW9yZSBpbiBodHRwczovL2FuZ3VsYXIuaW8vZ3VpZGUvYnJvd3Nlci1zdXBwb3J0XG4gKi9cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQlJPV1NFUiBQT0xZRklMTFNcbiAqL1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHpvbmUuanMgd2lsbCBwYXRjaCBhbGwgcG9zc2libGUgbWFjcm9UYXNrIGFuZCBEb21FdmVudHNcbiAqIHVzZXIgY2FuIGRpc2FibGUgcGFydHMgb2YgbWFjcm9UYXNrL0RvbUV2ZW50cyBwYXRjaCBieSBzZXR0aW5nIGZvbGxvd2luZyBmbGFnc1xuICogYmVjYXVzZSB0aG9zZSBmbGFncyBuZWVkIHRvIGJlIHNldCBiZWZvcmUgYHpvbmUuanNgIGJlaW5nIGxvYWRlZCwgYW5kIHdlYnBhY2tcbiAqIHdpbGwgcHV0IGltcG9ydCBpbiB0aGUgdG9wIG9mIGJ1bmRsZSwgc28gdXNlciBuZWVkIHRvIGNyZWF0ZSBhIHNlcGFyYXRlIGZpbGVcbiAqIGluIHRoaXMgZGlyZWN0b3J5IChmb3IgZXhhbXBsZTogem9uZS1mbGFncy50cyksIGFuZCBwdXQgdGhlIGZvbGxvd2luZyBmbGFnc1xuICogaW50byB0aGF0IGZpbGUsIGFuZCB0aGVuIGFkZCB0aGUgZm9sbG93aW5nIGNvZGUgYmVmb3JlIGltcG9ydGluZyB6b25lLmpzLlxuICogaW1wb3J0ICcuL3pvbmUtZmxhZ3MnO1xuICpcbiAqIFRoZSBmbGFncyBhbGxvd2VkIGluIHpvbmUtZmxhZ3MudHMgYXJlIGxpc3RlZCBoZXJlLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgZmxhZ3Mgd2lsbCB3b3JrIGZvciBhbGwgYnJvd3NlcnMuXG4gKlxuICogKHdpbmRvdyBhcyBhbnkpLl9fWm9uZV9kaXNhYmxlX3JlcXVlc3RBbmltYXRpb25GcmFtZSA9IHRydWU7IC8vIGRpc2FibGUgcGF0Y2ggcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gKiAod2luZG93IGFzIGFueSkuX19ab25lX2Rpc2FibGVfb25fcHJvcGVydHkgPSB0cnVlOyAvLyBkaXNhYmxlIHBhdGNoIG9uUHJvcGVydHkgc3VjaCBhcyBvbmNsaWNrXG4gKiAod2luZG93IGFzIGFueSkuX196b25lX3N5bWJvbF9fVU5QQVRDSEVEX0VWRU5UUyA9IFsnc2Nyb2xsJywgJ21vdXNlbW92ZSddOyAvLyBkaXNhYmxlIHBhdGNoIHNwZWNpZmllZCBldmVudE5hbWVzXG4gKlxuICogIGluIElFL0VkZ2UgZGV2ZWxvcGVyIHRvb2xzLCB0aGUgYWRkRXZlbnRMaXN0ZW5lciB3aWxsIGFsc28gYmUgd3JhcHBlZCBieSB6b25lLmpzXG4gKiAgd2l0aCB0aGUgZm9sbG93aW5nIGZsYWcsIGl0IHdpbGwgYnlwYXNzIGB6b25lLmpzYCBwYXRjaCBmb3IgSUUvRWRnZVxuICpcbiAqICAod2luZG93IGFzIGFueSkuX19ab25lX2VuYWJsZV9jcm9zc19jb250ZXh0X2NoZWNrID0gdHJ1ZTtcbiAqXG4gKi9cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogWm9uZSBKUyBpcyByZXF1aXJlZCBieSBkZWZhdWx0IGZvciBBbmd1bGFyIGl0c2VsZi5cbiAqL1xuaW1wb3J0ICd6b25lLmpzJzsgIC8vIEluY2x1ZGVkIHdpdGggQW5ndWxhciBDTEkuXG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQVBQTElDQVRJT04gSU1QT1JUU1xuICovXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6258\n");

/***/ }),

/***/ 2014:
/*!***********************************************!*\
  !*** ./node_modules/zone.js/fesm2015/zone.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * @license Angular v14.0.0-next.5\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n(function (global) {\n  const performance = global['performance'];\n\n  function mark(name) {\n    performance && performance['mark'] && performance['mark'](name);\n  }\n\n  function performanceMeasure(name, label) {\n    performance && performance['measure'] && performance['measure'](name, label);\n  }\n\n  mark('Zone'); // Initialize before it's accessed below.\n  // __Zone_symbol_prefix global can be used to override the default zone\n  // symbol prefix with a custom one if needed.\n\n  const symbolPrefix = global['__Zone_symbol_prefix'] || '__zone_symbol__';\n\n  function __symbol__(name) {\n    return symbolPrefix + name;\n  }\n\n  const checkDuplicate = global[__symbol__('forceDuplicateZoneCheck')] === true;\n\n  if (global['Zone']) {\n    // if global['Zone'] already exists (maybe zone.js was already loaded or\n    // some other lib also registered a global object named Zone), we may need\n    // to throw an error, but sometimes user may not want this error.\n    // For example,\n    // we have two web pages, page1 includes zone.js, page2 doesn't.\n    // and the 1st time user load page1 and page2, everything work fine,\n    // but when user load page2 again, error occurs because global['Zone'] already exists.\n    // so we add a flag to let user choose whether to throw this error or not.\n    // By default, if existing Zone is from zone.js, we will not throw the error.\n    if (checkDuplicate || typeof global['Zone'].__symbol__ !== 'function') {\n      throw new Error('Zone already loaded.');\n    } else {\n      return global['Zone'];\n    }\n  }\n\n  class Zone {\n    constructor(parent, zoneSpec) {\n      this._parent = parent;\n      this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '<root>';\n      this._properties = zoneSpec && zoneSpec.properties || {};\n      this._zoneDelegate = new _ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);\n    }\n\n    static assertZonePatched() {\n      if (global['Promise'] !== patches['ZoneAwarePromise']) {\n        throw new Error('Zone.js has detected that ZoneAwarePromise `(window|global).Promise` ' + 'has been overwritten.\\n' + 'Most likely cause is that a Promise polyfill has been loaded ' + 'after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. ' + 'If you must load one, do so before loading zone.js.)');\n      }\n    }\n\n    static get root() {\n      let zone = Zone.current;\n\n      while (zone.parent) {\n        zone = zone.parent;\n      }\n\n      return zone;\n    }\n\n    static get current() {\n      return _currentZoneFrame.zone;\n    }\n\n    static get currentTask() {\n      return _currentTask;\n    } // tslint:disable-next-line:require-internal-with-underscore\n\n\n    static __load_patch(name, fn, ignoreDuplicate = false) {\n      if (patches.hasOwnProperty(name)) {\n        // `checkDuplicate` option is defined from global variable\n        // so it works for all modules.\n        // `ignoreDuplicate` can work for the specified module\n        if (!ignoreDuplicate && checkDuplicate) {\n          throw Error('Already loaded patch: ' + name);\n        }\n      } else if (!global['__Zone_disable_' + name]) {\n        const perfName = 'Zone:' + name;\n        mark(perfName);\n        patches[name] = fn(global, Zone, _api);\n        performanceMeasure(perfName, perfName);\n      }\n    }\n\n    get parent() {\n      return this._parent;\n    }\n\n    get name() {\n      return this._name;\n    }\n\n    get(key) {\n      const zone = this.getZoneWith(key);\n      if (zone) return zone._properties[key];\n    }\n\n    getZoneWith(key) {\n      let current = this;\n\n      while (current) {\n        if (current._properties.hasOwnProperty(key)) {\n          return current;\n        }\n\n        current = current._parent;\n      }\n\n      return null;\n    }\n\n    fork(zoneSpec) {\n      if (!zoneSpec) throw new Error('ZoneSpec required!');\n      return this._zoneDelegate.fork(this, zoneSpec);\n    }\n\n    wrap(callback, source) {\n      if (typeof callback !== 'function') {\n        throw new Error('Expecting function got: ' + callback);\n      }\n\n      const _callback = this._zoneDelegate.intercept(this, callback, source);\n\n      const zone = this;\n      return function () {\n        return zone.runGuarded(_callback, this, arguments, source);\n      };\n    }\n\n    run(callback, applyThis, applyArgs, source) {\n      _currentZoneFrame = {\n        parent: _currentZoneFrame,\n        zone: this\n      };\n\n      try {\n        return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n      } finally {\n        _currentZoneFrame = _currentZoneFrame.parent;\n      }\n    }\n\n    runGuarded(callback, applyThis = null, applyArgs, source) {\n      _currentZoneFrame = {\n        parent: _currentZoneFrame,\n        zone: this\n      };\n\n      try {\n        try {\n          return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n        } catch (error) {\n          if (this._zoneDelegate.handleError(this, error)) {\n            throw error;\n          }\n        }\n      } finally {\n        _currentZoneFrame = _currentZoneFrame.parent;\n      }\n    }\n\n    runTask(task, applyThis, applyArgs) {\n      if (task.zone != this) {\n        throw new Error('A task can only be run in the zone of creation! (Creation: ' + (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');\n      } // https://github.com/angular/zone.js/issues/778, sometimes eventTask\n      // will run in notScheduled(canceled) state, we should not try to\n      // run such kind of task but just return\n\n\n      if (task.state === notScheduled && (task.type === eventTask || task.type === macroTask)) {\n        return;\n      }\n\n      const reEntryGuard = task.state != running;\n      reEntryGuard && task._transitionTo(running, scheduled);\n      task.runCount++;\n      const previousTask = _currentTask;\n      _currentTask = task;\n      _currentZoneFrame = {\n        parent: _currentZoneFrame,\n        zone: this\n      };\n\n      try {\n        if (task.type == macroTask && task.data && !task.data.isPeriodic) {\n          task.cancelFn = undefined;\n        }\n\n        try {\n          return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);\n        } catch (error) {\n          if (this._zoneDelegate.handleError(this, error)) {\n            throw error;\n          }\n        }\n      } finally {\n        // if the task's state is notScheduled or unknown, then it has already been cancelled\n        // we should not reset the state to scheduled\n        if (task.state !== notScheduled && task.state !== unknown) {\n          if (task.type == eventTask || task.data && task.data.isPeriodic) {\n            reEntryGuard && task._transitionTo(scheduled, running);\n          } else {\n            task.runCount = 0;\n\n            this._updateTaskCount(task, -1);\n\n            reEntryGuard && task._transitionTo(notScheduled, running, notScheduled);\n          }\n        }\n\n        _currentZoneFrame = _currentZoneFrame.parent;\n        _currentTask = previousTask;\n      }\n    }\n\n    scheduleTask(task) {\n      if (task.zone && task.zone !== this) {\n        // check if the task was rescheduled, the newZone\n        // should not be the children of the original zone\n        let newZone = this;\n\n        while (newZone) {\n          if (newZone === task.zone) {\n            throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${task.zone.name}`);\n          }\n\n          newZone = newZone.parent;\n        }\n      }\n\n      task._transitionTo(scheduling, notScheduled);\n\n      const zoneDelegates = [];\n      task._zoneDelegates = zoneDelegates;\n      task._zone = this;\n\n      try {\n        task = this._zoneDelegate.scheduleTask(this, task);\n      } catch (err) {\n        // should set task's state to unknown when scheduleTask throw error\n        // because the err may from reschedule, so the fromState maybe notScheduled\n        task._transitionTo(unknown, scheduling, notScheduled); // TODO: @JiaLiPassion, should we check the result from handleError?\n\n\n        this._zoneDelegate.handleError(this, err);\n\n        throw err;\n      }\n\n      if (task._zoneDelegates === zoneDelegates) {\n        // we have to check because internally the delegate can reschedule the task.\n        this._updateTaskCount(task, 1);\n      }\n\n      if (task.state == scheduling) {\n        task._transitionTo(scheduled, scheduling);\n      }\n\n      return task;\n    }\n\n    scheduleMicroTask(source, callback, data, customSchedule) {\n      return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, undefined));\n    }\n\n    scheduleMacroTask(source, callback, data, customSchedule, customCancel) {\n      return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));\n    }\n\n    scheduleEventTask(source, callback, data, customSchedule, customCancel) {\n      return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));\n    }\n\n    cancelTask(task) {\n      if (task.zone != this) throw new Error('A task can only be cancelled in the zone of creation! (Creation: ' + (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');\n\n      task._transitionTo(canceling, scheduled, running);\n\n      try {\n        this._zoneDelegate.cancelTask(this, task);\n      } catch (err) {\n        // if error occurs when cancelTask, transit the state to unknown\n        task._transitionTo(unknown, canceling);\n\n        this._zoneDelegate.handleError(this, err);\n\n        throw err;\n      }\n\n      this._updateTaskCount(task, -1);\n\n      task._transitionTo(notScheduled, canceling);\n\n      task.runCount = 0;\n      return task;\n    }\n\n    _updateTaskCount(task, count) {\n      const zoneDelegates = task._zoneDelegates;\n\n      if (count == -1) {\n        task._zoneDelegates = null;\n      }\n\n      for (let i = 0; i < zoneDelegates.length; i++) {\n        zoneDelegates[i]._updateTaskCount(task.type, count);\n      }\n    }\n\n  } // tslint:disable-next-line:require-internal-with-underscore\n\n\n  Zone.__symbol__ = __symbol__;\n  const DELEGATE_ZS = {\n    name: '',\n    onHasTask: (delegate, _, target, hasTaskState) => delegate.hasTask(target, hasTaskState),\n    onScheduleTask: (delegate, _, target, task) => delegate.scheduleTask(target, task),\n    onInvokeTask: (delegate, _, target, task, applyThis, applyArgs) => delegate.invokeTask(target, task, applyThis, applyArgs),\n    onCancelTask: (delegate, _, target, task) => delegate.cancelTask(target, task)\n  };\n\n  class _ZoneDelegate {\n    constructor(zone, parentDelegate, zoneSpec) {\n      this._taskCounts = {\n        'microTask': 0,\n        'macroTask': 0,\n        'eventTask': 0\n      };\n      this.zone = zone;\n      this._parentDelegate = parentDelegate;\n      this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);\n      this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);\n      this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this.zone : parentDelegate._forkCurrZone);\n      this._interceptZS = zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);\n      this._interceptDlgt = zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);\n      this._interceptCurrZone = zoneSpec && (zoneSpec.onIntercept ? this.zone : parentDelegate._interceptCurrZone);\n      this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);\n      this._invokeDlgt = zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);\n      this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this.zone : parentDelegate._invokeCurrZone);\n      this._handleErrorZS = zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);\n      this._handleErrorDlgt = zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);\n      this._handleErrorCurrZone = zoneSpec && (zoneSpec.onHandleError ? this.zone : parentDelegate._handleErrorCurrZone);\n      this._scheduleTaskZS = zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);\n      this._scheduleTaskDlgt = zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);\n      this._scheduleTaskCurrZone = zoneSpec && (zoneSpec.onScheduleTask ? this.zone : parentDelegate._scheduleTaskCurrZone);\n      this._invokeTaskZS = zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);\n      this._invokeTaskDlgt = zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);\n      this._invokeTaskCurrZone = zoneSpec && (zoneSpec.onInvokeTask ? this.zone : parentDelegate._invokeTaskCurrZone);\n      this._cancelTaskZS = zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);\n      this._cancelTaskDlgt = zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);\n      this._cancelTaskCurrZone = zoneSpec && (zoneSpec.onCancelTask ? this.zone : parentDelegate._cancelTaskCurrZone);\n      this._hasTaskZS = null;\n      this._hasTaskDlgt = null;\n      this._hasTaskDlgtOwner = null;\n      this._hasTaskCurrZone = null;\n      const zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;\n      const parentHasTask = parentDelegate && parentDelegate._hasTaskZS;\n\n      if (zoneSpecHasTask || parentHasTask) {\n        // If we need to report hasTask, than this ZS needs to do ref counting on tasks. In such\n        // a case all task related interceptors must go through this ZD. We can't short circuit it.\n        this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;\n        this._hasTaskDlgt = parentDelegate;\n        this._hasTaskDlgtOwner = this;\n        this._hasTaskCurrZone = zone;\n\n        if (!zoneSpec.onScheduleTask) {\n          this._scheduleTaskZS = DELEGATE_ZS;\n          this._scheduleTaskDlgt = parentDelegate;\n          this._scheduleTaskCurrZone = this.zone;\n        }\n\n        if (!zoneSpec.onInvokeTask) {\n          this._invokeTaskZS = DELEGATE_ZS;\n          this._invokeTaskDlgt = parentDelegate;\n          this._invokeTaskCurrZone = this.zone;\n        }\n\n        if (!zoneSpec.onCancelTask) {\n          this._cancelTaskZS = DELEGATE_ZS;\n          this._cancelTaskDlgt = parentDelegate;\n          this._cancelTaskCurrZone = this.zone;\n        }\n      }\n    }\n\n    fork(targetZone, zoneSpec) {\n      return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) : new Zone(targetZone, zoneSpec);\n    }\n\n    intercept(targetZone, callback, source) {\n      return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) : callback;\n    }\n\n    invoke(targetZone, callback, applyThis, applyArgs, source) {\n      return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) : callback.apply(applyThis, applyArgs);\n    }\n\n    handleError(targetZone, error) {\n      return this._handleErrorZS ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) : true;\n    }\n\n    scheduleTask(targetZone, task) {\n      let returnTask = task;\n\n      if (this._scheduleTaskZS) {\n        if (this._hasTaskZS) {\n          returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);\n        } // clang-format off\n\n\n        returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task); // clang-format on\n\n        if (!returnTask) returnTask = task;\n      } else {\n        if (task.scheduleFn) {\n          task.scheduleFn(task);\n        } else if (task.type == microTask) {\n          scheduleMicroTask(task);\n        } else {\n          throw new Error('Task is missing scheduleFn.');\n        }\n      }\n\n      return returnTask;\n    }\n\n    invokeTask(targetZone, task, applyThis, applyArgs) {\n      return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) : task.callback.apply(applyThis, applyArgs);\n    }\n\n    cancelTask(targetZone, task) {\n      let value;\n\n      if (this._cancelTaskZS) {\n        value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);\n      } else {\n        if (!task.cancelFn) {\n          throw Error('Task is not cancelable');\n        }\n\n        value = task.cancelFn(task);\n      }\n\n      return value;\n    }\n\n    hasTask(targetZone, isEmpty) {\n      // hasTask should not throw error so other ZoneDelegate\n      // can still trigger hasTask callback\n      try {\n        this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);\n      } catch (err) {\n        this.handleError(targetZone, err);\n      }\n    } // tslint:disable-next-line:require-internal-with-underscore\n\n\n    _updateTaskCount(type, count) {\n      const counts = this._taskCounts;\n      const prev = counts[type];\n      const next = counts[type] = prev + count;\n\n      if (next < 0) {\n        throw new Error('More tasks executed then were scheduled.');\n      }\n\n      if (prev == 0 || next == 0) {\n        const isEmpty = {\n          microTask: counts['microTask'] > 0,\n          macroTask: counts['macroTask'] > 0,\n          eventTask: counts['eventTask'] > 0,\n          change: type\n        };\n        this.hasTask(this.zone, isEmpty);\n      }\n    }\n\n  }\n\n  class ZoneTask {\n    constructor(type, source, callback, options, scheduleFn, cancelFn) {\n      // tslint:disable-next-line:require-internal-with-underscore\n      this._zone = null;\n      this.runCount = 0; // tslint:disable-next-line:require-internal-with-underscore\n\n      this._zoneDelegates = null; // tslint:disable-next-line:require-internal-with-underscore\n\n      this._state = 'notScheduled';\n      this.type = type;\n      this.source = source;\n      this.data = options;\n      this.scheduleFn = scheduleFn;\n      this.cancelFn = cancelFn;\n\n      if (!callback) {\n        throw new Error('callback is not defined');\n      }\n\n      this.callback = callback;\n      const self = this; // TODO: @JiaLiPassion options should have interface\n\n      if (type === eventTask && options && options.useG) {\n        this.invoke = ZoneTask.invokeTask;\n      } else {\n        this.invoke = function () {\n          return ZoneTask.invokeTask.call(global, self, this, arguments);\n        };\n      }\n    }\n\n    static invokeTask(task, target, args) {\n      if (!task) {\n        task = this;\n      }\n\n      _numberOfNestedTaskFrames++;\n\n      try {\n        task.runCount++;\n        return task.zone.runTask(task, target, args);\n      } finally {\n        if (_numberOfNestedTaskFrames == 1) {\n          drainMicroTaskQueue();\n        }\n\n        _numberOfNestedTaskFrames--;\n      }\n    }\n\n    get zone() {\n      return this._zone;\n    }\n\n    get state() {\n      return this._state;\n    }\n\n    cancelScheduleRequest() {\n      this._transitionTo(notScheduled, scheduling);\n    } // tslint:disable-next-line:require-internal-with-underscore\n\n\n    _transitionTo(toState, fromState1, fromState2) {\n      if (this._state === fromState1 || this._state === fromState2) {\n        this._state = toState;\n\n        if (toState == notScheduled) {\n          this._zoneDelegates = null;\n        }\n      } else {\n        throw new Error(`${this.type} '${this.source}': can not transition to '${toState}', expecting state '${fromState1}'${fromState2 ? ' or \\'' + fromState2 + '\\'' : ''}, was '${this._state}'.`);\n      }\n    }\n\n    toString() {\n      if (this.data && typeof this.data.handleId !== 'undefined') {\n        return this.data.handleId.toString();\n      } else {\n        return Object.prototype.toString.call(this);\n      }\n    } // add toJSON method to prevent cyclic error when\n    // call JSON.stringify(zoneTask)\n\n\n    toJSON() {\n      return {\n        type: this.type,\n        state: this.state,\n        source: this.source,\n        zone: this.zone.name,\n        runCount: this.runCount\n      };\n    }\n\n  } //////////////////////////////////////////////////////\n  //////////////////////////////////////////////////////\n  ///  MICROTASK QUEUE\n  //////////////////////////////////////////////////////\n  //////////////////////////////////////////////////////\n\n\n  const symbolSetTimeout = __symbol__('setTimeout');\n\n  const symbolPromise = __symbol__('Promise');\n\n  const symbolThen = __symbol__('then');\n\n  let _microTaskQueue = [];\n  let _isDrainingMicrotaskQueue = false;\n  let nativeMicroTaskQueuePromise;\n\n  function nativeScheduleMicroTask(func) {\n    if (!nativeMicroTaskQueuePromise) {\n      if (global[symbolPromise]) {\n        nativeMicroTaskQueuePromise = global[symbolPromise].resolve(0);\n      }\n    }\n\n    if (nativeMicroTaskQueuePromise) {\n      let nativeThen = nativeMicroTaskQueuePromise[symbolThen];\n\n      if (!nativeThen) {\n        // native Promise is not patchable, we need to use `then` directly\n        // issue 1078\n        nativeThen = nativeMicroTaskQueuePromise['then'];\n      }\n\n      nativeThen.call(nativeMicroTaskQueuePromise, func);\n    } else {\n      global[symbolSetTimeout](func, 0);\n    }\n  }\n\n  function scheduleMicroTask(task) {\n    // if we are not running in any task, and there has not been anything scheduled\n    // we must bootstrap the initial task creation by manually scheduling the drain\n    if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {\n      // We are not running in Task, so we need to kickstart the microtask queue.\n      nativeScheduleMicroTask(drainMicroTaskQueue);\n    }\n\n    task && _microTaskQueue.push(task);\n  }\n\n  function drainMicroTaskQueue() {\n    if (!_isDrainingMicrotaskQueue) {\n      _isDrainingMicrotaskQueue = true;\n\n      while (_microTaskQueue.length) {\n        const queue = _microTaskQueue;\n        _microTaskQueue = [];\n\n        for (let i = 0; i < queue.length; i++) {\n          const task = queue[i];\n\n          try {\n            task.zone.runTask(task, null, null);\n          } catch (error) {\n            _api.onUnhandledError(error);\n          }\n        }\n      }\n\n      _api.microtaskDrainDone();\n\n      _isDrainingMicrotaskQueue = false;\n    }\n  } //////////////////////////////////////////////////////\n  //////////////////////////////////////////////////////\n  ///  BOOTSTRAP\n  //////////////////////////////////////////////////////\n  //////////////////////////////////////////////////////\n\n\n  const NO_ZONE = {\n    name: 'NO ZONE'\n  };\n  const notScheduled = 'notScheduled',\n        scheduling = 'scheduling',\n        scheduled = 'scheduled',\n        running = 'running',\n        canceling = 'canceling',\n        unknown = 'unknown';\n  const microTask = 'microTask',\n        macroTask = 'macroTask',\n        eventTask = 'eventTask';\n  const patches = {};\n  const _api = {\n    symbol: __symbol__,\n    currentZoneFrame: () => _currentZoneFrame,\n    onUnhandledError: noop,\n    microtaskDrainDone: noop,\n    scheduleMicroTask: scheduleMicroTask,\n    showUncaughtError: () => !Zone[__symbol__('ignoreConsoleErrorUncaughtError')],\n    patchEventTarget: () => [],\n    patchOnProperties: noop,\n    patchMethod: () => noop,\n    bindArguments: () => [],\n    patchThen: () => noop,\n    patchMacroTask: () => noop,\n    patchEventPrototype: () => noop,\n    isIEOrEdge: () => false,\n    getGlobalObjects: () => undefined,\n    ObjectDefineProperty: () => noop,\n    ObjectGetOwnPropertyDescriptor: () => undefined,\n    ObjectCreate: () => undefined,\n    ArraySlice: () => [],\n    patchClass: () => noop,\n    wrapWithCurrentZone: () => noop,\n    filterProperties: () => [],\n    attachOriginToPatched: () => noop,\n    _redefineProperty: () => noop,\n    patchCallbacks: () => noop,\n    nativeScheduleMicroTask: nativeScheduleMicroTask\n  };\n  let _currentZoneFrame = {\n    parent: null,\n    zone: new Zone(null, null)\n  };\n  let _currentTask = null;\n  let _numberOfNestedTaskFrames = 0;\n\n  function noop() {}\n\n  performanceMeasure('Zone', 'Zone');\n  return global['Zone'] = Zone;\n})(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || __webpack_require__.g);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Suppress closure compiler errors about unknown 'Zone' variable\n * @fileoverview\n * @suppress {undefinedVars,globalThis,missingRequire}\n */\n/// <reference types=\"node\"/>\n// issue #989, to reduce bundle size, use short name\n\n/** Object.getOwnPropertyDescriptor */\n\n\nconst ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n/** Object.defineProperty */\n\nconst ObjectDefineProperty = Object.defineProperty;\n/** Object.getPrototypeOf */\n\nconst ObjectGetPrototypeOf = Object.getPrototypeOf;\n/** Object.create */\n\nconst ObjectCreate = Object.create;\n/** Array.prototype.slice */\n\nconst ArraySlice = Array.prototype.slice;\n/** addEventListener string const */\n\nconst ADD_EVENT_LISTENER_STR = 'addEventListener';\n/** removeEventListener string const */\n\nconst REMOVE_EVENT_LISTENER_STR = 'removeEventListener';\n/** zoneSymbol addEventListener */\n\nconst ZONE_SYMBOL_ADD_EVENT_LISTENER = Zone.__symbol__(ADD_EVENT_LISTENER_STR);\n/** zoneSymbol removeEventListener */\n\n\nconst ZONE_SYMBOL_REMOVE_EVENT_LISTENER = Zone.__symbol__(REMOVE_EVENT_LISTENER_STR);\n/** true string const */\n\n\nconst TRUE_STR = 'true';\n/** false string const */\n\nconst FALSE_STR = 'false';\n/** Zone symbol prefix string const. */\n\nconst ZONE_SYMBOL_PREFIX = Zone.__symbol__('');\n\nfunction wrapWithCurrentZone(callback, source) {\n  return Zone.current.wrap(callback, source);\n}\n\nfunction scheduleMacroTaskWithCurrentZone(source, callback, data, customSchedule, customCancel) {\n  return Zone.current.scheduleMacroTask(source, callback, data, customSchedule, customCancel);\n}\n\nconst zoneSymbol = Zone.__symbol__;\nconst isWindowExists = typeof window !== 'undefined';\nconst internalWindow = isWindowExists ? window : undefined;\n\nconst _global = isWindowExists && internalWindow || typeof self === 'object' && self || __webpack_require__.g;\n\nconst REMOVE_ATTRIBUTE = 'removeAttribute';\n\nfunction bindArguments(args, source) {\n  for (let i = args.length - 1; i >= 0; i--) {\n    if (typeof args[i] === 'function') {\n      args[i] = wrapWithCurrentZone(args[i], source + '_' + i);\n    }\n  }\n\n  return args;\n}\n\nfunction patchPrototype(prototype, fnNames) {\n  const source = prototype.constructor['name'];\n\n  for (let i = 0; i < fnNames.length; i++) {\n    const name = fnNames[i];\n    const delegate = prototype[name];\n\n    if (delegate) {\n      const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, name);\n\n      if (!isPropertyWritable(prototypeDesc)) {\n        continue;\n      }\n\n      prototype[name] = (delegate => {\n        const patched = function () {\n          return delegate.apply(this, bindArguments(arguments, source + '.' + name));\n        };\n\n        attachOriginToPatched(patched, delegate);\n        return patched;\n      })(delegate);\n    }\n  }\n}\n\nfunction isPropertyWritable(propertyDesc) {\n  if (!propertyDesc) {\n    return true;\n  }\n\n  if (propertyDesc.writable === false) {\n    return false;\n  }\n\n  return !(typeof propertyDesc.get === 'function' && typeof propertyDesc.set === 'undefined');\n}\n\nconst isWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope; // Make sure to access `process` through `_global` so that WebPack does not accidentally browserify\n// this code.\n\nconst isNode = !('nw' in _global) && typeof _global.process !== 'undefined' && {}.toString.call(_global.process) === '[object process]';\nconst isBrowser = !isNode && !isWebWorker && !!(isWindowExists && internalWindow['HTMLElement']); // we are in electron of nw, so we are both browser and nodejs\n// Make sure to access `process` through `_global` so that WebPack does not accidentally browserify\n// this code.\n\nconst isMix = typeof _global.process !== 'undefined' && {}.toString.call(_global.process) === '[object process]' && !isWebWorker && !!(isWindowExists && internalWindow['HTMLElement']);\nconst zoneSymbolEventNames$1 = {};\n\nconst wrapFn = function (event) {\n  // https://github.com/angular/zone.js/issues/911, in IE, sometimes\n  // event will be undefined, so we need to use window.event\n  event = event || _global.event;\n\n  if (!event) {\n    return;\n  }\n\n  let eventNameSymbol = zoneSymbolEventNames$1[event.type];\n\n  if (!eventNameSymbol) {\n    eventNameSymbol = zoneSymbolEventNames$1[event.type] = zoneSymbol('ON_PROPERTY' + event.type);\n  }\n\n  const target = this || event.target || _global;\n  const listener = target[eventNameSymbol];\n  let result;\n\n  if (isBrowser && target === internalWindow && event.type === 'error') {\n    // window.onerror have different signiture\n    // https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror#window.onerror\n    // and onerror callback will prevent default when callback return true\n    const errorEvent = event;\n    result = listener && listener.call(this, errorEvent.message, errorEvent.filename, errorEvent.lineno, errorEvent.colno, errorEvent.error);\n\n    if (result === true) {\n      event.preventDefault();\n    }\n  } else {\n    result = listener && listener.apply(this, arguments);\n\n    if (result != undefined && !result) {\n      event.preventDefault();\n    }\n  }\n\n  return result;\n};\n\nfunction patchProperty(obj, prop, prototype) {\n  let desc = ObjectGetOwnPropertyDescriptor(obj, prop);\n\n  if (!desc && prototype) {\n    // when patch window object, use prototype to check prop exist or not\n    const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, prop);\n\n    if (prototypeDesc) {\n      desc = {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  } // if the descriptor not exists or is not configurable\n  // just return\n\n\n  if (!desc || !desc.configurable) {\n    return;\n  }\n\n  const onPropPatchedSymbol = zoneSymbol('on' + prop + 'patched');\n\n  if (obj.hasOwnProperty(onPropPatchedSymbol) && obj[onPropPatchedSymbol]) {\n    return;\n  } // A property descriptor cannot have getter/setter and be writable\n  // deleting the writable and value properties avoids this error:\n  //\n  // TypeError: property descriptors must not specify a value or be writable when a\n  // getter or setter has been specified\n\n\n  delete desc.writable;\n  delete desc.value;\n  const originalDescGet = desc.get;\n  const originalDescSet = desc.set; // substr(2) cuz 'onclick' -> 'click', etc\n\n  const eventName = prop.substr(2);\n  let eventNameSymbol = zoneSymbolEventNames$1[eventName];\n\n  if (!eventNameSymbol) {\n    eventNameSymbol = zoneSymbolEventNames$1[eventName] = zoneSymbol('ON_PROPERTY' + eventName);\n  }\n\n  desc.set = function (newValue) {\n    // in some of windows's onproperty callback, this is undefined\n    // so we need to check it\n    let target = this;\n\n    if (!target && obj === _global) {\n      target = _global;\n    }\n\n    if (!target) {\n      return;\n    }\n\n    const previousValue = target[eventNameSymbol];\n\n    if (typeof previousValue === 'function') {\n      target.removeEventListener(eventName, wrapFn);\n    } // issue #978, when onload handler was added before loading zone.js\n    // we should remove it with originalDescSet\n\n\n    originalDescSet && originalDescSet.call(target, null);\n    target[eventNameSymbol] = newValue;\n\n    if (typeof newValue === 'function') {\n      target.addEventListener(eventName, wrapFn, false);\n    }\n  }; // The getter would return undefined for unassigned properties but the default value of an\n  // unassigned property is null\n\n\n  desc.get = function () {\n    // in some of windows's onproperty callback, this is undefined\n    // so we need to check it\n    let target = this;\n\n    if (!target && obj === _global) {\n      target = _global;\n    }\n\n    if (!target) {\n      return null;\n    }\n\n    const listener = target[eventNameSymbol];\n\n    if (listener) {\n      return listener;\n    } else if (originalDescGet) {\n      // result will be null when use inline event attribute,\n      // such as <button onclick=\"func();\">OK</button>\n      // because the onclick function is internal raw uncompiled handler\n      // the onclick will be evaluated when first time event was triggered or\n      // the property is accessed, https://github.com/angular/zone.js/issues/525\n      // so we should use original native get to retrieve the handler\n      let value = originalDescGet.call(this);\n\n      if (value) {\n        desc.set.call(this, value);\n\n        if (typeof target[REMOVE_ATTRIBUTE] === 'function') {\n          target.removeAttribute(prop);\n        }\n\n        return value;\n      }\n    }\n\n    return null;\n  };\n\n  ObjectDefineProperty(obj, prop, desc);\n  obj[onPropPatchedSymbol] = true;\n}\n\nfunction patchOnProperties(obj, properties, prototype) {\n  if (properties) {\n    for (let i = 0; i < properties.length; i++) {\n      patchProperty(obj, 'on' + properties[i], prototype);\n    }\n  } else {\n    const onProperties = [];\n\n    for (const prop in obj) {\n      if (prop.substr(0, 2) == 'on') {\n        onProperties.push(prop);\n      }\n    }\n\n    for (let j = 0; j < onProperties.length; j++) {\n      patchProperty(obj, onProperties[j], prototype);\n    }\n  }\n}\n\nconst originalInstanceKey = zoneSymbol('originalInstance'); // wrap some native API on `window`\n\nfunction patchClass(className) {\n  const OriginalClass = _global[className];\n  if (!OriginalClass) return; // keep original class in global\n\n  _global[zoneSymbol(className)] = OriginalClass;\n\n  _global[className] = function () {\n    const a = bindArguments(arguments, className);\n\n    switch (a.length) {\n      case 0:\n        this[originalInstanceKey] = new OriginalClass();\n        break;\n\n      case 1:\n        this[originalInstanceKey] = new OriginalClass(a[0]);\n        break;\n\n      case 2:\n        this[originalInstanceKey] = new OriginalClass(a[0], a[1]);\n        break;\n\n      case 3:\n        this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);\n        break;\n\n      case 4:\n        this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);\n        break;\n\n      default:\n        throw new Error('Arg list too long.');\n    }\n  }; // attach original delegate to patched function\n\n\n  attachOriginToPatched(_global[className], OriginalClass);\n  const instance = new OriginalClass(function () {});\n  let prop;\n\n  for (prop in instance) {\n    // https://bugs.webkit.org/show_bug.cgi?id=44721\n    if (className === 'XMLHttpRequest' && prop === 'responseBlob') continue;\n\n    (function (prop) {\n      if (typeof instance[prop] === 'function') {\n        _global[className].prototype[prop] = function () {\n          return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);\n        };\n      } else {\n        ObjectDefineProperty(_global[className].prototype, prop, {\n          set: function (fn) {\n            if (typeof fn === 'function') {\n              this[originalInstanceKey][prop] = wrapWithCurrentZone(fn, className + '.' + prop); // keep callback in wrapped function so we can\n              // use it in Function.prototype.toString to return\n              // the native one.\n\n              attachOriginToPatched(this[originalInstanceKey][prop], fn);\n            } else {\n              this[originalInstanceKey][prop] = fn;\n            }\n          },\n          get: function () {\n            return this[originalInstanceKey][prop];\n          }\n        });\n      }\n    })(prop);\n  }\n\n  for (prop in OriginalClass) {\n    if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) {\n      _global[className][prop] = OriginalClass[prop];\n    }\n  }\n}\n\nfunction patchMethod(target, name, patchFn) {\n  let proto = target;\n\n  while (proto && !proto.hasOwnProperty(name)) {\n    proto = ObjectGetPrototypeOf(proto);\n  }\n\n  if (!proto && target[name]) {\n    // somehow we did not find it, but we can see it. This happens on IE for Window properties.\n    proto = target;\n  }\n\n  const delegateName = zoneSymbol(name);\n  let delegate = null;\n\n  if (proto && (!(delegate = proto[delegateName]) || !proto.hasOwnProperty(delegateName))) {\n    delegate = proto[delegateName] = proto[name]; // check whether proto[name] is writable\n    // some property is readonly in safari, such as HtmlCanvasElement.prototype.toBlob\n\n    const desc = proto && ObjectGetOwnPropertyDescriptor(proto, name);\n\n    if (isPropertyWritable(desc)) {\n      const patchDelegate = patchFn(delegate, delegateName, name);\n\n      proto[name] = function () {\n        return patchDelegate(this, arguments);\n      };\n\n      attachOriginToPatched(proto[name], delegate);\n    }\n  }\n\n  return delegate;\n} // TODO: @JiaLiPassion, support cancel task later if necessary\n\n\nfunction patchMacroTask(obj, funcName, metaCreator) {\n  let setNative = null;\n\n  function scheduleTask(task) {\n    const data = task.data;\n\n    data.args[data.cbIdx] = function () {\n      task.invoke.apply(this, arguments);\n    };\n\n    setNative.apply(data.target, data.args);\n    return task;\n  }\n\n  setNative = patchMethod(obj, funcName, delegate => function (self, args) {\n    const meta = metaCreator(self, args);\n\n    if (meta.cbIdx >= 0 && typeof args[meta.cbIdx] === 'function') {\n      return scheduleMacroTaskWithCurrentZone(meta.name, args[meta.cbIdx], meta, scheduleTask);\n    } else {\n      // cause an error by calling it directly.\n      return delegate.apply(self, args);\n    }\n  });\n}\n\nfunction attachOriginToPatched(patched, original) {\n  patched[zoneSymbol('OriginalDelegate')] = original;\n}\n\nlet isDetectedIEOrEdge = false;\nlet ieOrEdge = false;\n\nfunction isIE() {\n  try {\n    const ua = internalWindow.navigator.userAgent;\n\n    if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1) {\n      return true;\n    }\n  } catch (error) {}\n\n  return false;\n}\n\nfunction isIEOrEdge() {\n  if (isDetectedIEOrEdge) {\n    return ieOrEdge;\n  }\n\n  isDetectedIEOrEdge = true;\n\n  try {\n    const ua = internalWindow.navigator.userAgent;\n\n    if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1 || ua.indexOf('Edge/') !== -1) {\n      ieOrEdge = true;\n    }\n  } catch (error) {}\n\n  return ieOrEdge;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nZone.__load_patch('ZoneAwarePromise', (global, Zone, api) => {\n  const ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n  const ObjectDefineProperty = Object.defineProperty;\n\n  function readableObjectToString(obj) {\n    if (obj && obj.toString === Object.prototype.toString) {\n      const className = obj.constructor && obj.constructor.name;\n      return (className ? className : '') + ': ' + JSON.stringify(obj);\n    }\n\n    return obj ? obj.toString() : Object.prototype.toString.call(obj);\n  }\n\n  const __symbol__ = api.symbol;\n  const _uncaughtPromiseErrors = [];\n  const isDisableWrappingUncaughtPromiseRejection = global[__symbol__('DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION')] === true;\n\n  const symbolPromise = __symbol__('Promise');\n\n  const symbolThen = __symbol__('then');\n\n  const creationTrace = '__creationTrace__';\n\n  api.onUnhandledError = e => {\n    if (api.showUncaughtError()) {\n      const rejection = e && e.rejection;\n\n      if (rejection) {\n        console.error('Unhandled Promise rejection:', rejection instanceof Error ? rejection.message : rejection, '; Zone:', e.zone.name, '; Task:', e.task && e.task.source, '; Value:', rejection, rejection instanceof Error ? rejection.stack : undefined);\n      } else {\n        console.error(e);\n      }\n    }\n  };\n\n  api.microtaskDrainDone = () => {\n    while (_uncaughtPromiseErrors.length) {\n      const uncaughtPromiseError = _uncaughtPromiseErrors.shift();\n\n      try {\n        uncaughtPromiseError.zone.runGuarded(() => {\n          if (uncaughtPromiseError.throwOriginal) {\n            throw uncaughtPromiseError.rejection;\n          }\n\n          throw uncaughtPromiseError;\n        });\n      } catch (error) {\n        handleUnhandledRejection(error);\n      }\n    }\n  };\n\n  const UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__('unhandledPromiseRejectionHandler');\n\n  function handleUnhandledRejection(e) {\n    api.onUnhandledError(e);\n\n    try {\n      const handler = Zone[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];\n\n      if (typeof handler === 'function') {\n        handler.call(this, e);\n      }\n    } catch (err) {}\n  }\n\n  function isThenable(value) {\n    return value && value.then;\n  }\n\n  function forwardResolution(value) {\n    return value;\n  }\n\n  function forwardRejection(rejection) {\n    return ZoneAwarePromise.reject(rejection);\n  }\n\n  const symbolState = __symbol__('state');\n\n  const symbolValue = __symbol__('value');\n\n  const symbolFinally = __symbol__('finally');\n\n  const symbolParentPromiseValue = __symbol__('parentPromiseValue');\n\n  const symbolParentPromiseState = __symbol__('parentPromiseState');\n\n  const source = 'Promise.then';\n  const UNRESOLVED = null;\n  const RESOLVED = true;\n  const REJECTED = false;\n  const REJECTED_NO_CATCH = 0;\n\n  function makeResolver(promise, state) {\n    return v => {\n      try {\n        resolvePromise(promise, state, v);\n      } catch (err) {\n        resolvePromise(promise, false, err);\n      } // Do not return value or you will break the Promise spec.\n\n    };\n  }\n\n  const once = function () {\n    let wasCalled = false;\n    return function wrapper(wrappedFunction) {\n      return function () {\n        if (wasCalled) {\n          return;\n        }\n\n        wasCalled = true;\n        wrappedFunction.apply(null, arguments);\n      };\n    };\n  };\n\n  const TYPE_ERROR = 'Promise resolved with itself';\n\n  const CURRENT_TASK_TRACE_SYMBOL = __symbol__('currentTaskTrace'); // Promise Resolution\n\n\n  function resolvePromise(promise, state, value) {\n    const onceWrapper = once();\n\n    if (promise === value) {\n      throw new TypeError(TYPE_ERROR);\n    }\n\n    if (promise[symbolState] === UNRESOLVED) {\n      // should only get value.then once based on promise spec.\n      let then = null;\n\n      try {\n        if (typeof value === 'object' || typeof value === 'function') {\n          then = value && value.then;\n        }\n      } catch (err) {\n        onceWrapper(() => {\n          resolvePromise(promise, false, err);\n        })();\n        return promise;\n      } // if (value instanceof ZoneAwarePromise) {\n\n\n      if (state !== REJECTED && value instanceof ZoneAwarePromise && value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) && value[symbolState] !== UNRESOLVED) {\n        clearRejectedNoCatch(value);\n        resolvePromise(promise, value[symbolState], value[symbolValue]);\n      } else if (state !== REJECTED && typeof then === 'function') {\n        try {\n          then.call(value, onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false)));\n        } catch (err) {\n          onceWrapper(() => {\n            resolvePromise(promise, false, err);\n          })();\n        }\n      } else {\n        promise[symbolState] = state;\n        const queue = promise[symbolValue];\n        promise[symbolValue] = value;\n\n        if (promise[symbolFinally] === symbolFinally) {\n          // the promise is generated by Promise.prototype.finally\n          if (state === RESOLVED) {\n            // the state is resolved, should ignore the value\n            // and use parent promise value\n            promise[symbolState] = promise[symbolParentPromiseState];\n            promise[symbolValue] = promise[symbolParentPromiseValue];\n          }\n        } // record task information in value when error occurs, so we can\n        // do some additional work such as render longStackTrace\n\n\n        if (state === REJECTED && value instanceof Error) {\n          // check if longStackTraceZone is here\n          const trace = Zone.currentTask && Zone.currentTask.data && Zone.currentTask.data[creationTrace];\n\n          if (trace) {\n            // only keep the long stack trace into error when in longStackTraceZone\n            ObjectDefineProperty(value, CURRENT_TASK_TRACE_SYMBOL, {\n              configurable: true,\n              enumerable: false,\n              writable: true,\n              value: trace\n            });\n          }\n        }\n\n        for (let i = 0; i < queue.length;) {\n          scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);\n        }\n\n        if (queue.length == 0 && state == REJECTED) {\n          promise[symbolState] = REJECTED_NO_CATCH;\n          let uncaughtPromiseError = value;\n\n          try {\n            // Here we throws a new Error to print more readable error log\n            // and if the value is not an error, zone.js builds an `Error`\n            // Object here to attach the stack information.\n            throw new Error('Uncaught (in promise): ' + readableObjectToString(value) + (value && value.stack ? '\\n' + value.stack : ''));\n          } catch (err) {\n            uncaughtPromiseError = err;\n          }\n\n          if (isDisableWrappingUncaughtPromiseRejection) {\n            // If disable wrapping uncaught promise reject\n            // use the value instead of wrapping it.\n            uncaughtPromiseError.throwOriginal = true;\n          }\n\n          uncaughtPromiseError.rejection = value;\n          uncaughtPromiseError.promise = promise;\n          uncaughtPromiseError.zone = Zone.current;\n          uncaughtPromiseError.task = Zone.currentTask;\n\n          _uncaughtPromiseErrors.push(uncaughtPromiseError);\n\n          api.scheduleMicroTask(); // to make sure that it is running\n        }\n      }\n    } // Resolving an already resolved promise is a noop.\n\n\n    return promise;\n  }\n\n  const REJECTION_HANDLED_HANDLER = __symbol__('rejectionHandledHandler');\n\n  function clearRejectedNoCatch(promise) {\n    if (promise[symbolState] === REJECTED_NO_CATCH) {\n      // if the promise is rejected no catch status\n      // and queue.length > 0, means there is a error handler\n      // here to handle the rejected promise, we should trigger\n      // windows.rejectionhandled eventHandler or nodejs rejectionHandled\n      // eventHandler\n      try {\n        const handler = Zone[REJECTION_HANDLED_HANDLER];\n\n        if (handler && typeof handler === 'function') {\n          handler.call(this, {\n            rejection: promise[symbolValue],\n            promise: promise\n          });\n        }\n      } catch (err) {}\n\n      promise[symbolState] = REJECTED;\n\n      for (let i = 0; i < _uncaughtPromiseErrors.length; i++) {\n        if (promise === _uncaughtPromiseErrors[i].promise) {\n          _uncaughtPromiseErrors.splice(i, 1);\n        }\n      }\n    }\n  }\n\n  function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {\n    clearRejectedNoCatch(promise);\n    const promiseState = promise[symbolState];\n    const delegate = promiseState ? typeof onFulfilled === 'function' ? onFulfilled : forwardResolution : typeof onRejected === 'function' ? onRejected : forwardRejection;\n    zone.scheduleMicroTask(source, () => {\n      try {\n        const parentPromiseValue = promise[symbolValue];\n        const isFinallyPromise = !!chainPromise && symbolFinally === chainPromise[symbolFinally];\n\n        if (isFinallyPromise) {\n          // if the promise is generated from finally call, keep parent promise's state and value\n          chainPromise[symbolParentPromiseValue] = parentPromiseValue;\n          chainPromise[symbolParentPromiseState] = promiseState;\n        } // should not pass value to finally callback\n\n\n        const value = zone.run(delegate, undefined, isFinallyPromise && delegate !== forwardRejection && delegate !== forwardResolution ? [] : [parentPromiseValue]);\n        resolvePromise(chainPromise, true, value);\n      } catch (error) {\n        // if error occurs, should always return this error\n        resolvePromise(chainPromise, false, error);\n      }\n    }, chainPromise);\n  }\n\n  const ZONE_AWARE_PROMISE_TO_STRING = 'function ZoneAwarePromise() { [native code] }';\n\n  const noop = function () {};\n\n  const AggregateError = global.AggregateError;\n\n  class ZoneAwarePromise {\n    static toString() {\n      return ZONE_AWARE_PROMISE_TO_STRING;\n    }\n\n    static resolve(value) {\n      return resolvePromise(new this(null), RESOLVED, value);\n    }\n\n    static reject(error) {\n      return resolvePromise(new this(null), REJECTED, error);\n    }\n\n    static any(values) {\n      if (!values || typeof values[Symbol.iterator] !== 'function') {\n        return Promise.reject(new AggregateError([], 'All promises were rejected'));\n      }\n\n      const promises = [];\n      let count = 0;\n\n      try {\n        for (let v of values) {\n          count++;\n          promises.push(ZoneAwarePromise.resolve(v));\n        }\n      } catch (err) {\n        return Promise.reject(new AggregateError([], 'All promises were rejected'));\n      }\n\n      if (count === 0) {\n        return Promise.reject(new AggregateError([], 'All promises were rejected'));\n      }\n\n      let finished = false;\n      const errors = [];\n      return new ZoneAwarePromise((resolve, reject) => {\n        for (let i = 0; i < promises.length; i++) {\n          promises[i].then(v => {\n            if (finished) {\n              return;\n            }\n\n            finished = true;\n            resolve(v);\n          }, err => {\n            errors.push(err);\n            count--;\n\n            if (count === 0) {\n              finished = true;\n              reject(new AggregateError(errors, 'All promises were rejected'));\n            }\n          });\n        }\n      });\n    }\n\n    static race(values) {\n      let resolve;\n      let reject;\n      let promise = new this((res, rej) => {\n        resolve = res;\n        reject = rej;\n      });\n\n      function onResolve(value) {\n        resolve(value);\n      }\n\n      function onReject(error) {\n        reject(error);\n      }\n\n      for (let value of values) {\n        if (!isThenable(value)) {\n          value = this.resolve(value);\n        }\n\n        value.then(onResolve, onReject);\n      }\n\n      return promise;\n    }\n\n    static all(values) {\n      return ZoneAwarePromise.allWithCallback(values);\n    }\n\n    static allSettled(values) {\n      const P = this && this.prototype instanceof ZoneAwarePromise ? this : ZoneAwarePromise;\n      return P.allWithCallback(values, {\n        thenCallback: value => ({\n          status: 'fulfilled',\n          value\n        }),\n        errorCallback: err => ({\n          status: 'rejected',\n          reason: err\n        })\n      });\n    }\n\n    static allWithCallback(values, callback) {\n      let resolve;\n      let reject;\n      let promise = new this((res, rej) => {\n        resolve = res;\n        reject = rej;\n      }); // Start at 2 to prevent prematurely resolving if .then is called immediately.\n\n      let unresolvedCount = 2;\n      let valueIndex = 0;\n      const resolvedValues = [];\n\n      for (let value of values) {\n        if (!isThenable(value)) {\n          value = this.resolve(value);\n        }\n\n        const curValueIndex = valueIndex;\n\n        try {\n          value.then(value => {\n            resolvedValues[curValueIndex] = callback ? callback.thenCallback(value) : value;\n            unresolvedCount--;\n\n            if (unresolvedCount === 0) {\n              resolve(resolvedValues);\n            }\n          }, err => {\n            if (!callback) {\n              reject(err);\n            } else {\n              resolvedValues[curValueIndex] = callback.errorCallback(err);\n              unresolvedCount--;\n\n              if (unresolvedCount === 0) {\n                resolve(resolvedValues);\n              }\n            }\n          });\n        } catch (thenErr) {\n          reject(thenErr);\n        }\n\n        unresolvedCount++;\n        valueIndex++;\n      } // Make the unresolvedCount zero-based again.\n\n\n      unresolvedCount -= 2;\n\n      if (unresolvedCount === 0) {\n        resolve(resolvedValues);\n      }\n\n      return promise;\n    }\n\n    constructor(executor) {\n      const promise = this;\n\n      if (!(promise instanceof ZoneAwarePromise)) {\n        throw new Error('Must be an instanceof Promise.');\n      }\n\n      promise[symbolState] = UNRESOLVED;\n      promise[symbolValue] = []; // queue;\n\n      try {\n        executor && executor(makeResolver(promise, RESOLVED), makeResolver(promise, REJECTED));\n      } catch (error) {\n        resolvePromise(promise, false, error);\n      }\n    }\n\n    get [Symbol.toStringTag]() {\n      return 'Promise';\n    }\n\n    get [Symbol.species]() {\n      return ZoneAwarePromise;\n    }\n\n    then(onFulfilled, onRejected) {\n      let C = this.constructor[Symbol.species];\n\n      if (!C || typeof C !== 'function') {\n        C = this.constructor || ZoneAwarePromise;\n      }\n\n      const chainPromise = new C(noop);\n      const zone = Zone.current;\n\n      if (this[symbolState] == UNRESOLVED) {\n        this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);\n      } else {\n        scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);\n      }\n\n      return chainPromise;\n    }\n\n    catch(onRejected) {\n      return this.then(null, onRejected);\n    }\n\n    finally(onFinally) {\n      let C = this.constructor[Symbol.species];\n\n      if (!C || typeof C !== 'function') {\n        C = ZoneAwarePromise;\n      }\n\n      const chainPromise = new C(noop);\n      chainPromise[symbolFinally] = symbolFinally;\n      const zone = Zone.current;\n\n      if (this[symbolState] == UNRESOLVED) {\n        this[symbolValue].push(zone, chainPromise, onFinally, onFinally);\n      } else {\n        scheduleResolveOrReject(this, zone, chainPromise, onFinally, onFinally);\n      }\n\n      return chainPromise;\n    }\n\n  } // Protect against aggressive optimizers dropping seemingly unused properties.\n  // E.g. Closure Compiler in advanced mode.\n\n\n  ZoneAwarePromise['resolve'] = ZoneAwarePromise.resolve;\n  ZoneAwarePromise['reject'] = ZoneAwarePromise.reject;\n  ZoneAwarePromise['race'] = ZoneAwarePromise.race;\n  ZoneAwarePromise['all'] = ZoneAwarePromise.all;\n  const NativePromise = global[symbolPromise] = global['Promise'];\n  global['Promise'] = ZoneAwarePromise;\n\n  const symbolThenPatched = __symbol__('thenPatched');\n\n  function patchThen(Ctor) {\n    const proto = Ctor.prototype;\n    const prop = ObjectGetOwnPropertyDescriptor(proto, 'then');\n\n    if (prop && (prop.writable === false || !prop.configurable)) {\n      // check Ctor.prototype.then propertyDescriptor is writable or not\n      // in meteor env, writable is false, we should ignore such case\n      return;\n    }\n\n    const originalThen = proto.then; // Keep a reference to the original method.\n\n    proto[symbolThen] = originalThen;\n\n    Ctor.prototype.then = function (onResolve, onReject) {\n      const wrapped = new ZoneAwarePromise((resolve, reject) => {\n        originalThen.call(this, resolve, reject);\n      });\n      return wrapped.then(onResolve, onReject);\n    };\n\n    Ctor[symbolThenPatched] = true;\n  }\n\n  api.patchThen = patchThen;\n\n  function zoneify(fn) {\n    return function (self, args) {\n      let resultPromise = fn.apply(self, args);\n\n      if (resultPromise instanceof ZoneAwarePromise) {\n        return resultPromise;\n      }\n\n      let ctor = resultPromise.constructor;\n\n      if (!ctor[symbolThenPatched]) {\n        patchThen(ctor);\n      }\n\n      return resultPromise;\n    };\n  }\n\n  if (NativePromise) {\n    patchThen(NativePromise);\n    patchMethod(global, 'fetch', delegate => zoneify(delegate));\n  } // This is not part of public API, but it is useful for tests, so we expose it.\n\n\n  Promise[Zone.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;\n  return ZoneAwarePromise;\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// override Function.prototype.toString to make zone.js patched function\n// look like native function\n\n\nZone.__load_patch('toString', global => {\n  // patch Func.prototype.toString to let them look like native\n  const originalFunctionToString = Function.prototype.toString;\n  const ORIGINAL_DELEGATE_SYMBOL = zoneSymbol('OriginalDelegate');\n  const PROMISE_SYMBOL = zoneSymbol('Promise');\n  const ERROR_SYMBOL = zoneSymbol('Error');\n\n  const newFunctionToString = function toString() {\n    if (typeof this === 'function') {\n      const originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];\n\n      if (originalDelegate) {\n        if (typeof originalDelegate === 'function') {\n          return originalFunctionToString.call(originalDelegate);\n        } else {\n          return Object.prototype.toString.call(originalDelegate);\n        }\n      }\n\n      if (this === Promise) {\n        const nativePromise = global[PROMISE_SYMBOL];\n\n        if (nativePromise) {\n          return originalFunctionToString.call(nativePromise);\n        }\n      }\n\n      if (this === Error) {\n        const nativeError = global[ERROR_SYMBOL];\n\n        if (nativeError) {\n          return originalFunctionToString.call(nativeError);\n        }\n      }\n    }\n\n    return originalFunctionToString.call(this);\n  };\n\n  newFunctionToString[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString;\n  Function.prototype.toString = newFunctionToString; // patch Object.prototype.toString to let them look like native\n\n  const originalObjectToString = Object.prototype.toString;\n  const PROMISE_OBJECT_TO_STRING = '[object Promise]';\n\n  Object.prototype.toString = function () {\n    if (typeof Promise === 'function' && this instanceof Promise) {\n      return PROMISE_OBJECT_TO_STRING;\n    }\n\n    return originalObjectToString.call(this);\n  };\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nlet passiveSupported = false;\n\nif (typeof window !== 'undefined') {\n  try {\n    const options = Object.defineProperty({}, 'passive', {\n      get: function () {\n        passiveSupported = true;\n      }\n    }); // Note: We pass the `options` object as the event handler too. This is not compatible with the\n    // signature of `addEventListener` or `removeEventListener` but enables us to remove the handler\n    // without an actual handler.\n\n    window.addEventListener('test', options, options);\n    window.removeEventListener('test', options, options);\n  } catch (err) {\n    passiveSupported = false;\n  }\n} // an identifier to tell ZoneTask do not create a new invoke closure\n\n\nconst OPTIMIZED_ZONE_EVENT_TASK_DATA = {\n  useG: true\n};\nconst zoneSymbolEventNames = {};\nconst globalSources = {};\nconst EVENT_NAME_SYMBOL_REGX = new RegExp('^' + ZONE_SYMBOL_PREFIX + '(\\\\w+)(true|false)$');\nconst IMMEDIATE_PROPAGATION_SYMBOL = zoneSymbol('propagationStopped');\n\nfunction prepareEventNames(eventName, eventNameToString) {\n  const falseEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + FALSE_STR;\n  const trueEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + TRUE_STR;\n  const symbol = ZONE_SYMBOL_PREFIX + falseEventName;\n  const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;\n  zoneSymbolEventNames[eventName] = {};\n  zoneSymbolEventNames[eventName][FALSE_STR] = symbol;\n  zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;\n}\n\nfunction patchEventTarget(_global, api, apis, patchOptions) {\n  const ADD_EVENT_LISTENER = patchOptions && patchOptions.add || ADD_EVENT_LISTENER_STR;\n  const REMOVE_EVENT_LISTENER = patchOptions && patchOptions.rm || REMOVE_EVENT_LISTENER_STR;\n  const LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.listeners || 'eventListeners';\n  const REMOVE_ALL_LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.rmAll || 'removeAllListeners';\n  const zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);\n  const ADD_EVENT_LISTENER_SOURCE = '.' + ADD_EVENT_LISTENER + ':';\n  const PREPEND_EVENT_LISTENER = 'prependListener';\n  const PREPEND_EVENT_LISTENER_SOURCE = '.' + PREPEND_EVENT_LISTENER + ':';\n\n  const invokeTask = function (task, target, event) {\n    // for better performance, check isRemoved which is set\n    // by removeEventListener\n    if (task.isRemoved) {\n      return;\n    }\n\n    const delegate = task.callback;\n\n    if (typeof delegate === 'object' && delegate.handleEvent) {\n      // create the bind version of handleEvent when invoke\n      task.callback = event => delegate.handleEvent(event);\n\n      task.originalDelegate = delegate;\n    } // invoke static task.invoke\n    // need to try/catch error here, otherwise, the error in one event listener\n    // will break the executions of the other event listeners. Also error will\n    // not remove the event listener when `once` options is true.\n\n\n    let error;\n\n    try {\n      task.invoke(task, target, [event]);\n    } catch (err) {\n      error = err;\n    }\n\n    const options = task.options;\n\n    if (options && typeof options === 'object' && options.once) {\n      // if options.once is true, after invoke once remove listener here\n      // only browser need to do this, nodejs eventEmitter will cal removeListener\n      // inside EventEmitter.once\n      const delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n      target[REMOVE_EVENT_LISTENER].call(target, event.type, delegate, options);\n    }\n\n    return error;\n  };\n\n  function globalCallback(context, event, isCapture) {\n    // https://github.com/angular/zone.js/issues/911, in IE, sometimes\n    // event will be undefined, so we need to use window.event\n    event = event || _global.event;\n\n    if (!event) {\n      return;\n    } // event.target is needed for Samsung TV and SourceBuffer\n    // || global is needed https://github.com/angular/zone.js/issues/190\n\n\n    const target = context || event.target || _global;\n    const tasks = target[zoneSymbolEventNames[event.type][isCapture ? TRUE_STR : FALSE_STR]];\n\n    if (tasks) {\n      const errors = []; // invoke all tasks which attached to current target with given event.type and capture = false\n      // for performance concern, if task.length === 1, just invoke\n\n      if (tasks.length === 1) {\n        const err = invokeTask(tasks[0], target, event);\n        err && errors.push(err);\n      } else {\n        // https://github.com/angular/zone.js/issues/836\n        // copy the tasks array before invoke, to avoid\n        // the callback will remove itself or other listener\n        const copyTasks = tasks.slice();\n\n        for (let i = 0; i < copyTasks.length; i++) {\n          if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {\n            break;\n          }\n\n          const err = invokeTask(copyTasks[i], target, event);\n          err && errors.push(err);\n        }\n      } // Since there is only one error, we don't need to schedule microTask\n      // to throw the error.\n\n\n      if (errors.length === 1) {\n        throw errors[0];\n      } else {\n        for (let i = 0; i < errors.length; i++) {\n          const err = errors[i];\n          api.nativeScheduleMicroTask(() => {\n            throw err;\n          });\n        }\n      }\n    }\n  } // global shared zoneAwareCallback to handle all event callback with capture = false\n\n\n  const globalZoneAwareCallback = function (event) {\n    return globalCallback(this, event, false);\n  }; // global shared zoneAwareCallback to handle all event callback with capture = true\n\n\n  const globalZoneAwareCaptureCallback = function (event) {\n    return globalCallback(this, event, true);\n  };\n\n  function patchEventTargetMethods(obj, patchOptions) {\n    if (!obj) {\n      return false;\n    }\n\n    let useGlobalCallback = true;\n\n    if (patchOptions && patchOptions.useG !== undefined) {\n      useGlobalCallback = patchOptions.useG;\n    }\n\n    const validateHandler = patchOptions && patchOptions.vh;\n    let checkDuplicate = true;\n\n    if (patchOptions && patchOptions.chkDup !== undefined) {\n      checkDuplicate = patchOptions.chkDup;\n    }\n\n    let returnTarget = false;\n\n    if (patchOptions && patchOptions.rt !== undefined) {\n      returnTarget = patchOptions.rt;\n    }\n\n    let proto = obj;\n\n    while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {\n      proto = ObjectGetPrototypeOf(proto);\n    }\n\n    if (!proto && obj[ADD_EVENT_LISTENER]) {\n      // somehow we did not find it, but we can see it. This happens on IE for Window properties.\n      proto = obj;\n    }\n\n    if (!proto) {\n      return false;\n    }\n\n    if (proto[zoneSymbolAddEventListener]) {\n      return false;\n    }\n\n    const eventNameToString = patchOptions && patchOptions.eventNameToString; // a shared global taskData to pass data for scheduleEventTask\n    // so we do not need to create a new object just for pass some data\n\n    const taskData = {};\n    const nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];\n    const nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] = proto[REMOVE_EVENT_LISTENER];\n    const nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] = proto[LISTENERS_EVENT_LISTENER];\n    const nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] = proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];\n    let nativePrependEventListener;\n\n    if (patchOptions && patchOptions.prepend) {\n      nativePrependEventListener = proto[zoneSymbol(patchOptions.prepend)] = proto[patchOptions.prepend];\n    }\n    /**\n     * This util function will build an option object with passive option\n     * to handle all possible input from the user.\n     */\n\n\n    function buildEventListenerOptions(options, passive) {\n      if (!passiveSupported && typeof options === 'object' && options) {\n        // doesn't support passive but user want to pass an object as options.\n        // this will not work on some old browser, so we just pass a boolean\n        // as useCapture parameter\n        return !!options.capture;\n      }\n\n      if (!passiveSupported || !passive) {\n        return options;\n      }\n\n      if (typeof options === 'boolean') {\n        return {\n          capture: options,\n          passive: true\n        };\n      }\n\n      if (!options) {\n        return {\n          passive: true\n        };\n      }\n\n      if (typeof options === 'object' && options.passive !== false) {\n        return Object.assign(Object.assign({}, options), {\n          passive: true\n        });\n      }\n\n      return options;\n    }\n\n    const customScheduleGlobal = function (task) {\n      // if there is already a task for the eventName + capture,\n      // just return, because we use the shared globalZoneAwareCallback here.\n      if (taskData.isExisting) {\n        return;\n      }\n\n      return nativeAddEventListener.call(taskData.target, taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options);\n    };\n\n    const customCancelGlobal = function (task) {\n      // if task is not marked as isRemoved, this call is directly\n      // from Zone.prototype.cancelTask, we should remove the task\n      // from tasksList of target first\n      if (!task.isRemoved) {\n        const symbolEventNames = zoneSymbolEventNames[task.eventName];\n        let symbolEventName;\n\n        if (symbolEventNames) {\n          symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];\n        }\n\n        const existingTasks = symbolEventName && task.target[symbolEventName];\n\n        if (existingTasks) {\n          for (let i = 0; i < existingTasks.length; i++) {\n            const existingTask = existingTasks[i];\n\n            if (existingTask === task) {\n              existingTasks.splice(i, 1); // set isRemoved to data for faster invokeTask check\n\n              task.isRemoved = true;\n\n              if (existingTasks.length === 0) {\n                // all tasks for the eventName + capture have gone,\n                // remove globalZoneAwareCallback and remove the task cache from target\n                task.allRemoved = true;\n                task.target[symbolEventName] = null;\n              }\n\n              break;\n            }\n          }\n        }\n      } // if all tasks for the eventName + capture have gone,\n      // we will really remove the global event callback,\n      // if not, return\n\n\n      if (!task.allRemoved) {\n        return;\n      }\n\n      return nativeRemoveEventListener.call(task.target, task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options);\n    };\n\n    const customScheduleNonGlobal = function (task) {\n      return nativeAddEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);\n    };\n\n    const customSchedulePrepend = function (task) {\n      return nativePrependEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);\n    };\n\n    const customCancelNonGlobal = function (task) {\n      return nativeRemoveEventListener.call(task.target, task.eventName, task.invoke, task.options);\n    };\n\n    const customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;\n    const customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;\n\n    const compareTaskCallbackVsDelegate = function (task, delegate) {\n      const typeOfDelegate = typeof delegate;\n      return typeOfDelegate === 'function' && task.callback === delegate || typeOfDelegate === 'object' && task.originalDelegate === delegate;\n    };\n\n    const compare = patchOptions && patchOptions.diff ? patchOptions.diff : compareTaskCallbackVsDelegate;\n    const unpatchedEvents = Zone[zoneSymbol('UNPATCHED_EVENTS')];\n\n    const passiveEvents = _global[zoneSymbol('PASSIVE_EVENTS')];\n\n    const makeAddListener = function (nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget = false, prepend = false) {\n      return function () {\n        const target = this || _global;\n        let eventName = arguments[0];\n\n        if (patchOptions && patchOptions.transferEventName) {\n          eventName = patchOptions.transferEventName(eventName);\n        }\n\n        let delegate = arguments[1];\n\n        if (!delegate) {\n          return nativeListener.apply(this, arguments);\n        }\n\n        if (isNode && eventName === 'uncaughtException') {\n          // don't patch uncaughtException of nodejs to prevent endless loop\n          return nativeListener.apply(this, arguments);\n        } // don't create the bind delegate function for handleEvent\n        // case here to improve addEventListener performance\n        // we will create the bind delegate when invoke\n\n\n        let isHandleEvent = false;\n\n        if (typeof delegate !== 'function') {\n          if (!delegate.handleEvent) {\n            return nativeListener.apply(this, arguments);\n          }\n\n          isHandleEvent = true;\n        }\n\n        if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {\n          return;\n        }\n\n        const passive = passiveSupported && !!passiveEvents && passiveEvents.indexOf(eventName) !== -1;\n        const options = buildEventListenerOptions(arguments[2], passive);\n\n        if (unpatchedEvents) {\n          // check upatched list\n          for (let i = 0; i < unpatchedEvents.length; i++) {\n            if (eventName === unpatchedEvents[i]) {\n              if (passive) {\n                return nativeListener.call(target, eventName, delegate, options);\n              } else {\n                return nativeListener.apply(this, arguments);\n              }\n            }\n          }\n        }\n\n        const capture = !options ? false : typeof options === 'boolean' ? true : options.capture;\n        const once = options && typeof options === 'object' ? options.once : false;\n        const zone = Zone.current;\n        let symbolEventNames = zoneSymbolEventNames[eventName];\n\n        if (!symbolEventNames) {\n          prepareEventNames(eventName, eventNameToString);\n          symbolEventNames = zoneSymbolEventNames[eventName];\n        }\n\n        const symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];\n        let existingTasks = target[symbolEventName];\n        let isExisting = false;\n\n        if (existingTasks) {\n          // already have task registered\n          isExisting = true;\n\n          if (checkDuplicate) {\n            for (let i = 0; i < existingTasks.length; i++) {\n              if (compare(existingTasks[i], delegate)) {\n                // same callback, same capture, same event name, just return\n                return;\n              }\n            }\n          }\n        } else {\n          existingTasks = target[symbolEventName] = [];\n        }\n\n        let source;\n        const constructorName = target.constructor['name'];\n        const targetSource = globalSources[constructorName];\n\n        if (targetSource) {\n          source = targetSource[eventName];\n        }\n\n        if (!source) {\n          source = constructorName + addSource + (eventNameToString ? eventNameToString(eventName) : eventName);\n        } // do not create a new object as task.data to pass those things\n        // just use the global shared one\n\n\n        taskData.options = options;\n\n        if (once) {\n          // if addEventListener with once options, we don't pass it to\n          // native addEventListener, instead we keep the once setting\n          // and handle ourselves.\n          taskData.options.once = false;\n        }\n\n        taskData.target = target;\n        taskData.capture = capture;\n        taskData.eventName = eventName;\n        taskData.isExisting = isExisting;\n        const data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : undefined; // keep taskData into data to allow onScheduleEventTask to access the task information\n\n        if (data) {\n          data.taskData = taskData;\n        }\n\n        const task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn); // should clear taskData.target to avoid memory leak\n        // issue, https://github.com/angular/angular/issues/20442\n\n        taskData.target = null; // need to clear up taskData because it is a global object\n\n        if (data) {\n          data.taskData = null;\n        } // have to save those information to task in case\n        // application may call task.zone.cancelTask() directly\n\n\n        if (once) {\n          options.once = true;\n        }\n\n        if (!(!passiveSupported && typeof task.options === 'boolean')) {\n          // if not support passive, and we pass an option object\n          // to addEventListener, we should save the options to task\n          task.options = options;\n        }\n\n        task.target = target;\n        task.capture = capture;\n        task.eventName = eventName;\n\n        if (isHandleEvent) {\n          // save original delegate for compare to check duplicate\n          task.originalDelegate = delegate;\n        }\n\n        if (!prepend) {\n          existingTasks.push(task);\n        } else {\n          existingTasks.unshift(task);\n        }\n\n        if (returnTarget) {\n          return target;\n        }\n      };\n    };\n\n    proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);\n\n    if (nativePrependEventListener) {\n      proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);\n    }\n\n    proto[REMOVE_EVENT_LISTENER] = function () {\n      const target = this || _global;\n      let eventName = arguments[0];\n\n      if (patchOptions && patchOptions.transferEventName) {\n        eventName = patchOptions.transferEventName(eventName);\n      }\n\n      const options = arguments[2];\n      const capture = !options ? false : typeof options === 'boolean' ? true : options.capture;\n      const delegate = arguments[1];\n\n      if (!delegate) {\n        return nativeRemoveEventListener.apply(this, arguments);\n      }\n\n      if (validateHandler && !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {\n        return;\n      }\n\n      const symbolEventNames = zoneSymbolEventNames[eventName];\n      let symbolEventName;\n\n      if (symbolEventNames) {\n        symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];\n      }\n\n      const existingTasks = symbolEventName && target[symbolEventName];\n\n      if (existingTasks) {\n        for (let i = 0; i < existingTasks.length; i++) {\n          const existingTask = existingTasks[i];\n\n          if (compare(existingTask, delegate)) {\n            existingTasks.splice(i, 1); // set isRemoved to data for faster invokeTask check\n\n            existingTask.isRemoved = true;\n\n            if (existingTasks.length === 0) {\n              // all tasks for the eventName + capture have gone,\n              // remove globalZoneAwareCallback and remove the task cache from target\n              existingTask.allRemoved = true;\n              target[symbolEventName] = null; // in the target, we have an event listener which is added by on_property\n              // such as target.onclick = function() {}, so we need to clear this internal\n              // property too if all delegates all removed\n\n              if (typeof eventName === 'string') {\n                const onPropertySymbol = ZONE_SYMBOL_PREFIX + 'ON_PROPERTY' + eventName;\n                target[onPropertySymbol] = null;\n              }\n            }\n\n            existingTask.zone.cancelTask(existingTask);\n\n            if (returnTarget) {\n              return target;\n            }\n\n            return;\n          }\n        }\n      } // issue 930, didn't find the event name or callback\n      // from zone kept existingTasks, the callback maybe\n      // added outside of zone, we need to call native removeEventListener\n      // to try to remove it.\n\n\n      return nativeRemoveEventListener.apply(this, arguments);\n    };\n\n    proto[LISTENERS_EVENT_LISTENER] = function () {\n      const target = this || _global;\n      let eventName = arguments[0];\n\n      if (patchOptions && patchOptions.transferEventName) {\n        eventName = patchOptions.transferEventName(eventName);\n      }\n\n      const listeners = [];\n      const tasks = findEventTasks(target, eventNameToString ? eventNameToString(eventName) : eventName);\n\n      for (let i = 0; i < tasks.length; i++) {\n        const task = tasks[i];\n        let delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n        listeners.push(delegate);\n      }\n\n      return listeners;\n    };\n\n    proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function () {\n      const target = this || _global;\n      let eventName = arguments[0];\n\n      if (!eventName) {\n        const keys = Object.keys(target);\n\n        for (let i = 0; i < keys.length; i++) {\n          const prop = keys[i];\n          const match = EVENT_NAME_SYMBOL_REGX.exec(prop);\n          let evtName = match && match[1]; // in nodejs EventEmitter, removeListener event is\n          // used for monitoring the removeListener call,\n          // so just keep removeListener eventListener until\n          // all other eventListeners are removed\n\n          if (evtName && evtName !== 'removeListener') {\n            this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, evtName);\n          }\n        } // remove removeListener listener finally\n\n\n        this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, 'removeListener');\n      } else {\n        if (patchOptions && patchOptions.transferEventName) {\n          eventName = patchOptions.transferEventName(eventName);\n        }\n\n        const symbolEventNames = zoneSymbolEventNames[eventName];\n\n        if (symbolEventNames) {\n          const symbolEventName = symbolEventNames[FALSE_STR];\n          const symbolCaptureEventName = symbolEventNames[TRUE_STR];\n          const tasks = target[symbolEventName];\n          const captureTasks = target[symbolCaptureEventName];\n\n          if (tasks) {\n            const removeTasks = tasks.slice();\n\n            for (let i = 0; i < removeTasks.length; i++) {\n              const task = removeTasks[i];\n              let delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n              this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);\n            }\n          }\n\n          if (captureTasks) {\n            const removeTasks = captureTasks.slice();\n\n            for (let i = 0; i < removeTasks.length; i++) {\n              const task = removeTasks[i];\n              let delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n              this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);\n            }\n          }\n        }\n      }\n\n      if (returnTarget) {\n        return this;\n      }\n    }; // for native toString patch\n\n\n    attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);\n    attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);\n\n    if (nativeRemoveAllListeners) {\n      attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);\n    }\n\n    if (nativeListeners) {\n      attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);\n    }\n\n    return true;\n  }\n\n  let results = [];\n\n  for (let i = 0; i < apis.length; i++) {\n    results[i] = patchEventTargetMethods(apis[i], patchOptions);\n  }\n\n  return results;\n}\n\nfunction findEventTasks(target, eventName) {\n  if (!eventName) {\n    const foundTasks = [];\n\n    for (let prop in target) {\n      const match = EVENT_NAME_SYMBOL_REGX.exec(prop);\n      let evtName = match && match[1];\n\n      if (evtName && (!eventName || evtName === eventName)) {\n        const tasks = target[prop];\n\n        if (tasks) {\n          for (let i = 0; i < tasks.length; i++) {\n            foundTasks.push(tasks[i]);\n          }\n        }\n      }\n    }\n\n    return foundTasks;\n  }\n\n  let symbolEventName = zoneSymbolEventNames[eventName];\n\n  if (!symbolEventName) {\n    prepareEventNames(eventName);\n    symbolEventName = zoneSymbolEventNames[eventName];\n  }\n\n  const captureFalseTasks = target[symbolEventName[FALSE_STR]];\n  const captureTrueTasks = target[symbolEventName[TRUE_STR]];\n\n  if (!captureFalseTasks) {\n    return captureTrueTasks ? captureTrueTasks.slice() : [];\n  } else {\n    return captureTrueTasks ? captureFalseTasks.concat(captureTrueTasks) : captureFalseTasks.slice();\n  }\n}\n\nfunction patchEventPrototype(global, api) {\n  const Event = global['Event'];\n\n  if (Event && Event.prototype) {\n    api.patchMethod(Event.prototype, 'stopImmediatePropagation', delegate => function (self, args) {\n      self[IMMEDIATE_PROPAGATION_SYMBOL] = true; // we need to call the native stopImmediatePropagation\n      // in case in some hybrid application, some part of\n      // application will be controlled by zone, some are not\n\n      delegate && delegate.apply(self, args);\n    });\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction patchCallbacks(api, target, targetName, method, callbacks) {\n  const symbol = Zone.__symbol__(method);\n\n  if (target[symbol]) {\n    return;\n  }\n\n  const nativeDelegate = target[symbol] = target[method];\n\n  target[method] = function (name, opts, options) {\n    if (opts && opts.prototype) {\n      callbacks.forEach(function (callback) {\n        const source = `${targetName}.${method}::` + callback;\n        const prototype = opts.prototype;\n\n        if (prototype.hasOwnProperty(callback)) {\n          const descriptor = api.ObjectGetOwnPropertyDescriptor(prototype, callback);\n\n          if (descriptor && descriptor.value) {\n            descriptor.value = api.wrapWithCurrentZone(descriptor.value, source);\n\n            api._redefineProperty(opts.prototype, callback, descriptor);\n          } else if (prototype[callback]) {\n            prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);\n          }\n        } else if (prototype[callback]) {\n          prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);\n        }\n      });\n    }\n\n    return nativeDelegate.call(target, name, opts, options);\n  };\n\n  api.attachOriginToPatched(target[method], nativeDelegate);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction filterProperties(target, onProperties, ignoreProperties) {\n  if (!ignoreProperties || ignoreProperties.length === 0) {\n    return onProperties;\n  }\n\n  const tip = ignoreProperties.filter(ip => ip.target === target);\n\n  if (!tip || tip.length === 0) {\n    return onProperties;\n  }\n\n  const targetIgnoreProperties = tip[0].ignoreProperties;\n  return onProperties.filter(op => targetIgnoreProperties.indexOf(op) === -1);\n}\n\nfunction patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {\n  // check whether target is available, sometimes target will be undefined\n  // because different browser or some 3rd party plugin.\n  if (!target) {\n    return;\n  }\n\n  const filteredProperties = filterProperties(target, onProperties, ignoreProperties);\n  patchOnProperties(target, filteredProperties, prototype);\n}\n/**\n * Get all event name properties which the event name startsWith `on`\n * from the target object itself, inherited properties are not considered.\n */\n\n\nfunction getOnEventNames(target) {\n  return Object.getOwnPropertyNames(target).filter(name => name.startsWith('on') && name.length > 2).map(name => name.substring(2));\n}\n\nfunction propertyDescriptorPatch(api, _global) {\n  if (isNode && !isMix) {\n    return;\n  }\n\n  if (Zone[api.symbol('patchEvents')]) {\n    // events are already been patched by legacy patch.\n    return;\n  }\n\n  const ignoreProperties = _global['__Zone_ignore_on_properties']; // for browsers that we can patch the descriptor:  Chrome & Firefox\n\n  let patchTargets = [];\n\n  if (isBrowser) {\n    const internalWindow = window;\n    patchTargets = patchTargets.concat(['Document', 'SVGElement', 'Element', 'HTMLElement', 'HTMLBodyElement', 'HTMLMediaElement', 'HTMLFrameSetElement', 'HTMLFrameElement', 'HTMLIFrameElement', 'HTMLMarqueeElement', 'Worker']);\n    const ignoreErrorProperties = isIE() ? [{\n      target: internalWindow,\n      ignoreProperties: ['error']\n    }] : []; // in IE/Edge, onProp not exist in window object, but in WindowPrototype\n    // so we need to pass WindowPrototype to check onProp exist or not\n\n    patchFilteredProperties(internalWindow, getOnEventNames(internalWindow), ignoreProperties ? ignoreProperties.concat(ignoreErrorProperties) : ignoreProperties, ObjectGetPrototypeOf(internalWindow));\n  }\n\n  patchTargets = patchTargets.concat(['XMLHttpRequest', 'XMLHttpRequestEventTarget', 'IDBIndex', 'IDBRequest', 'IDBOpenDBRequest', 'IDBDatabase', 'IDBTransaction', 'IDBCursor', 'WebSocket']);\n\n  for (let i = 0; i < patchTargets.length; i++) {\n    const target = _global[patchTargets[i]];\n    target && target.prototype && patchFilteredProperties(target.prototype, getOnEventNames(target.prototype), ignoreProperties);\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nZone.__load_patch('util', (global, Zone, api) => {\n  // Collect native event names by looking at properties\n  // on the global namespace, e.g. 'onclick'.\n  const eventNames = getOnEventNames(global);\n  api.patchOnProperties = patchOnProperties;\n  api.patchMethod = patchMethod;\n  api.bindArguments = bindArguments;\n  api.patchMacroTask = patchMacroTask; // In earlier version of zone.js (<0.9.0), we use env name `__zone_symbol__BLACK_LISTED_EVENTS` to\n  // define which events will not be patched by `Zone.js`.\n  // In newer version (>=0.9.0), we change the env name to `__zone_symbol__UNPATCHED_EVENTS` to keep\n  // the name consistent with angular repo.\n  // The  `__zone_symbol__BLACK_LISTED_EVENTS` is deprecated, but it is still be supported for\n  // backwards compatibility.\n\n  const SYMBOL_BLACK_LISTED_EVENTS = Zone.__symbol__('BLACK_LISTED_EVENTS');\n\n  const SYMBOL_UNPATCHED_EVENTS = Zone.__symbol__('UNPATCHED_EVENTS');\n\n  if (global[SYMBOL_UNPATCHED_EVENTS]) {\n    global[SYMBOL_BLACK_LISTED_EVENTS] = global[SYMBOL_UNPATCHED_EVENTS];\n  }\n\n  if (global[SYMBOL_BLACK_LISTED_EVENTS]) {\n    Zone[SYMBOL_BLACK_LISTED_EVENTS] = Zone[SYMBOL_UNPATCHED_EVENTS] = global[SYMBOL_BLACK_LISTED_EVENTS];\n  }\n\n  api.patchEventPrototype = patchEventPrototype;\n  api.patchEventTarget = patchEventTarget;\n  api.isIEOrEdge = isIEOrEdge;\n  api.ObjectDefineProperty = ObjectDefineProperty;\n  api.ObjectGetOwnPropertyDescriptor = ObjectGetOwnPropertyDescriptor;\n  api.ObjectCreate = ObjectCreate;\n  api.ArraySlice = ArraySlice;\n  api.patchClass = patchClass;\n  api.wrapWithCurrentZone = wrapWithCurrentZone;\n  api.filterProperties = filterProperties;\n  api.attachOriginToPatched = attachOriginToPatched;\n  api._redefineProperty = Object.defineProperty;\n  api.patchCallbacks = patchCallbacks;\n\n  api.getGlobalObjects = () => ({\n    globalSources,\n    zoneSymbolEventNames,\n    eventNames,\n    isBrowser,\n    isMix,\n    isNode,\n    TRUE_STR,\n    FALSE_STR,\n    ZONE_SYMBOL_PREFIX,\n    ADD_EVENT_LISTENER_STR,\n    REMOVE_EVENT_LISTENER_STR\n  });\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst taskSymbol = zoneSymbol('zoneTask');\n\nfunction patchTimer(window, setName, cancelName, nameSuffix) {\n  let setNative = null;\n  let clearNative = null;\n  setName += nameSuffix;\n  cancelName += nameSuffix;\n  const tasksByHandleId = {};\n\n  function scheduleTask(task) {\n    const data = task.data;\n\n    data.args[0] = function () {\n      return task.invoke.apply(this, arguments);\n    };\n\n    data.handleId = setNative.apply(window, data.args);\n    return task;\n  }\n\n  function clearTask(task) {\n    return clearNative.call(window, task.data.handleId);\n  }\n\n  setNative = patchMethod(window, setName, delegate => function (self, args) {\n    if (typeof args[0] === 'function') {\n      const options = {\n        isPeriodic: nameSuffix === 'Interval',\n        delay: nameSuffix === 'Timeout' || nameSuffix === 'Interval' ? args[1] || 0 : undefined,\n        args: args\n      };\n      const callback = args[0];\n\n      args[0] = function timer() {\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          // issue-934, task will be cancelled\n          // even it is a periodic task such as\n          // setInterval\n          // https://github.com/angular/angular/issues/40387\n          // Cleanup tasksByHandleId should be handled before scheduleTask\n          // Since some zoneSpec may intercept and doesn't trigger\n          // scheduleFn(scheduleTask) provided here.\n          if (!options.isPeriodic) {\n            if (typeof options.handleId === 'number') {\n              // in non-nodejs env, we remove timerId\n              // from local cache\n              delete tasksByHandleId[options.handleId];\n            } else if (options.handleId) {\n              // Node returns complex objects as handleIds\n              // we remove task reference from timer object\n              options.handleId[taskSymbol] = null;\n            }\n          }\n        }\n      };\n\n      const task = scheduleMacroTaskWithCurrentZone(setName, args[0], options, scheduleTask, clearTask);\n\n      if (!task) {\n        return task;\n      } // Node.js must additionally support the ref and unref functions.\n\n\n      const handle = task.data.handleId;\n\n      if (typeof handle === 'number') {\n        // for non nodejs env, we save handleId: task\n        // mapping in local cache for clearTimeout\n        tasksByHandleId[handle] = task;\n      } else if (handle) {\n        // for nodejs env, we save task\n        // reference in timerId Object for clearTimeout\n        handle[taskSymbol] = task;\n      } // check whether handle is null, because some polyfill or browser\n      // may return undefined from setTimeout/setInterval/setImmediate/requestAnimationFrame\n\n\n      if (handle && handle.ref && handle.unref && typeof handle.ref === 'function' && typeof handle.unref === 'function') {\n        task.ref = handle.ref.bind(handle);\n        task.unref = handle.unref.bind(handle);\n      }\n\n      if (typeof handle === 'number' || handle) {\n        return handle;\n      }\n\n      return task;\n    } else {\n      // cause an error by calling it directly.\n      return delegate.apply(window, args);\n    }\n  });\n  clearNative = patchMethod(window, cancelName, delegate => function (self, args) {\n    const id = args[0];\n    let task;\n\n    if (typeof id === 'number') {\n      // non nodejs env.\n      task = tasksByHandleId[id];\n    } else {\n      // nodejs env.\n      task = id && id[taskSymbol]; // other environments.\n\n      if (!task) {\n        task = id;\n      }\n    }\n\n    if (task && typeof task.type === 'string') {\n      if (task.state !== 'notScheduled' && (task.cancelFn && task.data.isPeriodic || task.runCount === 0)) {\n        if (typeof id === 'number') {\n          delete tasksByHandleId[id];\n        } else if (id) {\n          id[taskSymbol] = null;\n        } // Do not cancel already canceled functions\n\n\n        task.zone.cancelTask(task);\n      }\n    } else {\n      // cause an error by calling it directly.\n      delegate.apply(window, args);\n    }\n  });\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction patchCustomElements(_global, api) {\n  const {\n    isBrowser,\n    isMix\n  } = api.getGlobalObjects();\n\n  if (!isBrowser && !isMix || !_global['customElements'] || !('customElements' in _global)) {\n    return;\n  }\n\n  const callbacks = ['connectedCallback', 'disconnectedCallback', 'adoptedCallback', 'attributeChangedCallback'];\n  api.patchCallbacks(api, _global.customElements, 'customElements', 'define', callbacks);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction eventTargetPatch(_global, api) {\n  if (Zone[api.symbol('patchEventTarget')]) {\n    // EventTarget is already patched.\n    return;\n  }\n\n  const {\n    eventNames,\n    zoneSymbolEventNames,\n    TRUE_STR,\n    FALSE_STR,\n    ZONE_SYMBOL_PREFIX\n  } = api.getGlobalObjects(); //  predefine all __zone_symbol__ + eventName + true/false string\n\n  for (let i = 0; i < eventNames.length; i++) {\n    const eventName = eventNames[i];\n    const falseEventName = eventName + FALSE_STR;\n    const trueEventName = eventName + TRUE_STR;\n    const symbol = ZONE_SYMBOL_PREFIX + falseEventName;\n    const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;\n    zoneSymbolEventNames[eventName] = {};\n    zoneSymbolEventNames[eventName][FALSE_STR] = symbol;\n    zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;\n  }\n\n  const EVENT_TARGET = _global['EventTarget'];\n\n  if (!EVENT_TARGET || !EVENT_TARGET.prototype) {\n    return;\n  }\n\n  api.patchEventTarget(_global, api, [EVENT_TARGET && EVENT_TARGET.prototype]);\n  return true;\n}\n\nfunction patchEvent(global, api) {\n  api.patchEventPrototype(global, api);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nZone.__load_patch('legacy', global => {\n  const legacyPatch = global[Zone.__symbol__('legacyPatch')];\n\n  if (legacyPatch) {\n    legacyPatch();\n  }\n});\n\nZone.__load_patch('queueMicrotask', (global, Zone, api) => {\n  api.patchMethod(global, 'queueMicrotask', delegate => {\n    return function (self, args) {\n      Zone.current.scheduleMicroTask('queueMicrotask', args[0]);\n    };\n  });\n});\n\nZone.__load_patch('timers', global => {\n  const set = 'set';\n  const clear = 'clear';\n  patchTimer(global, set, clear, 'Timeout');\n  patchTimer(global, set, clear, 'Interval');\n  patchTimer(global, set, clear, 'Immediate');\n});\n\nZone.__load_patch('requestAnimationFrame', global => {\n  patchTimer(global, 'request', 'cancel', 'AnimationFrame');\n  patchTimer(global, 'mozRequest', 'mozCancel', 'AnimationFrame');\n  patchTimer(global, 'webkitRequest', 'webkitCancel', 'AnimationFrame');\n});\n\nZone.__load_patch('blocking', (global, Zone) => {\n  const blockingMethods = ['alert', 'prompt', 'confirm'];\n\n  for (let i = 0; i < blockingMethods.length; i++) {\n    const name = blockingMethods[i];\n    patchMethod(global, name, (delegate, symbol, name) => {\n      return function (s, args) {\n        return Zone.current.run(delegate, global, args, name);\n      };\n    });\n  }\n});\n\nZone.__load_patch('EventTarget', (global, Zone, api) => {\n  patchEvent(global, api);\n  eventTargetPatch(global, api); // patch XMLHttpRequestEventTarget's addEventListener/removeEventListener\n\n  const XMLHttpRequestEventTarget = global['XMLHttpRequestEventTarget'];\n\n  if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {\n    api.patchEventTarget(global, api, [XMLHttpRequestEventTarget.prototype]);\n  }\n});\n\nZone.__load_patch('MutationObserver', (global, Zone, api) => {\n  patchClass('MutationObserver');\n  patchClass('WebKitMutationObserver');\n});\n\nZone.__load_patch('IntersectionObserver', (global, Zone, api) => {\n  patchClass('IntersectionObserver');\n});\n\nZone.__load_patch('FileReader', (global, Zone, api) => {\n  patchClass('FileReader');\n});\n\nZone.__load_patch('on_property', (global, Zone, api) => {\n  propertyDescriptorPatch(api, global);\n});\n\nZone.__load_patch('customElements', (global, Zone, api) => {\n  patchCustomElements(global, api);\n});\n\nZone.__load_patch('XHR', (global, Zone) => {\n  // Treat XMLHttpRequest as a macrotask.\n  patchXHR(global);\n  const XHR_TASK = zoneSymbol('xhrTask');\n  const XHR_SYNC = zoneSymbol('xhrSync');\n  const XHR_LISTENER = zoneSymbol('xhrListener');\n  const XHR_SCHEDULED = zoneSymbol('xhrScheduled');\n  const XHR_URL = zoneSymbol('xhrURL');\n  const XHR_ERROR_BEFORE_SCHEDULED = zoneSymbol('xhrErrorBeforeScheduled');\n\n  function patchXHR(window) {\n    const XMLHttpRequest = window['XMLHttpRequest'];\n\n    if (!XMLHttpRequest) {\n      // XMLHttpRequest is not available in service worker\n      return;\n    }\n\n    const XMLHttpRequestPrototype = XMLHttpRequest.prototype;\n\n    function findPendingTask(target) {\n      return target[XHR_TASK];\n    }\n\n    let oriAddListener = XMLHttpRequestPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];\n    let oriRemoveListener = XMLHttpRequestPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\n\n    if (!oriAddListener) {\n      const XMLHttpRequestEventTarget = window['XMLHttpRequestEventTarget'];\n\n      if (XMLHttpRequestEventTarget) {\n        const XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget.prototype;\n        oriAddListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];\n        oriRemoveListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\n      }\n    }\n\n    const READY_STATE_CHANGE = 'readystatechange';\n    const SCHEDULED = 'scheduled';\n\n    function scheduleTask(task) {\n      const data = task.data;\n      const target = data.target;\n      target[XHR_SCHEDULED] = false;\n      target[XHR_ERROR_BEFORE_SCHEDULED] = false; // remove existing event listener\n\n      const listener = target[XHR_LISTENER];\n\n      if (!oriAddListener) {\n        oriAddListener = target[ZONE_SYMBOL_ADD_EVENT_LISTENER];\n        oriRemoveListener = target[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\n      }\n\n      if (listener) {\n        oriRemoveListener.call(target, READY_STATE_CHANGE, listener);\n      }\n\n      const newListener = target[XHR_LISTENER] = () => {\n        if (target.readyState === target.DONE) {\n          // sometimes on some browsers XMLHttpRequest will fire onreadystatechange with\n          // readyState=4 multiple times, so we need to check task state here\n          if (!data.aborted && target[XHR_SCHEDULED] && task.state === SCHEDULED) {\n            // check whether the xhr has registered onload listener\n            // if that is the case, the task should invoke after all\n            // onload listeners finish.\n            // Also if the request failed without response (status = 0), the load event handler\n            // will not be triggered, in that case, we should also invoke the placeholder callback\n            // to close the XMLHttpRequest::send macroTask.\n            // https://github.com/angular/angular/issues/38795\n            const loadTasks = target[Zone.__symbol__('loadfalse')];\n\n            if (target.status !== 0 && loadTasks && loadTasks.length > 0) {\n              const oriInvoke = task.invoke;\n\n              task.invoke = function () {\n                // need to load the tasks again, because in other\n                // load listener, they may remove themselves\n                const loadTasks = target[Zone.__symbol__('loadfalse')];\n\n                for (let i = 0; i < loadTasks.length; i++) {\n                  if (loadTasks[i] === task) {\n                    loadTasks.splice(i, 1);\n                  }\n                }\n\n                if (!data.aborted && task.state === SCHEDULED) {\n                  oriInvoke.call(task);\n                }\n              };\n\n              loadTasks.push(task);\n            } else {\n              task.invoke();\n            }\n          } else if (!data.aborted && target[XHR_SCHEDULED] === false) {\n            // error occurs when xhr.send()\n            target[XHR_ERROR_BEFORE_SCHEDULED] = true;\n          }\n        }\n      };\n\n      oriAddListener.call(target, READY_STATE_CHANGE, newListener);\n      const storedTask = target[XHR_TASK];\n\n      if (!storedTask) {\n        target[XHR_TASK] = task;\n      }\n\n      sendNative.apply(target, data.args);\n      target[XHR_SCHEDULED] = true;\n      return task;\n    }\n\n    function placeholderCallback() {}\n\n    function clearTask(task) {\n      const data = task.data; // Note - ideally, we would call data.target.removeEventListener here, but it's too late\n      // to prevent it from firing. So instead, we store info for the event listener.\n\n      data.aborted = true;\n      return abortNative.apply(data.target, data.args);\n    }\n\n    const openNative = patchMethod(XMLHttpRequestPrototype, 'open', () => function (self, args) {\n      self[XHR_SYNC] = args[2] == false;\n      self[XHR_URL] = args[1];\n      return openNative.apply(self, args);\n    });\n    const XMLHTTPREQUEST_SOURCE = 'XMLHttpRequest.send';\n    const fetchTaskAborting = zoneSymbol('fetchTaskAborting');\n    const fetchTaskScheduling = zoneSymbol('fetchTaskScheduling');\n    const sendNative = patchMethod(XMLHttpRequestPrototype, 'send', () => function (self, args) {\n      if (Zone.current[fetchTaskScheduling] === true) {\n        // a fetch is scheduling, so we are using xhr to polyfill fetch\n        // and because we already schedule macroTask for fetch, we should\n        // not schedule a macroTask for xhr again\n        return sendNative.apply(self, args);\n      }\n\n      if (self[XHR_SYNC]) {\n        // if the XHR is sync there is no task to schedule, just execute the code.\n        return sendNative.apply(self, args);\n      } else {\n        const options = {\n          target: self,\n          url: self[XHR_URL],\n          isPeriodic: false,\n          args: args,\n          aborted: false\n        };\n        const task = scheduleMacroTaskWithCurrentZone(XMLHTTPREQUEST_SOURCE, placeholderCallback, options, scheduleTask, clearTask);\n\n        if (self && self[XHR_ERROR_BEFORE_SCHEDULED] === true && !options.aborted && task.state === SCHEDULED) {\n          // xhr request throw error when send\n          // we should invoke task instead of leaving a scheduled\n          // pending macroTask\n          task.invoke();\n        }\n      }\n    });\n    const abortNative = patchMethod(XMLHttpRequestPrototype, 'abort', () => function (self, args) {\n      const task = findPendingTask(self);\n\n      if (task && typeof task.type == 'string') {\n        // If the XHR has already completed, do nothing.\n        // If the XHR has already been aborted, do nothing.\n        // Fix #569, call abort multiple times before done will cause\n        // macroTask task count be negative number\n        if (task.cancelFn == null || task.data && task.data.aborted) {\n          return;\n        }\n\n        task.zone.cancelTask(task);\n      } else if (Zone.current[fetchTaskAborting] === true) {\n        // the abort is called from fetch polyfill, we need to call native abort of XHR.\n        return abortNative.apply(self, args);\n      } // Otherwise, we are trying to abort an XHR which has not yet been sent, so there is no\n      // task\n      // to cancel. Do nothing.\n\n    });\n  }\n});\n\nZone.__load_patch('geolocation', global => {\n  /// GEO_LOCATION\n  if (global['navigator'] && global['navigator'].geolocation) {\n    patchPrototype(global['navigator'].geolocation, ['getCurrentPosition', 'watchPosition']);\n  }\n});\n\nZone.__load_patch('PromiseRejectionEvent', (global, Zone) => {\n  // handle unhandled promise rejection\n  function findPromiseRejectionHandler(evtName) {\n    return function (e) {\n      const eventTasks = findEventTasks(global, evtName);\n      eventTasks.forEach(eventTask => {\n        // windows has added unhandledrejection event listener\n        // trigger the event listener\n        const PromiseRejectionEvent = global['PromiseRejectionEvent'];\n\n        if (PromiseRejectionEvent) {\n          const evt = new PromiseRejectionEvent(evtName, {\n            promise: e.promise,\n            reason: e.rejection\n          });\n          eventTask.invoke(evt);\n        }\n      });\n    };\n  }\n\n  if (global['PromiseRejectionEvent']) {\n    Zone[zoneSymbol('unhandledPromiseRejectionHandler')] = findPromiseRejectionHandler('unhandledrejection');\n    Zone[zoneSymbol('rejectionHandledHandler')] = findPromiseRejectionHandler('rejectionhandled');\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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bTIwMTUvem9uZS5qcz85YmVhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2MTQuMC4wLW5leHQuNVxuICogKGMpIDIwMTAtMjAyMiBHb29nbGUgTExDLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4oKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICBjb25zdCBwZXJmb3JtYW5jZSA9IGdsb2JhbFsncGVyZm9ybWFuY2UnXTtcbiAgICBmdW5jdGlvbiBtYXJrKG5hbWUpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UgJiYgcGVyZm9ybWFuY2VbJ21hcmsnXSAmJiBwZXJmb3JtYW5jZVsnbWFyayddKG5hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZXJmb3JtYW5jZU1lYXN1cmUobmFtZSwgbGFiZWwpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UgJiYgcGVyZm9ybWFuY2VbJ21lYXN1cmUnXSAmJiBwZXJmb3JtYW5jZVsnbWVhc3VyZSddKG5hbWUsIGxhYmVsKTtcbiAgICB9XG4gICAgbWFyaygnWm9uZScpO1xuICAgIC8vIEluaXRpYWxpemUgYmVmb3JlIGl0J3MgYWNjZXNzZWQgYmVsb3cuXG4gICAgLy8gX19ab25lX3N5bWJvbF9wcmVmaXggZ2xvYmFsIGNhbiBiZSB1c2VkIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHpvbmVcbiAgICAvLyBzeW1ib2wgcHJlZml4IHdpdGggYSBjdXN0b20gb25lIGlmIG5lZWRlZC5cbiAgICBjb25zdCBzeW1ib2xQcmVmaXggPSBnbG9iYWxbJ19fWm9uZV9zeW1ib2xfcHJlZml4J10gfHwgJ19fem9uZV9zeW1ib2xfXyc7XG4gICAgZnVuY3Rpb24gX19zeW1ib2xfXyhuYW1lKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xQcmVmaXggKyBuYW1lO1xuICAgIH1cbiAgICBjb25zdCBjaGVja0R1cGxpY2F0ZSA9IGdsb2JhbFtfX3N5bWJvbF9fKCdmb3JjZUR1cGxpY2F0ZVpvbmVDaGVjaycpXSA9PT0gdHJ1ZTtcbiAgICBpZiAoZ2xvYmFsWydab25lJ10pIHtcbiAgICAgICAgLy8gaWYgZ2xvYmFsWydab25lJ10gYWxyZWFkeSBleGlzdHMgKG1heWJlIHpvbmUuanMgd2FzIGFscmVhZHkgbG9hZGVkIG9yXG4gICAgICAgIC8vIHNvbWUgb3RoZXIgbGliIGFsc28gcmVnaXN0ZXJlZCBhIGdsb2JhbCBvYmplY3QgbmFtZWQgWm9uZSksIHdlIG1heSBuZWVkXG4gICAgICAgIC8vIHRvIHRocm93IGFuIGVycm9yLCBidXQgc29tZXRpbWVzIHVzZXIgbWF5IG5vdCB3YW50IHRoaXMgZXJyb3IuXG4gICAgICAgIC8vIEZvciBleGFtcGxlLFxuICAgICAgICAvLyB3ZSBoYXZlIHR3byB3ZWIgcGFnZXMsIHBhZ2UxIGluY2x1ZGVzIHpvbmUuanMsIHBhZ2UyIGRvZXNuJ3QuXG4gICAgICAgIC8vIGFuZCB0aGUgMXN0IHRpbWUgdXNlciBsb2FkIHBhZ2UxIGFuZCBwYWdlMiwgZXZlcnl0aGluZyB3b3JrIGZpbmUsXG4gICAgICAgIC8vIGJ1dCB3aGVuIHVzZXIgbG9hZCBwYWdlMiBhZ2FpbiwgZXJyb3Igb2NjdXJzIGJlY2F1c2UgZ2xvYmFsWydab25lJ10gYWxyZWFkeSBleGlzdHMuXG4gICAgICAgIC8vIHNvIHdlIGFkZCBhIGZsYWcgdG8gbGV0IHVzZXIgY2hvb3NlIHdoZXRoZXIgdG8gdGhyb3cgdGhpcyBlcnJvciBvciBub3QuXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIGlmIGV4aXN0aW5nIFpvbmUgaXMgZnJvbSB6b25lLmpzLCB3ZSB3aWxsIG5vdCB0aHJvdyB0aGUgZXJyb3IuXG4gICAgICAgIGlmIChjaGVja0R1cGxpY2F0ZSB8fCB0eXBlb2YgZ2xvYmFsWydab25lJ10uX19zeW1ib2xfXyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdab25lIGFscmVhZHkgbG9hZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFsnWm9uZSddO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsYXNzIFpvbmUge1xuICAgICAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHpvbmVTcGVjKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLl9uYW1lID0gem9uZVNwZWMgPyB6b25lU3BlYy5uYW1lIHx8ICd1bm5hbWVkJyA6ICc8cm9vdD4nO1xuICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllcyA9IHpvbmVTcGVjICYmIHpvbmVTcGVjLnByb3BlcnRpZXMgfHwge307XG4gICAgICAgICAgICB0aGlzLl96b25lRGVsZWdhdGUgPVxuICAgICAgICAgICAgICAgIG5ldyBfWm9uZURlbGVnYXRlKHRoaXMsIHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wYXJlbnQuX3pvbmVEZWxlZ2F0ZSwgem9uZVNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBhc3NlcnRab25lUGF0Y2hlZCgpIHtcbiAgICAgICAgICAgIGlmIChnbG9iYWxbJ1Byb21pc2UnXSAhPT0gcGF0Y2hlc1snWm9uZUF3YXJlUHJvbWlzZSddKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdab25lLmpzIGhhcyBkZXRlY3RlZCB0aGF0IFpvbmVBd2FyZVByb21pc2UgYCh3aW5kb3d8Z2xvYmFsKS5Qcm9taXNlYCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2hhcyBiZWVuIG92ZXJ3cml0dGVuLlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAnTW9zdCBsaWtlbHkgY2F1c2UgaXMgdGhhdCBhIFByb21pc2UgcG9seWZpbGwgaGFzIGJlZW4gbG9hZGVkICcgK1xuICAgICAgICAgICAgICAgICAgICAnYWZ0ZXIgWm9uZS5qcyAoUG9seWZpbGxpbmcgUHJvbWlzZSBhcGkgaXMgbm90IG5lY2Vzc2FyeSB3aGVuIHpvbmUuanMgaXMgbG9hZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ0lmIHlvdSBtdXN0IGxvYWQgb25lLCBkbyBzbyBiZWZvcmUgbG9hZGluZyB6b25lLmpzLiknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0IHJvb3QoKSB7XG4gICAgICAgICAgICBsZXQgem9uZSA9IFpvbmUuY3VycmVudDtcbiAgICAgICAgICAgIHdoaWxlICh6b25lLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHpvbmUgPSB6b25lLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB6b25lO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXQgY3VycmVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfY3VycmVudFpvbmVGcmFtZS56b25lO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXQgY3VycmVudFRhc2soKSB7XG4gICAgICAgICAgICByZXR1cm4gX2N1cnJlbnRUYXNrO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpyZXF1aXJlLWludGVybmFsLXdpdGgtdW5kZXJzY29yZVxuICAgICAgICBzdGF0aWMgX19sb2FkX3BhdGNoKG5hbWUsIGZuLCBpZ25vcmVEdXBsaWNhdGUgPSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKHBhdGNoZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBgY2hlY2tEdXBsaWNhdGVgIG9wdGlvbiBpcyBkZWZpbmVkIGZyb20gZ2xvYmFsIHZhcmlhYmxlXG4gICAgICAgICAgICAgICAgLy8gc28gaXQgd29ya3MgZm9yIGFsbCBtb2R1bGVzLlxuICAgICAgICAgICAgICAgIC8vIGBpZ25vcmVEdXBsaWNhdGVgIGNhbiB3b3JrIGZvciB0aGUgc3BlY2lmaWVkIG1vZHVsZVxuICAgICAgICAgICAgICAgIGlmICghaWdub3JlRHVwbGljYXRlICYmIGNoZWNrRHVwbGljYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdBbHJlYWR5IGxvYWRlZCBwYXRjaDogJyArIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFnbG9iYWxbJ19fWm9uZV9kaXNhYmxlXycgKyBuYW1lXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlcmZOYW1lID0gJ1pvbmU6JyArIG5hbWU7XG4gICAgICAgICAgICAgICAgbWFyayhwZXJmTmFtZSk7XG4gICAgICAgICAgICAgICAgcGF0Y2hlc1tuYW1lXSA9IGZuKGdsb2JhbCwgWm9uZSwgX2FwaSk7XG4gICAgICAgICAgICAgICAgcGVyZm9ybWFuY2VNZWFzdXJlKHBlcmZOYW1lLCBwZXJmTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBnZXQoa2V5KSB7XG4gICAgICAgICAgICBjb25zdCB6b25lID0gdGhpcy5nZXRab25lV2l0aChrZXkpO1xuICAgICAgICAgICAgaWYgKHpvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHpvbmUuX3Byb3BlcnRpZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBnZXRab25lV2l0aChrZXkpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuX3Byb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuX3BhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvcmsoem9uZVNwZWMpIHtcbiAgICAgICAgICAgIGlmICghem9uZVNwZWMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdab25lU3BlYyByZXF1aXJlZCEnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lRGVsZWdhdGUuZm9yayh0aGlzLCB6b25lU3BlYyk7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcChjYWxsYmFjaywgc291cmNlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RpbmcgZnVuY3Rpb24gZ290OiAnICsgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgX2NhbGxiYWNrID0gdGhpcy5fem9uZURlbGVnYXRlLmludGVyY2VwdCh0aGlzLCBjYWxsYmFjaywgc291cmNlKTtcbiAgICAgICAgICAgIGNvbnN0IHpvbmUgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gem9uZS5ydW5HdWFyZGVkKF9jYWxsYmFjaywgdGhpcywgYXJndW1lbnRzLCBzb3VyY2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBydW4oY2FsbGJhY2ssIGFwcGx5VGhpcywgYXBwbHlBcmdzLCBzb3VyY2UpIHtcbiAgICAgICAgICAgIF9jdXJyZW50Wm9uZUZyYW1lID0geyBwYXJlbnQ6IF9jdXJyZW50Wm9uZUZyYW1lLCB6b25lOiB0aGlzIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lRGVsZWdhdGUuaW52b2tlKHRoaXMsIGNhbGxiYWNrLCBhcHBseVRoaXMsIGFwcGx5QXJncywgc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIF9jdXJyZW50Wm9uZUZyYW1lID0gX2N1cnJlbnRab25lRnJhbWUucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJ1bkd1YXJkZWQoY2FsbGJhY2ssIGFwcGx5VGhpcyA9IG51bGwsIGFwcGx5QXJncywgc291cmNlKSB7XG4gICAgICAgICAgICBfY3VycmVudFpvbmVGcmFtZSA9IHsgcGFyZW50OiBfY3VycmVudFpvbmVGcmFtZSwgem9uZTogdGhpcyB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fem9uZURlbGVnYXRlLmludm9rZSh0aGlzLCBjYWxsYmFjaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MsIHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fem9uZURlbGVnYXRlLmhhbmRsZUVycm9yKHRoaXMsIGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBfY3VycmVudFpvbmVGcmFtZSA9IF9jdXJyZW50Wm9uZUZyYW1lLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBydW5UYXNrKHRhc2ssIGFwcGx5VGhpcywgYXBwbHlBcmdzKSB7XG4gICAgICAgICAgICBpZiAodGFzay56b25lICE9IHRoaXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgdGFzayBjYW4gb25seSBiZSBydW4gaW4gdGhlIHpvbmUgb2YgY3JlYXRpb24hIChDcmVhdGlvbjogJyArXG4gICAgICAgICAgICAgICAgICAgICh0YXNrLnpvbmUgfHwgTk9fWk9ORSkubmFtZSArICc7IEV4ZWN1dGlvbjogJyArIHRoaXMubmFtZSArICcpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci96b25lLmpzL2lzc3Vlcy83NzgsIHNvbWV0aW1lcyBldmVudFRhc2tcbiAgICAgICAgICAgIC8vIHdpbGwgcnVuIGluIG5vdFNjaGVkdWxlZChjYW5jZWxlZCkgc3RhdGUsIHdlIHNob3VsZCBub3QgdHJ5IHRvXG4gICAgICAgICAgICAvLyBydW4gc3VjaCBraW5kIG9mIHRhc2sgYnV0IGp1c3QgcmV0dXJuXG4gICAgICAgICAgICBpZiAodGFzay5zdGF0ZSA9PT0gbm90U2NoZWR1bGVkICYmICh0YXNrLnR5cGUgPT09IGV2ZW50VGFzayB8fCB0YXNrLnR5cGUgPT09IG1hY3JvVGFzaykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZUVudHJ5R3VhcmQgPSB0YXNrLnN0YXRlICE9IHJ1bm5pbmc7XG4gICAgICAgICAgICByZUVudHJ5R3VhcmQgJiYgdGFzay5fdHJhbnNpdGlvblRvKHJ1bm5pbmcsIHNjaGVkdWxlZCk7XG4gICAgICAgICAgICB0YXNrLnJ1bkNvdW50Kys7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1Rhc2sgPSBfY3VycmVudFRhc2s7XG4gICAgICAgICAgICBfY3VycmVudFRhc2sgPSB0YXNrO1xuICAgICAgICAgICAgX2N1cnJlbnRab25lRnJhbWUgPSB7IHBhcmVudDogX2N1cnJlbnRab25lRnJhbWUsIHpvbmU6IHRoaXMgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhc2sudHlwZSA9PSBtYWNyb1Rhc2sgJiYgdGFzay5kYXRhICYmICF0YXNrLmRhdGEuaXNQZXJpb2RpYykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLmNhbmNlbEZuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fem9uZURlbGVnYXRlLmludm9rZVRhc2sodGhpcywgdGFzaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3pvbmVEZWxlZ2F0ZS5oYW5kbGVFcnJvcih0aGlzLCBlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHRhc2sncyBzdGF0ZSBpcyBub3RTY2hlZHVsZWQgb3IgdW5rbm93biwgdGhlbiBpdCBoYXMgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgICAgICAgICAgICAgIC8vIHdlIHNob3VsZCBub3QgcmVzZXQgdGhlIHN0YXRlIHRvIHNjaGVkdWxlZFxuICAgICAgICAgICAgICAgIGlmICh0YXNrLnN0YXRlICE9PSBub3RTY2hlZHVsZWQgJiYgdGFzay5zdGF0ZSAhPT0gdW5rbm93bikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFzay50eXBlID09IGV2ZW50VGFzayB8fCAodGFzay5kYXRhICYmIHRhc2suZGF0YS5pc1BlcmlvZGljKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVFbnRyeUd1YXJkICYmIHRhc2suX3RyYW5zaXRpb25UbyhzY2hlZHVsZWQsIHJ1bm5pbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5ydW5Db3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVUYXNrQ291bnQodGFzaywgLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVFbnRyeUd1YXJkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5fdHJhbnNpdGlvblRvKG5vdFNjaGVkdWxlZCwgcnVubmluZywgbm90U2NoZWR1bGVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfY3VycmVudFpvbmVGcmFtZSA9IF9jdXJyZW50Wm9uZUZyYW1lLnBhcmVudDtcbiAgICAgICAgICAgICAgICBfY3VycmVudFRhc2sgPSBwcmV2aW91c1Rhc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2NoZWR1bGVUYXNrKHRhc2spIHtcbiAgICAgICAgICAgIGlmICh0YXNrLnpvbmUgJiYgdGFzay56b25lICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHRhc2sgd2FzIHJlc2NoZWR1bGVkLCB0aGUgbmV3Wm9uZVxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBub3QgYmUgdGhlIGNoaWxkcmVuIG9mIHRoZSBvcmlnaW5hbCB6b25lXG4gICAgICAgICAgICAgICAgbGV0IG5ld1pvbmUgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXdab25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdab25lID09PSB0YXNrLnpvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBjYW4gbm90IHJlc2NoZWR1bGUgdGFzayB0byAke3RoaXMubmFtZX0gd2hpY2ggaXMgZGVzY2VuZGFudHMgb2YgdGhlIG9yaWdpbmFsIHpvbmUgJHt0YXNrLnpvbmUubmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXdab25lID0gbmV3Wm9uZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFzay5fdHJhbnNpdGlvblRvKHNjaGVkdWxpbmcsIG5vdFNjaGVkdWxlZCk7XG4gICAgICAgICAgICBjb25zdCB6b25lRGVsZWdhdGVzID0gW107XG4gICAgICAgICAgICB0YXNrLl96b25lRGVsZWdhdGVzID0gem9uZURlbGVnYXRlcztcbiAgICAgICAgICAgIHRhc2suX3pvbmUgPSB0aGlzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0YXNrID0gdGhpcy5fem9uZURlbGVnYXRlLnNjaGVkdWxlVGFzayh0aGlzLCB0YXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgc2V0IHRhc2sncyBzdGF0ZSB0byB1bmtub3duIHdoZW4gc2NoZWR1bGVUYXNrIHRocm93IGVycm9yXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgZXJyIG1heSBmcm9tIHJlc2NoZWR1bGUsIHNvIHRoZSBmcm9tU3RhdGUgbWF5YmUgbm90U2NoZWR1bGVkXG4gICAgICAgICAgICAgICAgdGFzay5fdHJhbnNpdGlvblRvKHVua25vd24sIHNjaGVkdWxpbmcsIG5vdFNjaGVkdWxlZCk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQEppYUxpUGFzc2lvbiwgc2hvdWxkIHdlIGNoZWNrIHRoZSByZXN1bHQgZnJvbSBoYW5kbGVFcnJvcj9cbiAgICAgICAgICAgICAgICB0aGlzLl96b25lRGVsZWdhdGUuaGFuZGxlRXJyb3IodGhpcywgZXJyKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFzay5fem9uZURlbGVnYXRlcyA9PT0gem9uZURlbGVnYXRlcykge1xuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gY2hlY2sgYmVjYXVzZSBpbnRlcm5hbGx5IHRoZSBkZWxlZ2F0ZSBjYW4gcmVzY2hlZHVsZSB0aGUgdGFzay5cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVUYXNrQ291bnQodGFzaywgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFzay5zdGF0ZSA9PSBzY2hlZHVsaW5nKSB7XG4gICAgICAgICAgICAgICAgdGFzay5fdHJhbnNpdGlvblRvKHNjaGVkdWxlZCwgc2NoZWR1bGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFzaztcbiAgICAgICAgfVxuICAgICAgICBzY2hlZHVsZU1pY3JvVGFzayhzb3VyY2UsIGNhbGxiYWNrLCBkYXRhLCBjdXN0b21TY2hlZHVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVUYXNrKG5ldyBab25lVGFzayhtaWNyb1Rhc2ssIHNvdXJjZSwgY2FsbGJhY2ssIGRhdGEsIGN1c3RvbVNjaGVkdWxlLCB1bmRlZmluZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBzY2hlZHVsZU1hY3JvVGFzayhzb3VyY2UsIGNhbGxiYWNrLCBkYXRhLCBjdXN0b21TY2hlZHVsZSwgY3VzdG9tQ2FuY2VsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZVRhc2sobmV3IFpvbmVUYXNrKG1hY3JvVGFzaywgc291cmNlLCBjYWxsYmFjaywgZGF0YSwgY3VzdG9tU2NoZWR1bGUsIGN1c3RvbUNhbmNlbCkpO1xuICAgICAgICB9XG4gICAgICAgIHNjaGVkdWxlRXZlbnRUYXNrKHNvdXJjZSwgY2FsbGJhY2ssIGRhdGEsIGN1c3RvbVNjaGVkdWxlLCBjdXN0b21DYW5jZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlVGFzayhuZXcgWm9uZVRhc2soZXZlbnRUYXNrLCBzb3VyY2UsIGNhbGxiYWNrLCBkYXRhLCBjdXN0b21TY2hlZHVsZSwgY3VzdG9tQ2FuY2VsKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FuY2VsVGFzayh0YXNrKSB7XG4gICAgICAgICAgICBpZiAodGFzay56b25lICE9IHRoaXMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHRhc2sgY2FuIG9ubHkgYmUgY2FuY2VsbGVkIGluIHRoZSB6b25lIG9mIGNyZWF0aW9uISAoQ3JlYXRpb246ICcgK1xuICAgICAgICAgICAgICAgICAgICAodGFzay56b25lIHx8IE5PX1pPTkUpLm5hbWUgKyAnOyBFeGVjdXRpb246ICcgKyB0aGlzLm5hbWUgKyAnKScpO1xuICAgICAgICAgICAgdGFzay5fdHJhbnNpdGlvblRvKGNhbmNlbGluZywgc2NoZWR1bGVkLCBydW5uaW5nKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fem9uZURlbGVnYXRlLmNhbmNlbFRhc2sodGhpcywgdGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgZXJyb3Igb2NjdXJzIHdoZW4gY2FuY2VsVGFzaywgdHJhbnNpdCB0aGUgc3RhdGUgdG8gdW5rbm93blxuICAgICAgICAgICAgICAgIHRhc2suX3RyYW5zaXRpb25Ubyh1bmtub3duLCBjYW5jZWxpbmcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3pvbmVEZWxlZ2F0ZS5oYW5kbGVFcnJvcih0aGlzLCBlcnIpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRhc2tDb3VudCh0YXNrLCAtMSk7XG4gICAgICAgICAgICB0YXNrLl90cmFuc2l0aW9uVG8obm90U2NoZWR1bGVkLCBjYW5jZWxpbmcpO1xuICAgICAgICAgICAgdGFzay5ydW5Db3VudCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gdGFzaztcbiAgICAgICAgfVxuICAgICAgICBfdXBkYXRlVGFza0NvdW50KHRhc2ssIGNvdW50KSB7XG4gICAgICAgICAgICBjb25zdCB6b25lRGVsZWdhdGVzID0gdGFzay5fem9uZURlbGVnYXRlcztcbiAgICAgICAgICAgIGlmIChjb3VudCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRhc2suX3pvbmVEZWxlZ2F0ZXMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6b25lRGVsZWdhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgem9uZURlbGVnYXRlc1tpXS5fdXBkYXRlVGFza0NvdW50KHRhc2sudHlwZSwgY291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpyZXF1aXJlLWludGVybmFsLXdpdGgtdW5kZXJzY29yZVxuICAgIFpvbmUuX19zeW1ib2xfXyA9IF9fc3ltYm9sX187XG4gICAgY29uc3QgREVMRUdBVEVfWlMgPSB7XG4gICAgICAgIG5hbWU6ICcnLFxuICAgICAgICBvbkhhc1Rhc2s6IChkZWxlZ2F0ZSwgXywgdGFyZ2V0LCBoYXNUYXNrU3RhdGUpID0+IGRlbGVnYXRlLmhhc1Rhc2sodGFyZ2V0LCBoYXNUYXNrU3RhdGUpLFxuICAgICAgICBvblNjaGVkdWxlVGFzazogKGRlbGVnYXRlLCBfLCB0YXJnZXQsIHRhc2spID0+IGRlbGVnYXRlLnNjaGVkdWxlVGFzayh0YXJnZXQsIHRhc2spLFxuICAgICAgICBvbkludm9rZVRhc2s6IChkZWxlZ2F0ZSwgXywgdGFyZ2V0LCB0YXNrLCBhcHBseVRoaXMsIGFwcGx5QXJncykgPT4gZGVsZWdhdGUuaW52b2tlVGFzayh0YXJnZXQsIHRhc2ssIGFwcGx5VGhpcywgYXBwbHlBcmdzKSxcbiAgICAgICAgb25DYW5jZWxUYXNrOiAoZGVsZWdhdGUsIF8sIHRhcmdldCwgdGFzaykgPT4gZGVsZWdhdGUuY2FuY2VsVGFzayh0YXJnZXQsIHRhc2spXG4gICAgfTtcbiAgICBjbGFzcyBfWm9uZURlbGVnYXRlIHtcbiAgICAgICAgY29uc3RydWN0b3Ioem9uZSwgcGFyZW50RGVsZWdhdGUsIHpvbmVTcGVjKSB7XG4gICAgICAgICAgICB0aGlzLl90YXNrQ291bnRzID0geyAnbWljcm9UYXNrJzogMCwgJ21hY3JvVGFzayc6IDAsICdldmVudFRhc2snOiAwIH07XG4gICAgICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50RGVsZWdhdGUgPSBwYXJlbnREZWxlZ2F0ZTtcbiAgICAgICAgICAgIHRoaXMuX2ZvcmtaUyA9IHpvbmVTcGVjICYmICh6b25lU3BlYyAmJiB6b25lU3BlYy5vbkZvcmsgPyB6b25lU3BlYyA6IHBhcmVudERlbGVnYXRlLl9mb3JrWlMpO1xuICAgICAgICAgICAgdGhpcy5fZm9ya0RsZ3QgPSB6b25lU3BlYyAmJiAoem9uZVNwZWMub25Gb3JrID8gcGFyZW50RGVsZWdhdGUgOiBwYXJlbnREZWxlZ2F0ZS5fZm9ya0RsZ3QpO1xuICAgICAgICAgICAgdGhpcy5fZm9ya0N1cnJab25lID1cbiAgICAgICAgICAgICAgICB6b25lU3BlYyAmJiAoem9uZVNwZWMub25Gb3JrID8gdGhpcy56b25lIDogcGFyZW50RGVsZWdhdGUuX2ZvcmtDdXJyWm9uZSk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcmNlcHRaUyA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uSW50ZXJjZXB0ID8gem9uZVNwZWMgOiBwYXJlbnREZWxlZ2F0ZS5faW50ZXJjZXB0WlMpO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJjZXB0RGxndCA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uSW50ZXJjZXB0ID8gcGFyZW50RGVsZWdhdGUgOiBwYXJlbnREZWxlZ2F0ZS5faW50ZXJjZXB0RGxndCk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcmNlcHRDdXJyWm9uZSA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uSW50ZXJjZXB0ID8gdGhpcy56b25lIDogcGFyZW50RGVsZWdhdGUuX2ludGVyY2VwdEN1cnJab25lKTtcbiAgICAgICAgICAgIHRoaXMuX2ludm9rZVpTID0gem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uSW52b2tlID8gem9uZVNwZWMgOiBwYXJlbnREZWxlZ2F0ZS5faW52b2tlWlMpO1xuICAgICAgICAgICAgdGhpcy5faW52b2tlRGxndCA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uSW52b2tlID8gcGFyZW50RGVsZWdhdGUgOiBwYXJlbnREZWxlZ2F0ZS5faW52b2tlRGxndCk7XG4gICAgICAgICAgICB0aGlzLl9pbnZva2VDdXJyWm9uZSA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uSW52b2tlID8gdGhpcy56b25lIDogcGFyZW50RGVsZWdhdGUuX2ludm9rZUN1cnJab25lKTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUVycm9yWlMgPVxuICAgICAgICAgICAgICAgIHpvbmVTcGVjICYmICh6b25lU3BlYy5vbkhhbmRsZUVycm9yID8gem9uZVNwZWMgOiBwYXJlbnREZWxlZ2F0ZS5faGFuZGxlRXJyb3JaUyk7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVFcnJvckRsZ3QgPVxuICAgICAgICAgICAgICAgIHpvbmVTcGVjICYmICh6b25lU3BlYy5vbkhhbmRsZUVycm9yID8gcGFyZW50RGVsZWdhdGUgOiBwYXJlbnREZWxlZ2F0ZS5faGFuZGxlRXJyb3JEbGd0KTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUVycm9yQ3VyclpvbmUgPVxuICAgICAgICAgICAgICAgIHpvbmVTcGVjICYmICh6b25lU3BlYy5vbkhhbmRsZUVycm9yID8gdGhpcy56b25lIDogcGFyZW50RGVsZWdhdGUuX2hhbmRsZUVycm9yQ3VyclpvbmUpO1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVUYXNrWlMgPVxuICAgICAgICAgICAgICAgIHpvbmVTcGVjICYmICh6b25lU3BlYy5vblNjaGVkdWxlVGFzayA/IHpvbmVTcGVjIDogcGFyZW50RGVsZWdhdGUuX3NjaGVkdWxlVGFza1pTKTtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlVGFza0RsZ3QgPSB6b25lU3BlYyAmJlxuICAgICAgICAgICAgICAgICh6b25lU3BlYy5vblNjaGVkdWxlVGFzayA/IHBhcmVudERlbGVnYXRlIDogcGFyZW50RGVsZWdhdGUuX3NjaGVkdWxlVGFza0RsZ3QpO1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVUYXNrQ3VyclpvbmUgPVxuICAgICAgICAgICAgICAgIHpvbmVTcGVjICYmICh6b25lU3BlYy5vblNjaGVkdWxlVGFzayA/IHRoaXMuem9uZSA6IHBhcmVudERlbGVnYXRlLl9zY2hlZHVsZVRhc2tDdXJyWm9uZSk7XG4gICAgICAgICAgICB0aGlzLl9pbnZva2VUYXNrWlMgPVxuICAgICAgICAgICAgICAgIHpvbmVTcGVjICYmICh6b25lU3BlYy5vbkludm9rZVRhc2sgPyB6b25lU3BlYyA6IHBhcmVudERlbGVnYXRlLl9pbnZva2VUYXNrWlMpO1xuICAgICAgICAgICAgdGhpcy5faW52b2tlVGFza0RsZ3QgPVxuICAgICAgICAgICAgICAgIHpvbmVTcGVjICYmICh6b25lU3BlYy5vbkludm9rZVRhc2sgPyBwYXJlbnREZWxlZ2F0ZSA6IHBhcmVudERlbGVnYXRlLl9pbnZva2VUYXNrRGxndCk7XG4gICAgICAgICAgICB0aGlzLl9pbnZva2VUYXNrQ3VyclpvbmUgPVxuICAgICAgICAgICAgICAgIHpvbmVTcGVjICYmICh6b25lU3BlYy5vbkludm9rZVRhc2sgPyB0aGlzLnpvbmUgOiBwYXJlbnREZWxlZ2F0ZS5faW52b2tlVGFza0N1cnJab25lKTtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbFRhc2taUyA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uQ2FuY2VsVGFzayA/IHpvbmVTcGVjIDogcGFyZW50RGVsZWdhdGUuX2NhbmNlbFRhc2taUyk7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxUYXNrRGxndCA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uQ2FuY2VsVGFzayA/IHBhcmVudERlbGVnYXRlIDogcGFyZW50RGVsZWdhdGUuX2NhbmNlbFRhc2tEbGd0KTtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbFRhc2tDdXJyWm9uZSA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uQ2FuY2VsVGFzayA/IHRoaXMuem9uZSA6IHBhcmVudERlbGVnYXRlLl9jYW5jZWxUYXNrQ3VyclpvbmUpO1xuICAgICAgICAgICAgdGhpcy5faGFzVGFza1pTID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2hhc1Rhc2tEbGd0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2hhc1Rhc2tEbGd0T3duZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faGFzVGFza0N1cnJab25lID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHpvbmVTcGVjSGFzVGFzayA9IHpvbmVTcGVjICYmIHpvbmVTcGVjLm9uSGFzVGFzaztcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEhhc1Rhc2sgPSBwYXJlbnREZWxlZ2F0ZSAmJiBwYXJlbnREZWxlZ2F0ZS5faGFzVGFza1pTO1xuICAgICAgICAgICAgaWYgKHpvbmVTcGVjSGFzVGFzayB8fCBwYXJlbnRIYXNUYXNrKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgbmVlZCB0byByZXBvcnQgaGFzVGFzaywgdGhhbiB0aGlzIFpTIG5lZWRzIHRvIGRvIHJlZiBjb3VudGluZyBvbiB0YXNrcy4gSW4gc3VjaFxuICAgICAgICAgICAgICAgIC8vIGEgY2FzZSBhbGwgdGFzayByZWxhdGVkIGludGVyY2VwdG9ycyBtdXN0IGdvIHRocm91Z2ggdGhpcyBaRC4gV2UgY2FuJ3Qgc2hvcnQgY2lyY3VpdCBpdC5cbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNUYXNrWlMgPSB6b25lU3BlY0hhc1Rhc2sgPyB6b25lU3BlYyA6IERFTEVHQVRFX1pTO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhc1Rhc2tEbGd0ID0gcGFyZW50RGVsZWdhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFzVGFza0RsZ3RPd25lciA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFzVGFza0N1cnJab25lID0gem9uZTtcbiAgICAgICAgICAgICAgICBpZiAoIXpvbmVTcGVjLm9uU2NoZWR1bGVUYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlVGFza1pTID0gREVMRUdBVEVfWlM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlVGFza0RsZ3QgPSBwYXJlbnREZWxlZ2F0ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVUYXNrQ3VyclpvbmUgPSB0aGlzLnpvbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghem9uZVNwZWMub25JbnZva2VUYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ludm9rZVRhc2taUyA9IERFTEVHQVRFX1pTO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnZva2VUYXNrRGxndCA9IHBhcmVudERlbGVnYXRlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnZva2VUYXNrQ3VyclpvbmUgPSB0aGlzLnpvbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghem9uZVNwZWMub25DYW5jZWxUYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbFRhc2taUyA9IERFTEVHQVRFX1pTO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWxUYXNrRGxndCA9IHBhcmVudERlbGVnYXRlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWxUYXNrQ3VyclpvbmUgPSB0aGlzLnpvbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvcmsodGFyZ2V0Wm9uZSwgem9uZVNwZWMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb3JrWlMgPyB0aGlzLl9mb3JrWlMub25Gb3JrKHRoaXMuX2ZvcmtEbGd0LCB0aGlzLnpvbmUsIHRhcmdldFpvbmUsIHpvbmVTcGVjKSA6XG4gICAgICAgICAgICAgICAgbmV3IFpvbmUodGFyZ2V0Wm9uZSwgem9uZVNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIGludGVyY2VwdCh0YXJnZXRab25lLCBjYWxsYmFjaywgc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJjZXB0WlMgP1xuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVyY2VwdFpTLm9uSW50ZXJjZXB0KHRoaXMuX2ludGVyY2VwdERsZ3QsIHRoaXMuX2ludGVyY2VwdEN1cnJab25lLCB0YXJnZXRab25lLCBjYWxsYmFjaywgc291cmNlKSA6XG4gICAgICAgICAgICAgICAgY2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgaW52b2tlKHRhcmdldFpvbmUsIGNhbGxiYWNrLCBhcHBseVRoaXMsIGFwcGx5QXJncywgc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlWlMgPyB0aGlzLl9pbnZva2VaUy5vbkludm9rZSh0aGlzLl9pbnZva2VEbGd0LCB0aGlzLl9pbnZva2VDdXJyWm9uZSwgdGFyZ2V0Wm9uZSwgY2FsbGJhY2ssIGFwcGx5VGhpcywgYXBwbHlBcmdzLCBzb3VyY2UpIDpcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShhcHBseVRoaXMsIGFwcGx5QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlRXJyb3IodGFyZ2V0Wm9uZSwgZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVFcnJvclpTID9cbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVFcnJvclpTLm9uSGFuZGxlRXJyb3IodGhpcy5faGFuZGxlRXJyb3JEbGd0LCB0aGlzLl9oYW5kbGVFcnJvckN1cnJab25lLCB0YXJnZXRab25lLCBlcnJvcikgOlxuICAgICAgICAgICAgICAgIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc2NoZWR1bGVUYXNrKHRhcmdldFpvbmUsIHRhc2spIHtcbiAgICAgICAgICAgIGxldCByZXR1cm5UYXNrID0gdGFzaztcbiAgICAgICAgICAgIGlmICh0aGlzLl9zY2hlZHVsZVRhc2taUykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oYXNUYXNrWlMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVGFzay5fem9uZURlbGVnYXRlcy5wdXNoKHRoaXMuX2hhc1Rhc2tEbGd0T3duZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjbGFuZy1mb3JtYXQgb2ZmXG4gICAgICAgICAgICAgICAgcmV0dXJuVGFzayA9IHRoaXMuX3NjaGVkdWxlVGFza1pTLm9uU2NoZWR1bGVUYXNrKHRoaXMuX3NjaGVkdWxlVGFza0RsZ3QsIHRoaXMuX3NjaGVkdWxlVGFza0N1cnJab25lLCB0YXJnZXRab25lLCB0YXNrKTtcbiAgICAgICAgICAgICAgICAvLyBjbGFuZy1mb3JtYXQgb25cbiAgICAgICAgICAgICAgICBpZiAoIXJldHVyblRhc2spXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblRhc2sgPSB0YXNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhc2suc2NoZWR1bGVGbikge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnNjaGVkdWxlRm4odGFzayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRhc2sudHlwZSA9PSBtaWNyb1Rhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVNaWNyb1Rhc2sodGFzayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rhc2sgaXMgbWlzc2luZyBzY2hlZHVsZUZuLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXR1cm5UYXNrO1xuICAgICAgICB9XG4gICAgICAgIGludm9rZVRhc2sodGFyZ2V0Wm9uZSwgdGFzaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnZva2VUYXNrWlMgPyB0aGlzLl9pbnZva2VUYXNrWlMub25JbnZva2VUYXNrKHRoaXMuX2ludm9rZVRhc2tEbGd0LCB0aGlzLl9pbnZva2VUYXNrQ3VyclpvbmUsIHRhcmdldFpvbmUsIHRhc2ssIGFwcGx5VGhpcywgYXBwbHlBcmdzKSA6XG4gICAgICAgICAgICAgICAgdGFzay5jYWxsYmFjay5hcHBseShhcHBseVRoaXMsIGFwcGx5QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FuY2VsVGFzayh0YXJnZXRab25lLCB0YXNrKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2FuY2VsVGFza1pTKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9jYW5jZWxUYXNrWlMub25DYW5jZWxUYXNrKHRoaXMuX2NhbmNlbFRhc2tEbGd0LCB0aGlzLl9jYW5jZWxUYXNrQ3VyclpvbmUsIHRhcmdldFpvbmUsIHRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0YXNrLmNhbmNlbEZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdUYXNrIGlzIG5vdCBjYW5jZWxhYmxlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGFzay5jYW5jZWxGbih0YXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBoYXNUYXNrKHRhcmdldFpvbmUsIGlzRW1wdHkpIHtcbiAgICAgICAgICAgIC8vIGhhc1Rhc2sgc2hvdWxkIG5vdCB0aHJvdyBlcnJvciBzbyBvdGhlciBab25lRGVsZWdhdGVcbiAgICAgICAgICAgIC8vIGNhbiBzdGlsbCB0cmlnZ2VyIGhhc1Rhc2sgY2FsbGJhY2tcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFzVGFza1pTICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhc1Rhc2taUy5vbkhhc1Rhc2sodGhpcy5faGFzVGFza0RsZ3QsIHRoaXMuX2hhc1Rhc2tDdXJyWm9uZSwgdGFyZ2V0Wm9uZSwgaXNFbXB0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcih0YXJnZXRab25lLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpyZXF1aXJlLWludGVybmFsLXdpdGgtdW5kZXJzY29yZVxuICAgICAgICBfdXBkYXRlVGFza0NvdW50KHR5cGUsIGNvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBjb3VudHMgPSB0aGlzLl90YXNrQ291bnRzO1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IGNvdW50c1t0eXBlXTtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBjb3VudHNbdHlwZV0gPSBwcmV2ICsgY291bnQ7XG4gICAgICAgICAgICBpZiAobmV4dCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01vcmUgdGFza3MgZXhlY3V0ZWQgdGhlbiB3ZXJlIHNjaGVkdWxlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2ID09IDAgfHwgbmV4dCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNFbXB0eSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbWljcm9UYXNrOiBjb3VudHNbJ21pY3JvVGFzayddID4gMCxcbiAgICAgICAgICAgICAgICAgICAgbWFjcm9UYXNrOiBjb3VudHNbJ21hY3JvVGFzayddID4gMCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRUYXNrOiBjb3VudHNbJ2V2ZW50VGFzayddID4gMCxcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlOiB0eXBlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc1Rhc2sodGhpcy56b25lLCBpc0VtcHR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGFzcyBab25lVGFzayB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHR5cGUsIHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnMsIHNjaGVkdWxlRm4sIGNhbmNlbEZuKSB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6cmVxdWlyZS1pbnRlcm5hbC13aXRoLXVuZGVyc2NvcmVcbiAgICAgICAgICAgIHRoaXMuX3pvbmUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5ydW5Db3VudCA9IDA7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6cmVxdWlyZS1pbnRlcm5hbC13aXRoLXVuZGVyc2NvcmVcbiAgICAgICAgICAgIHRoaXMuX3pvbmVEZWxlZ2F0ZXMgPSBudWxsO1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnJlcXVpcmUtaW50ZXJuYWwtd2l0aC11bmRlcnNjb3JlXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9ICdub3RTY2hlZHVsZWQnO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVGbiA9IHNjaGVkdWxlRm47XG4gICAgICAgICAgICB0aGlzLmNhbmNlbEZuID0gY2FuY2VsRm47XG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsYmFjayBpcyBub3QgZGVmaW5lZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAvLyBUT0RPOiBASmlhTGlQYXNzaW9uIG9wdGlvbnMgc2hvdWxkIGhhdmUgaW50ZXJmYWNlXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gZXZlbnRUYXNrICYmIG9wdGlvbnMgJiYgb3B0aW9ucy51c2VHKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnZva2UgPSBab25lVGFzay5pbnZva2VUYXNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnZva2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBab25lVGFzay5pbnZva2VUYXNrLmNhbGwoZ2xvYmFsLCBzZWxmLCB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGludm9rZVRhc2sodGFzaywgdGFyZ2V0LCBhcmdzKSB7XG4gICAgICAgICAgICBpZiAoIXRhc2spIHtcbiAgICAgICAgICAgICAgICB0YXNrID0gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9udW1iZXJPZk5lc3RlZFRhc2tGcmFtZXMrKztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGFzay5ydW5Db3VudCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLnpvbmUucnVuVGFzayh0YXNrLCB0YXJnZXQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKF9udW1iZXJPZk5lc3RlZFRhc2tGcmFtZXMgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBkcmFpbk1pY3JvVGFza1F1ZXVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9udW1iZXJPZk5lc3RlZFRhc2tGcmFtZXMtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXQgem9uZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lO1xuICAgICAgICB9XG4gICAgICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjYW5jZWxTY2hlZHVsZVJlcXVlc3QoKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uVG8obm90U2NoZWR1bGVkLCBzY2hlZHVsaW5nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6cmVxdWlyZS1pbnRlcm5hbC13aXRoLXVuZGVyc2NvcmVcbiAgICAgICAgX3RyYW5zaXRpb25Ubyh0b1N0YXRlLCBmcm9tU3RhdGUxLCBmcm9tU3RhdGUyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IGZyb21TdGF0ZTEgfHwgdGhpcy5fc3RhdGUgPT09IGZyb21TdGF0ZTIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHRvU3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHRvU3RhdGUgPT0gbm90U2NoZWR1bGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3pvbmVEZWxlZ2F0ZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLnR5cGV9ICcke3RoaXMuc291cmNlfSc6IGNhbiBub3QgdHJhbnNpdGlvbiB0byAnJHt0b1N0YXRlfScsIGV4cGVjdGluZyBzdGF0ZSAnJHtmcm9tU3RhdGUxfScke2Zyb21TdGF0ZTIgPyAnIG9yIFxcJycgKyBmcm9tU3RhdGUyICsgJ1xcJycgOiAnJ30sIHdhcyAnJHt0aGlzLl9zdGF0ZX0nLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YSAmJiB0eXBlb2YgdGhpcy5kYXRhLmhhbmRsZUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuaGFuZGxlSWQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIHRvSlNPTiBtZXRob2QgdG8gcHJldmVudCBjeWNsaWMgZXJyb3Igd2hlblxuICAgICAgICAvLyBjYWxsIEpTT04uc3RyaW5naWZ5KHpvbmVUYXNrKVxuICAgICAgICB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICAgICAgICAgIHpvbmU6IHRoaXMuem9uZS5uYW1lLFxuICAgICAgICAgICAgICAgIHJ1bkNvdW50OiB0aGlzLnJ1bkNvdW50XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLyAgTUlDUk9UQVNLIFFVRVVFXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgY29uc3Qgc3ltYm9sU2V0VGltZW91dCA9IF9fc3ltYm9sX18oJ3NldFRpbWVvdXQnKTtcbiAgICBjb25zdCBzeW1ib2xQcm9taXNlID0gX19zeW1ib2xfXygnUHJvbWlzZScpO1xuICAgIGNvbnN0IHN5bWJvbFRoZW4gPSBfX3N5bWJvbF9fKCd0aGVuJyk7XG4gICAgbGV0IF9taWNyb1Rhc2tRdWV1ZSA9IFtdO1xuICAgIGxldCBfaXNEcmFpbmluZ01pY3JvdGFza1F1ZXVlID0gZmFsc2U7XG4gICAgbGV0IG5hdGl2ZU1pY3JvVGFza1F1ZXVlUHJvbWlzZTtcbiAgICBmdW5jdGlvbiBuYXRpdmVTY2hlZHVsZU1pY3JvVGFzayhmdW5jKSB7XG4gICAgICAgIGlmICghbmF0aXZlTWljcm9UYXNrUXVldWVQcm9taXNlKSB7XG4gICAgICAgICAgICBpZiAoZ2xvYmFsW3N5bWJvbFByb21pc2VdKSB7XG4gICAgICAgICAgICAgICAgbmF0aXZlTWljcm9UYXNrUXVldWVQcm9taXNlID0gZ2xvYmFsW3N5bWJvbFByb21pc2VdLnJlc29sdmUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hdGl2ZU1pY3JvVGFza1F1ZXVlUHJvbWlzZSkge1xuICAgICAgICAgICAgbGV0IG5hdGl2ZVRoZW4gPSBuYXRpdmVNaWNyb1Rhc2tRdWV1ZVByb21pc2Vbc3ltYm9sVGhlbl07XG4gICAgICAgICAgICBpZiAoIW5hdGl2ZVRoZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBuYXRpdmUgUHJvbWlzZSBpcyBub3QgcGF0Y2hhYmxlLCB3ZSBuZWVkIHRvIHVzZSBgdGhlbmAgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyBpc3N1ZSAxMDc4XG4gICAgICAgICAgICAgICAgbmF0aXZlVGhlbiA9IG5hdGl2ZU1pY3JvVGFza1F1ZXVlUHJvbWlzZVsndGhlbiddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmF0aXZlVGhlbi5jYWxsKG5hdGl2ZU1pY3JvVGFza1F1ZXVlUHJvbWlzZSwgZnVuYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWxbc3ltYm9sU2V0VGltZW91dF0oZnVuYywgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNaWNyb1Rhc2sodGFzaykge1xuICAgICAgICAvLyBpZiB3ZSBhcmUgbm90IHJ1bm5pbmcgaW4gYW55IHRhc2ssIGFuZCB0aGVyZSBoYXMgbm90IGJlZW4gYW55dGhpbmcgc2NoZWR1bGVkXG4gICAgICAgIC8vIHdlIG11c3QgYm9vdHN0cmFwIHRoZSBpbml0aWFsIHRhc2sgY3JlYXRpb24gYnkgbWFudWFsbHkgc2NoZWR1bGluZyB0aGUgZHJhaW5cbiAgICAgICAgaWYgKF9udW1iZXJPZk5lc3RlZFRhc2tGcmFtZXMgPT09IDAgJiYgX21pY3JvVGFza1F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gV2UgYXJlIG5vdCBydW5uaW5nIGluIFRhc2ssIHNvIHdlIG5lZWQgdG8ga2lja3N0YXJ0IHRoZSBtaWNyb3Rhc2sgcXVldWUuXG4gICAgICAgICAgICBuYXRpdmVTY2hlZHVsZU1pY3JvVGFzayhkcmFpbk1pY3JvVGFza1F1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICB0YXNrICYmIF9taWNyb1Rhc2tRdWV1ZS5wdXNoKHRhc2spO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkcmFpbk1pY3JvVGFza1F1ZXVlKCkge1xuICAgICAgICBpZiAoIV9pc0RyYWluaW5nTWljcm90YXNrUXVldWUpIHtcbiAgICAgICAgICAgIF9pc0RyYWluaW5nTWljcm90YXNrUXVldWUgPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKF9taWNyb1Rhc2tRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBxdWV1ZSA9IF9taWNyb1Rhc2tRdWV1ZTtcbiAgICAgICAgICAgICAgICBfbWljcm9UYXNrUXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBxdWV1ZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suem9uZS5ydW5UYXNrKHRhc2ssIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2FwaS5vblVuaGFuZGxlZEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9hcGkubWljcm90YXNrRHJhaW5Eb25lKCk7XG4gICAgICAgICAgICBfaXNEcmFpbmluZ01pY3JvdGFza1F1ZXVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8vICBCT09UU1RSQVBcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBjb25zdCBOT19aT05FID0geyBuYW1lOiAnTk8gWk9ORScgfTtcbiAgICBjb25zdCBub3RTY2hlZHVsZWQgPSAnbm90U2NoZWR1bGVkJywgc2NoZWR1bGluZyA9ICdzY2hlZHVsaW5nJywgc2NoZWR1bGVkID0gJ3NjaGVkdWxlZCcsIHJ1bm5pbmcgPSAncnVubmluZycsIGNhbmNlbGluZyA9ICdjYW5jZWxpbmcnLCB1bmtub3duID0gJ3Vua25vd24nO1xuICAgIGNvbnN0IG1pY3JvVGFzayA9ICdtaWNyb1Rhc2snLCBtYWNyb1Rhc2sgPSAnbWFjcm9UYXNrJywgZXZlbnRUYXNrID0gJ2V2ZW50VGFzayc7XG4gICAgY29uc3QgcGF0Y2hlcyA9IHt9O1xuICAgIGNvbnN0IF9hcGkgPSB7XG4gICAgICAgIHN5bWJvbDogX19zeW1ib2xfXyxcbiAgICAgICAgY3VycmVudFpvbmVGcmFtZTogKCkgPT4gX2N1cnJlbnRab25lRnJhbWUsXG4gICAgICAgIG9uVW5oYW5kbGVkRXJyb3I6IG5vb3AsXG4gICAgICAgIG1pY3JvdGFza0RyYWluRG9uZTogbm9vcCxcbiAgICAgICAgc2NoZWR1bGVNaWNyb1Rhc2s6IHNjaGVkdWxlTWljcm9UYXNrLFxuICAgICAgICBzaG93VW5jYXVnaHRFcnJvcjogKCkgPT4gIVpvbmVbX19zeW1ib2xfXygnaWdub3JlQ29uc29sZUVycm9yVW5jYXVnaHRFcnJvcicpXSxcbiAgICAgICAgcGF0Y2hFdmVudFRhcmdldDogKCkgPT4gW10sXG4gICAgICAgIHBhdGNoT25Qcm9wZXJ0aWVzOiBub29wLFxuICAgICAgICBwYXRjaE1ldGhvZDogKCkgPT4gbm9vcCxcbiAgICAgICAgYmluZEFyZ3VtZW50czogKCkgPT4gW10sXG4gICAgICAgIHBhdGNoVGhlbjogKCkgPT4gbm9vcCxcbiAgICAgICAgcGF0Y2hNYWNyb1Rhc2s6ICgpID0+IG5vb3AsXG4gICAgICAgIHBhdGNoRXZlbnRQcm90b3R5cGU6ICgpID0+IG5vb3AsXG4gICAgICAgIGlzSUVPckVkZ2U6ICgpID0+IGZhbHNlLFxuICAgICAgICBnZXRHbG9iYWxPYmplY3RzOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgICAgIE9iamVjdERlZmluZVByb3BlcnR5OiAoKSA9PiBub29wLFxuICAgICAgICBPYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICgpID0+IHVuZGVmaW5lZCxcbiAgICAgICAgT2JqZWN0Q3JlYXRlOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgICAgIEFycmF5U2xpY2U6ICgpID0+IFtdLFxuICAgICAgICBwYXRjaENsYXNzOiAoKSA9PiBub29wLFxuICAgICAgICB3cmFwV2l0aEN1cnJlbnRab25lOiAoKSA9PiBub29wLFxuICAgICAgICBmaWx0ZXJQcm9wZXJ0aWVzOiAoKSA9PiBbXSxcbiAgICAgICAgYXR0YWNoT3JpZ2luVG9QYXRjaGVkOiAoKSA9PiBub29wLFxuICAgICAgICBfcmVkZWZpbmVQcm9wZXJ0eTogKCkgPT4gbm9vcCxcbiAgICAgICAgcGF0Y2hDYWxsYmFja3M6ICgpID0+IG5vb3AsXG4gICAgICAgIG5hdGl2ZVNjaGVkdWxlTWljcm9UYXNrOiBuYXRpdmVTY2hlZHVsZU1pY3JvVGFza1xuICAgIH07XG4gICAgbGV0IF9jdXJyZW50Wm9uZUZyYW1lID0geyBwYXJlbnQ6IG51bGwsIHpvbmU6IG5ldyBab25lKG51bGwsIG51bGwpIH07XG4gICAgbGV0IF9jdXJyZW50VGFzayA9IG51bGw7XG4gICAgbGV0IF9udW1iZXJPZk5lc3RlZFRhc2tGcmFtZXMgPSAwO1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7IH1cbiAgICBwZXJmb3JtYW5jZU1lYXN1cmUoJ1pvbmUnLCAnWm9uZScpO1xuICAgIHJldHVybiBnbG9iYWxbJ1pvbmUnXSA9IFpvbmU7XG59KSkodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93IHx8IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIHx8IGdsb2JhbCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBTdXBwcmVzcyBjbG9zdXJlIGNvbXBpbGVyIGVycm9ycyBhYm91dCB1bmtub3duICdab25lJyB2YXJpYWJsZVxuICogQGZpbGVvdmVydmlld1xuICogQHN1cHByZXNzIHt1bmRlZmluZWRWYXJzLGdsb2JhbFRoaXMsbWlzc2luZ1JlcXVpcmV9XG4gKi9cbi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwibm9kZVwiLz5cbi8vIGlzc3VlICM5ODksIHRvIHJlZHVjZSBidW5kbGUgc2l6ZSwgdXNlIHNob3J0IG5hbWVcbi8qKiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICovXG5jb25zdCBPYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuLyoqIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAqL1xuY29uc3QgT2JqZWN0RGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4vKiogT2JqZWN0LmdldFByb3RvdHlwZU9mICovXG5jb25zdCBPYmplY3RHZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbi8qKiBPYmplY3QuY3JlYXRlICovXG5jb25zdCBPYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuLyoqIEFycmF5LnByb3RvdHlwZS5zbGljZSAqL1xuY29uc3QgQXJyYXlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbi8qKiBhZGRFdmVudExpc3RlbmVyIHN0cmluZyBjb25zdCAqL1xuY29uc3QgQUREX0VWRU5UX0xJU1RFTkVSX1NUUiA9ICdhZGRFdmVudExpc3RlbmVyJztcbi8qKiByZW1vdmVFdmVudExpc3RlbmVyIHN0cmluZyBjb25zdCAqL1xuY29uc3QgUkVNT1ZFX0VWRU5UX0xJU1RFTkVSX1NUUiA9ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbi8qKiB6b25lU3ltYm9sIGFkZEV2ZW50TGlzdGVuZXIgKi9cbmNvbnN0IFpPTkVfU1lNQk9MX0FERF9FVkVOVF9MSVNURU5FUiA9IFpvbmUuX19zeW1ib2xfXyhBRERfRVZFTlRfTElTVEVORVJfU1RSKTtcbi8qKiB6b25lU3ltYm9sIHJlbW92ZUV2ZW50TGlzdGVuZXIgKi9cbmNvbnN0IFpPTkVfU1lNQk9MX1JFTU9WRV9FVkVOVF9MSVNURU5FUiA9IFpvbmUuX19zeW1ib2xfXyhSRU1PVkVfRVZFTlRfTElTVEVORVJfU1RSKTtcbi8qKiB0cnVlIHN0cmluZyBjb25zdCAqL1xuY29uc3QgVFJVRV9TVFIgPSAndHJ1ZSc7XG4vKiogZmFsc2Ugc3RyaW5nIGNvbnN0ICovXG5jb25zdCBGQUxTRV9TVFIgPSAnZmFsc2UnO1xuLyoqIFpvbmUgc3ltYm9sIHByZWZpeCBzdHJpbmcgY29uc3QuICovXG5jb25zdCBaT05FX1NZTUJPTF9QUkVGSVggPSBab25lLl9fc3ltYm9sX18oJycpO1xuZnVuY3Rpb24gd3JhcFdpdGhDdXJyZW50Wm9uZShjYWxsYmFjaywgc291cmNlKSB7XG4gICAgcmV0dXJuIFpvbmUuY3VycmVudC53cmFwKGNhbGxiYWNrLCBzb3VyY2UpO1xufVxuZnVuY3Rpb24gc2NoZWR1bGVNYWNyb1Rhc2tXaXRoQ3VycmVudFpvbmUoc291cmNlLCBjYWxsYmFjaywgZGF0YSwgY3VzdG9tU2NoZWR1bGUsIGN1c3RvbUNhbmNlbCkge1xuICAgIHJldHVybiBab25lLmN1cnJlbnQuc2NoZWR1bGVNYWNyb1Rhc2soc291cmNlLCBjYWxsYmFjaywgZGF0YSwgY3VzdG9tU2NoZWR1bGUsIGN1c3RvbUNhbmNlbCk7XG59XG5jb25zdCB6b25lU3ltYm9sID0gWm9uZS5fX3N5bWJvbF9fO1xuY29uc3QgaXNXaW5kb3dFeGlzdHMgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IGludGVybmFsV2luZG93ID0gaXNXaW5kb3dFeGlzdHMgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG5jb25zdCBfZ2xvYmFsID0gaXNXaW5kb3dFeGlzdHMgJiYgaW50ZXJuYWxXaW5kb3cgfHwgdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICYmIHNlbGYgfHwgZ2xvYmFsO1xuY29uc3QgUkVNT1ZFX0FUVFJJQlVURSA9ICdyZW1vdmVBdHRyaWJ1dGUnO1xuZnVuY3Rpb24gYmluZEFyZ3VtZW50cyhhcmdzLCBzb3VyY2UpIHtcbiAgICBmb3IgKGxldCBpID0gYXJncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbaV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFyZ3NbaV0gPSB3cmFwV2l0aEN1cnJlbnRab25lKGFyZ3NbaV0sIHNvdXJjZSArICdfJyArIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcmdzO1xufVxuZnVuY3Rpb24gcGF0Y2hQcm90b3R5cGUocHJvdG90eXBlLCBmbk5hbWVzKSB7XG4gICAgY29uc3Qgc291cmNlID0gcHJvdG90eXBlLmNvbnN0cnVjdG9yWyduYW1lJ107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbk5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmbk5hbWVzW2ldO1xuICAgICAgICBjb25zdCBkZWxlZ2F0ZSA9IHByb3RvdHlwZVtuYW1lXTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBwcm90b3R5cGVEZXNjID0gT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvdHlwZSwgbmFtZSk7XG4gICAgICAgICAgICBpZiAoIWlzUHJvcGVydHlXcml0YWJsZShwcm90b3R5cGVEZXNjKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvdG90eXBlW25hbWVdID0gKChkZWxlZ2F0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5hcHBseSh0aGlzLCBiaW5kQXJndW1lbnRzKGFyZ3VtZW50cywgc291cmNlICsgJy4nICsgbmFtZSkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYXR0YWNoT3JpZ2luVG9QYXRjaGVkKHBhdGNoZWQsIGRlbGVnYXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0Y2hlZDtcbiAgICAgICAgICAgIH0pKGRlbGVnYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzUHJvcGVydHlXcml0YWJsZShwcm9wZXJ0eURlc2MpIHtcbiAgICBpZiAoIXByb3BlcnR5RGVzYykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByb3BlcnR5RGVzYy53cml0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gISh0eXBlb2YgcHJvcGVydHlEZXNjLmdldCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcHJvcGVydHlEZXNjLnNldCA9PT0gJ3VuZGVmaW5lZCcpO1xufVxuY29uc3QgaXNXZWJXb3JrZXIgPSAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpO1xuLy8gTWFrZSBzdXJlIHRvIGFjY2VzcyBgcHJvY2Vzc2AgdGhyb3VnaCBgX2dsb2JhbGAgc28gdGhhdCBXZWJQYWNrIGRvZXMgbm90IGFjY2lkZW50YWxseSBicm93c2VyaWZ5XG4vLyB0aGlzIGNvZGUuXG5jb25zdCBpc05vZGUgPSAoISgnbncnIGluIF9nbG9iYWwpICYmIHR5cGVvZiBfZ2xvYmFsLnByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmXG4gICAge30udG9TdHJpbmcuY2FsbChfZ2xvYmFsLnByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpO1xuY29uc3QgaXNCcm93c2VyID0gIWlzTm9kZSAmJiAhaXNXZWJXb3JrZXIgJiYgISEoaXNXaW5kb3dFeGlzdHMgJiYgaW50ZXJuYWxXaW5kb3dbJ0hUTUxFbGVtZW50J10pO1xuLy8gd2UgYXJlIGluIGVsZWN0cm9uIG9mIG53LCBzbyB3ZSBhcmUgYm90aCBicm93c2VyIGFuZCBub2RlanNcbi8vIE1ha2Ugc3VyZSB0byBhY2Nlc3MgYHByb2Nlc3NgIHRocm91Z2ggYF9nbG9iYWxgIHNvIHRoYXQgV2ViUGFjayBkb2VzIG5vdCBhY2NpZGVudGFsbHkgYnJvd3NlcmlmeVxuLy8gdGhpcyBjb2RlLlxuY29uc3QgaXNNaXggPSB0eXBlb2YgX2dsb2JhbC5wcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHt9LnRvU3RyaW5nLmNhbGwoX2dsb2JhbC5wcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nICYmICFpc1dlYldvcmtlciAmJlxuICAgICEhKGlzV2luZG93RXhpc3RzICYmIGludGVybmFsV2luZG93WydIVE1MRWxlbWVudCddKTtcbmNvbnN0IHpvbmVTeW1ib2xFdmVudE5hbWVzJDEgPSB7fTtcbmNvbnN0IHdyYXBGbiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL3pvbmUuanMvaXNzdWVzLzkxMSwgaW4gSUUsIHNvbWV0aW1lc1xuICAgIC8vIGV2ZW50IHdpbGwgYmUgdW5kZWZpbmVkLCBzbyB3ZSBuZWVkIHRvIHVzZSB3aW5kb3cuZXZlbnRcbiAgICBldmVudCA9IGV2ZW50IHx8IF9nbG9iYWwuZXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBldmVudE5hbWVTeW1ib2wgPSB6b25lU3ltYm9sRXZlbnROYW1lcyQxW2V2ZW50LnR5cGVdO1xuICAgIGlmICghZXZlbnROYW1lU3ltYm9sKSB7XG4gICAgICAgIGV2ZW50TmFtZVN5bWJvbCA9IHpvbmVTeW1ib2xFdmVudE5hbWVzJDFbZXZlbnQudHlwZV0gPSB6b25lU3ltYm9sKCdPTl9QUk9QRVJUWScgKyBldmVudC50eXBlKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcyB8fCBldmVudC50YXJnZXQgfHwgX2dsb2JhbDtcbiAgICBjb25zdCBsaXN0ZW5lciA9IHRhcmdldFtldmVudE5hbWVTeW1ib2xdO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKGlzQnJvd3NlciAmJiB0YXJnZXQgPT09IGludGVybmFsV2luZG93ICYmIGV2ZW50LnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgLy8gd2luZG93Lm9uZXJyb3IgaGF2ZSBkaWZmZXJlbnQgc2lnbml0dXJlXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9HbG9iYWxFdmVudEhhbmRsZXJzL29uZXJyb3Ijd2luZG93Lm9uZXJyb3JcbiAgICAgICAgLy8gYW5kIG9uZXJyb3IgY2FsbGJhY2sgd2lsbCBwcmV2ZW50IGRlZmF1bHQgd2hlbiBjYWxsYmFjayByZXR1cm4gdHJ1ZVxuICAgICAgICBjb25zdCBlcnJvckV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIHJlc3VsdCA9IGxpc3RlbmVyICYmXG4gICAgICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGVycm9yRXZlbnQubWVzc2FnZSwgZXJyb3JFdmVudC5maWxlbmFtZSwgZXJyb3JFdmVudC5saW5lbm8sIGVycm9yRXZlbnQuY29sbm8sIGVycm9yRXZlbnQuZXJyb3IpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBsaXN0ZW5lciAmJiBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAocmVzdWx0ICE9IHVuZGVmaW5lZCAmJiAhcmVzdWx0KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZnVuY3Rpb24gcGF0Y2hQcm9wZXJ0eShvYmosIHByb3AsIHByb3RvdHlwZSkge1xuICAgIGxldCBkZXNjID0gT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG4gICAgaWYgKCFkZXNjICYmIHByb3RvdHlwZSkge1xuICAgICAgICAvLyB3aGVuIHBhdGNoIHdpbmRvdyBvYmplY3QsIHVzZSBwcm90b3R5cGUgdG8gY2hlY2sgcHJvcCBleGlzdCBvciBub3RcbiAgICAgICAgY29uc3QgcHJvdG90eXBlRGVzYyA9IE9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90b3R5cGUsIHByb3ApO1xuICAgICAgICBpZiAocHJvdG90eXBlRGVzYykge1xuICAgICAgICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgdGhlIGRlc2NyaXB0b3Igbm90IGV4aXN0cyBvciBpcyBub3QgY29uZmlndXJhYmxlXG4gICAgLy8ganVzdCByZXR1cm5cbiAgICBpZiAoIWRlc2MgfHwgIWRlc2MuY29uZmlndXJhYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb25Qcm9wUGF0Y2hlZFN5bWJvbCA9IHpvbmVTeW1ib2woJ29uJyArIHByb3AgKyAncGF0Y2hlZCcpO1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkob25Qcm9wUGF0Y2hlZFN5bWJvbCkgJiYgb2JqW29uUHJvcFBhdGNoZWRTeW1ib2xdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGNhbm5vdCBoYXZlIGdldHRlci9zZXR0ZXIgYW5kIGJlIHdyaXRhYmxlXG4gICAgLy8gZGVsZXRpbmcgdGhlIHdyaXRhYmxlIGFuZCB2YWx1ZSBwcm9wZXJ0aWVzIGF2b2lkcyB0aGlzIGVycm9yOlxuICAgIC8vXG4gICAgLy8gVHlwZUVycm9yOiBwcm9wZXJ0eSBkZXNjcmlwdG9ycyBtdXN0IG5vdCBzcGVjaWZ5IGEgdmFsdWUgb3IgYmUgd3JpdGFibGUgd2hlbiBhXG4gICAgLy8gZ2V0dGVyIG9yIHNldHRlciBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICBkZWxldGUgZGVzYy53cml0YWJsZTtcbiAgICBkZWxldGUgZGVzYy52YWx1ZTtcbiAgICBjb25zdCBvcmlnaW5hbERlc2NHZXQgPSBkZXNjLmdldDtcbiAgICBjb25zdCBvcmlnaW5hbERlc2NTZXQgPSBkZXNjLnNldDtcbiAgICAvLyBzdWJzdHIoMikgY3V6ICdvbmNsaWNrJyAtPiAnY2xpY2snLCBldGNcbiAgICBjb25zdCBldmVudE5hbWUgPSBwcm9wLnN1YnN0cigyKTtcbiAgICBsZXQgZXZlbnROYW1lU3ltYm9sID0gem9uZVN5bWJvbEV2ZW50TmFtZXMkMVtldmVudE5hbWVdO1xuICAgIGlmICghZXZlbnROYW1lU3ltYm9sKSB7XG4gICAgICAgIGV2ZW50TmFtZVN5bWJvbCA9IHpvbmVTeW1ib2xFdmVudE5hbWVzJDFbZXZlbnROYW1lXSA9IHpvbmVTeW1ib2woJ09OX1BST1BFUlRZJyArIGV2ZW50TmFtZSk7XG4gICAgfVxuICAgIGRlc2Muc2V0ID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgIC8vIGluIHNvbWUgb2Ygd2luZG93cydzIG9ucHJvcGVydHkgY2FsbGJhY2ssIHRoaXMgaXMgdW5kZWZpbmVkXG4gICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgaXRcbiAgICAgICAgbGV0IHRhcmdldCA9IHRoaXM7XG4gICAgICAgIGlmICghdGFyZ2V0ICYmIG9iaiA9PT0gX2dsb2JhbCkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gX2dsb2JhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0YXJnZXRbZXZlbnROYW1lU3ltYm9sXTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmV2aW91c1ZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHdyYXBGbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXNzdWUgIzk3OCwgd2hlbiBvbmxvYWQgaGFuZGxlciB3YXMgYWRkZWQgYmVmb3JlIGxvYWRpbmcgem9uZS5qc1xuICAgICAgICAvLyB3ZSBzaG91bGQgcmVtb3ZlIGl0IHdpdGggb3JpZ2luYWxEZXNjU2V0XG4gICAgICAgIG9yaWdpbmFsRGVzY1NldCAmJiBvcmlnaW5hbERlc2NTZXQuY2FsbCh0YXJnZXQsIG51bGwpO1xuICAgICAgICB0YXJnZXRbZXZlbnROYW1lU3ltYm9sXSA9IG5ld1ZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIG5ld1ZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHdyYXBGbiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBUaGUgZ2V0dGVyIHdvdWxkIHJldHVybiB1bmRlZmluZWQgZm9yIHVuYXNzaWduZWQgcHJvcGVydGllcyBidXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYW5cbiAgICAvLyB1bmFzc2lnbmVkIHByb3BlcnR5IGlzIG51bGxcbiAgICBkZXNjLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gaW4gc29tZSBvZiB3aW5kb3dzJ3Mgb25wcm9wZXJ0eSBjYWxsYmFjaywgdGhpcyBpcyB1bmRlZmluZWRcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byBjaGVjayBpdFxuICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgaWYgKCF0YXJnZXQgJiYgb2JqID09PSBfZ2xvYmFsKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBfZ2xvYmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IHRhcmdldFtldmVudE5hbWVTeW1ib2xdO1xuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcmlnaW5hbERlc2NHZXQpIHtcbiAgICAgICAgICAgIC8vIHJlc3VsdCB3aWxsIGJlIG51bGwgd2hlbiB1c2UgaW5saW5lIGV2ZW50IGF0dHJpYnV0ZSxcbiAgICAgICAgICAgIC8vIHN1Y2ggYXMgPGJ1dHRvbiBvbmNsaWNrPVwiZnVuYygpO1wiPk9LPC9idXR0b24+XG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBvbmNsaWNrIGZ1bmN0aW9uIGlzIGludGVybmFsIHJhdyB1bmNvbXBpbGVkIGhhbmRsZXJcbiAgICAgICAgICAgIC8vIHRoZSBvbmNsaWNrIHdpbGwgYmUgZXZhbHVhdGVkIHdoZW4gZmlyc3QgdGltZSBldmVudCB3YXMgdHJpZ2dlcmVkIG9yXG4gICAgICAgICAgICAvLyB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWQsIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL3pvbmUuanMvaXNzdWVzLzUyNVxuICAgICAgICAgICAgLy8gc28gd2Ugc2hvdWxkIHVzZSBvcmlnaW5hbCBuYXRpdmUgZ2V0IHRvIHJldHJpZXZlIHRoZSBoYW5kbGVyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBvcmlnaW5hbERlc2NHZXQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGRlc2Muc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0W1JFTU9WRV9BVFRSSUJVVEVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIE9iamVjdERlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgZGVzYyk7XG4gICAgb2JqW29uUHJvcFBhdGNoZWRTeW1ib2xdID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHBhdGNoT25Qcm9wZXJ0aWVzKG9iaiwgcHJvcGVydGllcywgcHJvdG90eXBlKSB7XG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXRjaFByb3BlcnR5KG9iaiwgJ29uJyArIHByb3BlcnRpZXNbaV0sIHByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG9uUHJvcGVydGllcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAocHJvcC5zdWJzdHIoMCwgMikgPT0gJ29uJykge1xuICAgICAgICAgICAgICAgIG9uUHJvcGVydGllcy5wdXNoKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb25Qcm9wZXJ0aWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBwYXRjaFByb3BlcnR5KG9iaiwgb25Qcm9wZXJ0aWVzW2pdLCBwcm90b3R5cGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3Qgb3JpZ2luYWxJbnN0YW5jZUtleSA9IHpvbmVTeW1ib2woJ29yaWdpbmFsSW5zdGFuY2UnKTtcbi8vIHdyYXAgc29tZSBuYXRpdmUgQVBJIG9uIGB3aW5kb3dgXG5mdW5jdGlvbiBwYXRjaENsYXNzKGNsYXNzTmFtZSkge1xuICAgIGNvbnN0IE9yaWdpbmFsQ2xhc3MgPSBfZ2xvYmFsW2NsYXNzTmFtZV07XG4gICAgaWYgKCFPcmlnaW5hbENsYXNzKVxuICAgICAgICByZXR1cm47XG4gICAgLy8ga2VlcCBvcmlnaW5hbCBjbGFzcyBpbiBnbG9iYWxcbiAgICBfZ2xvYmFsW3pvbmVTeW1ib2woY2xhc3NOYW1lKV0gPSBPcmlnaW5hbENsYXNzO1xuICAgIF9nbG9iYWxbY2xhc3NOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgYSA9IGJpbmRBcmd1bWVudHMoYXJndW1lbnRzLCBjbGFzc05hbWUpO1xuICAgICAgICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpc1tvcmlnaW5hbEluc3RhbmNlS2V5XSA9IG5ldyBPcmlnaW5hbENsYXNzKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdGhpc1tvcmlnaW5hbEluc3RhbmNlS2V5XSA9IG5ldyBPcmlnaW5hbENsYXNzKGFbMF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHRoaXNbb3JpZ2luYWxJbnN0YW5jZUtleV0gPSBuZXcgT3JpZ2luYWxDbGFzcyhhWzBdLCBhWzFdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB0aGlzW29yaWdpbmFsSW5zdGFuY2VLZXldID0gbmV3IE9yaWdpbmFsQ2xhc3MoYVswXSwgYVsxXSwgYVsyXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgdGhpc1tvcmlnaW5hbEluc3RhbmNlS2V5XSA9IG5ldyBPcmlnaW5hbENsYXNzKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZyBsaXN0IHRvbyBsb25nLicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBhdHRhY2ggb3JpZ2luYWwgZGVsZWdhdGUgdG8gcGF0Y2hlZCBmdW5jdGlvblxuICAgIGF0dGFjaE9yaWdpblRvUGF0Y2hlZChfZ2xvYmFsW2NsYXNzTmFtZV0sIE9yaWdpbmFsQ2xhc3MpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IE9yaWdpbmFsQ2xhc3MoZnVuY3Rpb24gKCkgeyB9KTtcbiAgICBsZXQgcHJvcDtcbiAgICBmb3IgKHByb3AgaW4gaW5zdGFuY2UpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTQ0NzIxXG4gICAgICAgIGlmIChjbGFzc05hbWUgPT09ICdYTUxIdHRwUmVxdWVzdCcgJiYgcHJvcCA9PT0gJ3Jlc3BvbnNlQmxvYicpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlW3Byb3BdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgX2dsb2JhbFtjbGFzc05hbWVdLnByb3RvdHlwZVtwcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbb3JpZ2luYWxJbnN0YW5jZUtleV1bcHJvcF0uYXBwbHkodGhpc1tvcmlnaW5hbEluc3RhbmNlS2V5XSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0RGVmaW5lUHJvcGVydHkoX2dsb2JhbFtjbGFzc05hbWVdLnByb3RvdHlwZSwgcHJvcCwge1xuICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbb3JpZ2luYWxJbnN0YW5jZUtleV1bcHJvcF0gPSB3cmFwV2l0aEN1cnJlbnRab25lKGZuLCBjbGFzc05hbWUgKyAnLicgKyBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIGNhbGxiYWNrIGluIHdyYXBwZWQgZnVuY3Rpb24gc28gd2UgY2FuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGl0IGluIEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyB0byByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbmF0aXZlIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2hPcmlnaW5Ub1BhdGNoZWQodGhpc1tvcmlnaW5hbEluc3RhbmNlS2V5XVtwcm9wXSwgZm4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tvcmlnaW5hbEluc3RhbmNlS2V5XVtwcm9wXSA9IGZuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW29yaWdpbmFsSW5zdGFuY2VLZXldW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0ocHJvcCkpO1xuICAgIH1cbiAgICBmb3IgKHByb3AgaW4gT3JpZ2luYWxDbGFzcykge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ3Byb3RvdHlwZScgJiYgT3JpZ2luYWxDbGFzcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgX2dsb2JhbFtjbGFzc05hbWVdW3Byb3BdID0gT3JpZ2luYWxDbGFzc1twcm9wXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTWV0aG9kKHRhcmdldCwgbmFtZSwgcGF0Y2hGbikge1xuICAgIGxldCBwcm90byA9IHRhcmdldDtcbiAgICB3aGlsZSAocHJvdG8gJiYgIXByb3RvLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHByb3RvID0gT2JqZWN0R2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgIH1cbiAgICBpZiAoIXByb3RvICYmIHRhcmdldFtuYW1lXSkge1xuICAgICAgICAvLyBzb21laG93IHdlIGRpZCBub3QgZmluZCBpdCwgYnV0IHdlIGNhbiBzZWUgaXQuIFRoaXMgaGFwcGVucyBvbiBJRSBmb3IgV2luZG93IHByb3BlcnRpZXMuXG4gICAgICAgIHByb3RvID0gdGFyZ2V0O1xuICAgIH1cbiAgICBjb25zdCBkZWxlZ2F0ZU5hbWUgPSB6b25lU3ltYm9sKG5hbWUpO1xuICAgIGxldCBkZWxlZ2F0ZSA9IG51bGw7XG4gICAgaWYgKHByb3RvICYmICghKGRlbGVnYXRlID0gcHJvdG9bZGVsZWdhdGVOYW1lXSkgfHwgIXByb3RvLmhhc093blByb3BlcnR5KGRlbGVnYXRlTmFtZSkpKSB7XG4gICAgICAgIGRlbGVnYXRlID0gcHJvdG9bZGVsZWdhdGVOYW1lXSA9IHByb3RvW25hbWVdO1xuICAgICAgICAvLyBjaGVjayB3aGV0aGVyIHByb3RvW25hbWVdIGlzIHdyaXRhYmxlXG4gICAgICAgIC8vIHNvbWUgcHJvcGVydHkgaXMgcmVhZG9ubHkgaW4gc2FmYXJpLCBzdWNoIGFzIEh0bWxDYW52YXNFbGVtZW50LnByb3RvdHlwZS50b0Jsb2JcbiAgICAgICAgY29uc3QgZGVzYyA9IHByb3RvICYmIE9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgbmFtZSk7XG4gICAgICAgIGlmIChpc1Byb3BlcnR5V3JpdGFibGUoZGVzYykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGNoRGVsZWdhdGUgPSBwYXRjaEZuKGRlbGVnYXRlLCBkZWxlZ2F0ZU5hbWUsIG5hbWUpO1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGNoRGVsZWdhdGUodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhdHRhY2hPcmlnaW5Ub1BhdGNoZWQocHJvdG9bbmFtZV0sIGRlbGVnYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVsZWdhdGU7XG59XG4vLyBUT0RPOiBASmlhTGlQYXNzaW9uLCBzdXBwb3J0IGNhbmNlbCB0YXNrIGxhdGVyIGlmIG5lY2Vzc2FyeVxuZnVuY3Rpb24gcGF0Y2hNYWNyb1Rhc2sob2JqLCBmdW5jTmFtZSwgbWV0YUNyZWF0b3IpIHtcbiAgICBsZXQgc2V0TmF0aXZlID0gbnVsbDtcbiAgICBmdW5jdGlvbiBzY2hlZHVsZVRhc2sodGFzaykge1xuICAgICAgICBjb25zdCBkYXRhID0gdGFzay5kYXRhO1xuICAgICAgICBkYXRhLmFyZ3NbZGF0YS5jYklkeF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0YXNrLmludm9rZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgICBzZXROYXRpdmUuYXBwbHkoZGF0YS50YXJnZXQsIGRhdGEuYXJncyk7XG4gICAgICAgIHJldHVybiB0YXNrO1xuICAgIH1cbiAgICBzZXROYXRpdmUgPSBwYXRjaE1ldGhvZChvYmosIGZ1bmNOYW1lLCAoZGVsZWdhdGUpID0+IGZ1bmN0aW9uIChzZWxmLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSBtZXRhQ3JlYXRvcihzZWxmLCBhcmdzKTtcbiAgICAgICAgaWYgKG1ldGEuY2JJZHggPj0gMCAmJiB0eXBlb2YgYXJnc1ttZXRhLmNiSWR4XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlTWFjcm9UYXNrV2l0aEN1cnJlbnRab25lKG1ldGEubmFtZSwgYXJnc1ttZXRhLmNiSWR4XSwgbWV0YSwgc2NoZWR1bGVUYXNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNhdXNlIGFuIGVycm9yIGJ5IGNhbGxpbmcgaXQgZGlyZWN0bHkuXG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGF0dGFjaE9yaWdpblRvUGF0Y2hlZChwYXRjaGVkLCBvcmlnaW5hbCkge1xuICAgIHBhdGNoZWRbem9uZVN5bWJvbCgnT3JpZ2luYWxEZWxlZ2F0ZScpXSA9IG9yaWdpbmFsO1xufVxubGV0IGlzRGV0ZWN0ZWRJRU9yRWRnZSA9IGZhbHNlO1xubGV0IGllT3JFZGdlID0gZmFsc2U7XG5mdW5jdGlvbiBpc0lFKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVhID0gaW50ZXJuYWxXaW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAgICAgaWYgKHVhLmluZGV4T2YoJ01TSUUgJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ1RyaWRlbnQvJykgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNJRU9yRWRnZSgpIHtcbiAgICBpZiAoaXNEZXRlY3RlZElFT3JFZGdlKSB7XG4gICAgICAgIHJldHVybiBpZU9yRWRnZTtcbiAgICB9XG4gICAgaXNEZXRlY3RlZElFT3JFZGdlID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB1YSA9IGludGVybmFsV2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgICAgIGlmICh1YS5pbmRleE9mKCdNU0lFICcpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdUcmlkZW50LycpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdFZGdlLycpICE9PSAtMSkge1xuICAgICAgICAgICAgaWVPckVkZ2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgIH1cbiAgICByZXR1cm4gaWVPckVkZ2U7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuWm9uZS5fX2xvYWRfcGF0Y2goJ1pvbmVBd2FyZVByb21pc2UnLCAoZ2xvYmFsLCBab25lLCBhcGkpID0+IHtcbiAgICBjb25zdCBPYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgIGNvbnN0IE9iamVjdERlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICAgIGZ1bmN0aW9uIHJlYWRhYmxlT2JqZWN0VG9TdHJpbmcob2JqKSB7XG4gICAgICAgIGlmIChvYmogJiYgb2JqLnRvU3RyaW5nID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gKGNsYXNzTmFtZSA/IGNsYXNzTmFtZSA6ICcnKSArICc6ICcgKyBKU09OLnN0cmluZ2lmeShvYmopO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmogPyBvYmoudG9TdHJpbmcoKSA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuICAgIH1cbiAgICBjb25zdCBfX3N5bWJvbF9fID0gYXBpLnN5bWJvbDtcbiAgICBjb25zdCBfdW5jYXVnaHRQcm9taXNlRXJyb3JzID0gW107XG4gICAgY29uc3QgaXNEaXNhYmxlV3JhcHBpbmdVbmNhdWdodFByb21pc2VSZWplY3Rpb24gPSBnbG9iYWxbX19zeW1ib2xfXygnRElTQUJMRV9XUkFQUElOR19VTkNBVUdIVF9QUk9NSVNFX1JFSkVDVElPTicpXSA9PT0gdHJ1ZTtcbiAgICBjb25zdCBzeW1ib2xQcm9taXNlID0gX19zeW1ib2xfXygnUHJvbWlzZScpO1xuICAgIGNvbnN0IHN5bWJvbFRoZW4gPSBfX3N5bWJvbF9fKCd0aGVuJyk7XG4gICAgY29uc3QgY3JlYXRpb25UcmFjZSA9ICdfX2NyZWF0aW9uVHJhY2VfXyc7XG4gICAgYXBpLm9uVW5oYW5kbGVkRXJyb3IgPSAoZSkgPT4ge1xuICAgICAgICBpZiAoYXBpLnNob3dVbmNhdWdodEVycm9yKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlamVjdGlvbiA9IGUgJiYgZS5yZWplY3Rpb247XG4gICAgICAgICAgICBpZiAocmVqZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIFByb21pc2UgcmVqZWN0aW9uOicsIHJlamVjdGlvbiBpbnN0YW5jZW9mIEVycm9yID8gcmVqZWN0aW9uLm1lc3NhZ2UgOiByZWplY3Rpb24sICc7IFpvbmU6JywgZS56b25lLm5hbWUsICc7IFRhc2s6JywgZS50YXNrICYmIGUudGFzay5zb3VyY2UsICc7IFZhbHVlOicsIHJlamVjdGlvbiwgcmVqZWN0aW9uIGluc3RhbmNlb2YgRXJyb3IgPyByZWplY3Rpb24uc3RhY2sgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgYXBpLm1pY3JvdGFza0RyYWluRG9uZSA9ICgpID0+IHtcbiAgICAgICAgd2hpbGUgKF91bmNhdWdodFByb21pc2VFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB1bmNhdWdodFByb21pc2VFcnJvciA9IF91bmNhdWdodFByb21pc2VFcnJvcnMuc2hpZnQoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdW5jYXVnaHRQcm9taXNlRXJyb3Iuem9uZS5ydW5HdWFyZGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVuY2F1Z2h0UHJvbWlzZUVycm9yLnRocm93T3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHVuY2F1Z2h0UHJvbWlzZUVycm9yLnJlamVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyB1bmNhdWdodFByb21pc2VFcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZVVuaGFuZGxlZFJlamVjdGlvbihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IFVOSEFORExFRF9QUk9NSVNFX1JFSkVDVElPTl9IQU5ETEVSX1NZTUJPTCA9IF9fc3ltYm9sX18oJ3VuaGFuZGxlZFByb21pc2VSZWplY3Rpb25IYW5kbGVyJyk7XG4gICAgZnVuY3Rpb24gaGFuZGxlVW5oYW5kbGVkUmVqZWN0aW9uKGUpIHtcbiAgICAgICAgYXBpLm9uVW5oYW5kbGVkRXJyb3IoZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gWm9uZVtVTkhBTkRMRURfUFJPTUlTRV9SRUpFQ1RJT05fSEFORExFUl9TWU1CT0xdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc1RoZW5hYmxlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS50aGVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3J3YXJkUmVzb2x1dGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcndhcmRSZWplY3Rpb24ocmVqZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBab25lQXdhcmVQcm9taXNlLnJlamVjdChyZWplY3Rpb24pO1xuICAgIH1cbiAgICBjb25zdCBzeW1ib2xTdGF0ZSA9IF9fc3ltYm9sX18oJ3N0YXRlJyk7XG4gICAgY29uc3Qgc3ltYm9sVmFsdWUgPSBfX3N5bWJvbF9fKCd2YWx1ZScpO1xuICAgIGNvbnN0IHN5bWJvbEZpbmFsbHkgPSBfX3N5bWJvbF9fKCdmaW5hbGx5Jyk7XG4gICAgY29uc3Qgc3ltYm9sUGFyZW50UHJvbWlzZVZhbHVlID0gX19zeW1ib2xfXygncGFyZW50UHJvbWlzZVZhbHVlJyk7XG4gICAgY29uc3Qgc3ltYm9sUGFyZW50UHJvbWlzZVN0YXRlID0gX19zeW1ib2xfXygncGFyZW50UHJvbWlzZVN0YXRlJyk7XG4gICAgY29uc3Qgc291cmNlID0gJ1Byb21pc2UudGhlbic7XG4gICAgY29uc3QgVU5SRVNPTFZFRCA9IG51bGw7XG4gICAgY29uc3QgUkVTT0xWRUQgPSB0cnVlO1xuICAgIGNvbnN0IFJFSkVDVEVEID0gZmFsc2U7XG4gICAgY29uc3QgUkVKRUNURURfTk9fQ0FUQ0ggPSAwO1xuICAgIGZ1bmN0aW9uIG1ha2VSZXNvbHZlcihwcm9taXNlLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gKHYpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UocHJvbWlzZSwgc3RhdGUsIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlKHByb21pc2UsIGZhbHNlLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG8gbm90IHJldHVybiB2YWx1ZSBvciB5b3Ugd2lsbCBicmVhayB0aGUgUHJvbWlzZSBzcGVjLlxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBvbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgd2FzQ2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB3cmFwcGVyKHdyYXBwZWRGdW5jdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAod2FzQ2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2FzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3cmFwcGVkRnVuY3Rpb24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBUWVBFX0VSUk9SID0gJ1Byb21pc2UgcmVzb2x2ZWQgd2l0aCBpdHNlbGYnO1xuICAgIGNvbnN0IENVUlJFTlRfVEFTS19UUkFDRV9TWU1CT0wgPSBfX3N5bWJvbF9fKCdjdXJyZW50VGFza1RyYWNlJyk7XG4gICAgLy8gUHJvbWlzZSBSZXNvbHV0aW9uXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UocHJvbWlzZSwgc3RhdGUsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG9uY2VXcmFwcGVyID0gb25jZSgpO1xuICAgICAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoVFlQRV9FUlJPUik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21pc2Vbc3ltYm9sU3RhdGVdID09PSBVTlJFU09MVkVEKSB7XG4gICAgICAgICAgICAvLyBzaG91bGQgb25seSBnZXQgdmFsdWUudGhlbiBvbmNlIGJhc2VkIG9uIHByb21pc2Ugc3BlYy5cbiAgICAgICAgICAgIGxldCB0aGVuID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoZW4gPSB2YWx1ZSAmJiB2YWx1ZS50aGVuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBvbmNlV3JhcHBlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlKHByb21pc2UsIGZhbHNlLCBlcnIpO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiAodmFsdWUgaW5zdGFuY2VvZiBab25lQXdhcmVQcm9taXNlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUgIT09IFJFSkVDVEVEICYmIHZhbHVlIGluc3RhbmNlb2YgWm9uZUF3YXJlUHJvbWlzZSAmJlxuICAgICAgICAgICAgICAgIHZhbHVlLmhhc093blByb3BlcnR5KHN5bWJvbFN0YXRlKSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eShzeW1ib2xWYWx1ZSkgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZVtzeW1ib2xTdGF0ZV0gIT09IFVOUkVTT0xWRUQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclJlamVjdGVkTm9DYXRjaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UocHJvbWlzZSwgdmFsdWVbc3ltYm9sU3RhdGVdLCB2YWx1ZVtzeW1ib2xWYWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUgIT09IFJFSkVDVEVEICYmIHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBvbmNlV3JhcHBlcihtYWtlUmVzb2x2ZXIocHJvbWlzZSwgc3RhdGUpKSwgb25jZVdyYXBwZXIobWFrZVJlc29sdmVyKHByb21pc2UsIGZhbHNlKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uY2VXcmFwcGVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlKHByb21pc2UsIGZhbHNlLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2Vbc3ltYm9sU3RhdGVdID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVldWUgPSBwcm9taXNlW3N5bWJvbFZhbHVlXTtcbiAgICAgICAgICAgICAgICBwcm9taXNlW3N5bWJvbFZhbHVlXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlW3N5bWJvbEZpbmFsbHldID09PSBzeW1ib2xGaW5hbGx5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwcm9taXNlIGlzIGdlbmVyYXRlZCBieSBQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gUkVTT0xWRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzdGF0ZSBpcyByZXNvbHZlZCwgc2hvdWxkIGlnbm9yZSB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB1c2UgcGFyZW50IHByb21pc2UgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2Vbc3ltYm9sU3RhdGVdID0gcHJvbWlzZVtzeW1ib2xQYXJlbnRQcm9taXNlU3RhdGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVtzeW1ib2xWYWx1ZV0gPSBwcm9taXNlW3N5bWJvbFBhcmVudFByb21pc2VWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVjb3JkIHRhc2sgaW5mb3JtYXRpb24gaW4gdmFsdWUgd2hlbiBlcnJvciBvY2N1cnMsIHNvIHdlIGNhblxuICAgICAgICAgICAgICAgIC8vIGRvIHNvbWUgYWRkaXRpb25hbCB3b3JrIHN1Y2ggYXMgcmVuZGVyIGxvbmdTdGFja1RyYWNlXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSBSRUpFQ1RFRCAmJiB2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGxvbmdTdGFja1RyYWNlWm9uZSBpcyBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNlID0gWm9uZS5jdXJyZW50VGFzayAmJiBab25lLmN1cnJlbnRUYXNrLmRhdGEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIFpvbmUuY3VycmVudFRhc2suZGF0YVtjcmVhdGlvblRyYWNlXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGtlZXAgdGhlIGxvbmcgc3RhY2sgdHJhY2UgaW50byBlcnJvciB3aGVuIGluIGxvbmdTdGFja1RyYWNlWm9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0RGVmaW5lUHJvcGVydHkodmFsdWUsIENVUlJFTlRfVEFTS19UUkFDRV9TWU1CT0wsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0cmFjZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVSZXNvbHZlT3JSZWplY3QocHJvbWlzZSwgcXVldWVbaSsrXSwgcXVldWVbaSsrXSwgcXVldWVbaSsrXSwgcXVldWVbaSsrXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPT0gMCAmJiBzdGF0ZSA9PSBSRUpFQ1RFRCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlW3N5bWJvbFN0YXRlXSA9IFJFSkVDVEVEX05PX0NBVENIO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdW5jYXVnaHRQcm9taXNlRXJyb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhlcmUgd2UgdGhyb3dzIGEgbmV3IEVycm9yIHRvIHByaW50IG1vcmUgcmVhZGFibGUgZXJyb3IgbG9nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgaWYgdGhlIHZhbHVlIGlzIG5vdCBhbiBlcnJvciwgem9uZS5qcyBidWlsZHMgYW4gYEVycm9yYFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2JqZWN0IGhlcmUgdG8gYXR0YWNoIHRoZSBzdGFjayBpbmZvcm1hdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5jYXVnaHQgKGluIHByb21pc2UpOiAnICsgcmVhZGFibGVPYmplY3RUb1N0cmluZyh2YWx1ZSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh2YWx1ZSAmJiB2YWx1ZS5zdGFjayA/ICdcXG4nICsgdmFsdWUuc3RhY2sgOiAnJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuY2F1Z2h0UHJvbWlzZUVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Rpc2FibGVXcmFwcGluZ1VuY2F1Z2h0UHJvbWlzZVJlamVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGlzYWJsZSB3cmFwcGluZyB1bmNhdWdodCBwcm9taXNlIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHRoZSB2YWx1ZSBpbnN0ZWFkIG9mIHdyYXBwaW5nIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgdW5jYXVnaHRQcm9taXNlRXJyb3IudGhyb3dPcmlnaW5hbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdW5jYXVnaHRQcm9taXNlRXJyb3IucmVqZWN0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHVuY2F1Z2h0UHJvbWlzZUVycm9yLnByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICB1bmNhdWdodFByb21pc2VFcnJvci56b25lID0gWm9uZS5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICB1bmNhdWdodFByb21pc2VFcnJvci50YXNrID0gWm9uZS5jdXJyZW50VGFzaztcbiAgICAgICAgICAgICAgICAgICAgX3VuY2F1Z2h0UHJvbWlzZUVycm9ycy5wdXNoKHVuY2F1Z2h0UHJvbWlzZUVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgYXBpLnNjaGVkdWxlTWljcm9UYXNrKCk7IC8vIHRvIG1ha2Ugc3VyZSB0aGF0IGl0IGlzIHJ1bm5pbmdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzb2x2aW5nIGFuIGFscmVhZHkgcmVzb2x2ZWQgcHJvbWlzZSBpcyBhIG5vb3AuXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBSRUpFQ1RJT05fSEFORExFRF9IQU5ETEVSID0gX19zeW1ib2xfXygncmVqZWN0aW9uSGFuZGxlZEhhbmRsZXInKTtcbiAgICBmdW5jdGlvbiBjbGVhclJlamVjdGVkTm9DYXRjaChwcm9taXNlKSB7XG4gICAgICAgIGlmIChwcm9taXNlW3N5bWJvbFN0YXRlXSA9PT0gUkVKRUNURURfTk9fQ0FUQ0gpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIG5vIGNhdGNoIHN0YXR1c1xuICAgICAgICAgICAgLy8gYW5kIHF1ZXVlLmxlbmd0aCA+IDAsIG1lYW5zIHRoZXJlIGlzIGEgZXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgLy8gaGVyZSB0byBoYW5kbGUgdGhlIHJlamVjdGVkIHByb21pc2UsIHdlIHNob3VsZCB0cmlnZ2VyXG4gICAgICAgICAgICAvLyB3aW5kb3dzLnJlamVjdGlvbmhhbmRsZWQgZXZlbnRIYW5kbGVyIG9yIG5vZGVqcyByZWplY3Rpb25IYW5kbGVkXG4gICAgICAgICAgICAvLyBldmVudEhhbmRsZXJcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IFpvbmVbUkVKRUNUSU9OX0hBTkRMRURfSEFORExFUl07XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgJiYgdHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIHsgcmVqZWN0aW9uOiBwcm9taXNlW3N5bWJvbFZhbHVlXSwgcHJvbWlzZTogcHJvbWlzZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9taXNlW3N5bWJvbFN0YXRlXSA9IFJFSkVDVEVEO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfdW5jYXVnaHRQcm9taXNlRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb21pc2UgPT09IF91bmNhdWdodFByb21pc2VFcnJvcnNbaV0ucHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICBfdW5jYXVnaHRQcm9taXNlRXJyb3JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVSZXNvbHZlT3JSZWplY3QocHJvbWlzZSwgem9uZSwgY2hhaW5Qcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICBjbGVhclJlamVjdGVkTm9DYXRjaChwcm9taXNlKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZVN0YXRlID0gcHJvbWlzZVtzeW1ib2xTdGF0ZV07XG4gICAgICAgIGNvbnN0IGRlbGVnYXRlID0gcHJvbWlzZVN0YXRlID9cbiAgICAgICAgICAgICh0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicpID8gb25GdWxmaWxsZWQgOiBmb3J3YXJkUmVzb2x1dGlvbiA6XG4gICAgICAgICAgICAodHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicpID8gb25SZWplY3RlZCA6XG4gICAgICAgICAgICAgICAgZm9yd2FyZFJlamVjdGlvbjtcbiAgICAgICAgem9uZS5zY2hlZHVsZU1pY3JvVGFzayhzb3VyY2UsICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50UHJvbWlzZVZhbHVlID0gcHJvbWlzZVtzeW1ib2xWYWx1ZV07XG4gICAgICAgICAgICAgICAgY29uc3QgaXNGaW5hbGx5UHJvbWlzZSA9ICEhY2hhaW5Qcm9taXNlICYmIHN5bWJvbEZpbmFsbHkgPT09IGNoYWluUHJvbWlzZVtzeW1ib2xGaW5hbGx5XTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGaW5hbGx5UHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcHJvbWlzZSBpcyBnZW5lcmF0ZWQgZnJvbSBmaW5hbGx5IGNhbGwsIGtlZXAgcGFyZW50IHByb21pc2UncyBzdGF0ZSBhbmQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5Qcm9taXNlW3N5bWJvbFBhcmVudFByb21pc2VWYWx1ZV0gPSBwYXJlbnRQcm9taXNlVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluUHJvbWlzZVtzeW1ib2xQYXJlbnRQcm9taXNlU3RhdGVdID0gcHJvbWlzZVN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgbm90IHBhc3MgdmFsdWUgdG8gZmluYWxseSBjYWxsYmFja1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gem9uZS5ydW4oZGVsZWdhdGUsIHVuZGVmaW5lZCwgaXNGaW5hbGx5UHJvbWlzZSAmJiBkZWxlZ2F0ZSAhPT0gZm9yd2FyZFJlamVjdGlvbiAmJiBkZWxlZ2F0ZSAhPT0gZm9yd2FyZFJlc29sdXRpb24gP1xuICAgICAgICAgICAgICAgICAgICBbXSA6XG4gICAgICAgICAgICAgICAgICAgIFtwYXJlbnRQcm9taXNlVmFsdWVdKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZShjaGFpblByb21pc2UsIHRydWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIGlmIGVycm9yIG9jY3Vycywgc2hvdWxkIGFsd2F5cyByZXR1cm4gdGhpcyBlcnJvclxuICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlKGNoYWluUHJvbWlzZSwgZmFsc2UsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgY2hhaW5Qcm9taXNlKTtcbiAgICB9XG4gICAgY29uc3QgWk9ORV9BV0FSRV9QUk9NSVNFX1RPX1NUUklORyA9ICdmdW5jdGlvbiBab25lQXdhcmVQcm9taXNlKCkgeyBbbmF0aXZlIGNvZGVdIH0nO1xuICAgIGNvbnN0IG5vb3AgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgY29uc3QgQWdncmVnYXRlRXJyb3IgPSBnbG9iYWwuQWdncmVnYXRlRXJyb3I7XG4gICAgY2xhc3MgWm9uZUF3YXJlUHJvbWlzZSB7XG4gICAgICAgIHN0YXRpYyB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiBaT05FX0FXQVJFX1BST01JU0VfVE9fU1RSSU5HO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyByZXNvbHZlKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZVByb21pc2UobmV3IHRoaXMobnVsbCksIFJFU09MVkVELCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHJlamVjdChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVQcm9taXNlKG5ldyB0aGlzKG51bGwpLCBSRUpFQ1RFRCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBhbnkodmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlcyB8fCB0eXBlb2YgdmFsdWVzW1N5bWJvbC5pdGVyYXRvcl0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEFnZ3JlZ2F0ZUVycm9yKFtdLCAnQWxsIHByb21pc2VzIHdlcmUgcmVqZWN0ZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdiBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChab25lQXdhcmVQcm9taXNlLnJlc29sdmUodikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEFnZ3JlZ2F0ZUVycm9yKFtdLCAnQWxsIHByb21pc2VzIHdlcmUgcmVqZWN0ZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEFnZ3JlZ2F0ZUVycm9yKFtdLCAnQWxsIHByb21pc2VzIHdlcmUgcmVqZWN0ZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBab25lQXdhcmVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb21pc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzW2ldLnRoZW4odiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHYpO1xuICAgICAgICAgICAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBBZ2dyZWdhdGVFcnJvcihlcnJvcnMsICdBbGwgcHJvbWlzZXMgd2VyZSByZWplY3RlZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBzdGF0aWMgcmFjZSh2YWx1ZXMpIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlO1xuICAgICAgICAgICAgbGV0IHJlamVjdDtcbiAgICAgICAgICAgIGxldCBwcm9taXNlID0gbmV3IHRoaXMoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgICAgICByZWplY3QgPSByZWo7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uUmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gb25SZWplY3QoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1RoZW5hYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ob25SZXNvbHZlLCBvblJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgYWxsKHZhbHVlcykge1xuICAgICAgICAgICAgcmV0dXJuIFpvbmVBd2FyZVByb21pc2UuYWxsV2l0aENhbGxiYWNrKHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGFsbFNldHRsZWQodmFsdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBQID0gdGhpcyAmJiB0aGlzLnByb3RvdHlwZSBpbnN0YW5jZW9mIFpvbmVBd2FyZVByb21pc2UgPyB0aGlzIDogWm9uZUF3YXJlUHJvbWlzZTtcbiAgICAgICAgICAgIHJldHVybiBQLmFsbFdpdGhDYWxsYmFjayh2YWx1ZXMsIHtcbiAgICAgICAgICAgICAgICB0aGVuQ2FsbGJhY2s6ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiAnZnVsZmlsbGVkJywgdmFsdWUgfSksXG4gICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjazogKGVycikgPT4gKHsgc3RhdHVzOiAncmVqZWN0ZWQnLCByZWFzb246IGVyciB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGFsbFdpdGhDYWxsYmFjayh2YWx1ZXMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZTtcbiAgICAgICAgICAgIGxldCByZWplY3Q7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IG5ldyB0aGlzKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUgPSByZXM7XG4gICAgICAgICAgICAgICAgcmVqZWN0ID0gcmVqO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBTdGFydCBhdCAyIHRvIHByZXZlbnQgcHJlbWF0dXJlbHkgcmVzb2x2aW5nIGlmIC50aGVuIGlzIGNhbGxlZCBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgIGxldCB1bnJlc29sdmVkQ291bnQgPSAyO1xuICAgICAgICAgICAgbGV0IHZhbHVlSW5kZXggPSAwO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgIGlmICghaXNUaGVuYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjdXJWYWx1ZUluZGV4ID0gdmFsdWVJbmRleDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRWYWx1ZXNbY3VyVmFsdWVJbmRleF0gPSBjYWxsYmFjayA/IGNhbGxiYWNrLnRoZW5DYWxsYmFjayh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVucmVzb2x2ZWRDb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVucmVzb2x2ZWRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzb2x2ZWRWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFZhbHVlc1tjdXJWYWx1ZUluZGV4XSA9IGNhbGxiYWNrLmVycm9yQ2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnJlc29sdmVkQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5yZXNvbHZlZENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzb2x2ZWRWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoICh0aGVuRXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh0aGVuRXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5yZXNvbHZlZENvdW50Kys7XG4gICAgICAgICAgICAgICAgdmFsdWVJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSB0aGUgdW5yZXNvbHZlZENvdW50IHplcm8tYmFzZWQgYWdhaW4uXG4gICAgICAgICAgICB1bnJlc29sdmVkQ291bnQgLT0gMjtcbiAgICAgICAgICAgIGlmICh1bnJlc29sdmVkQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc29sdmVkVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0cnVjdG9yKGV4ZWN1dG9yKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcztcbiAgICAgICAgICAgIGlmICghKHByb21pc2UgaW5zdGFuY2VvZiBab25lQXdhcmVQcm9taXNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBiZSBhbiBpbnN0YW5jZW9mIFByb21pc2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9taXNlW3N5bWJvbFN0YXRlXSA9IFVOUkVTT0xWRUQ7XG4gICAgICAgICAgICBwcm9taXNlW3N5bWJvbFZhbHVlXSA9IFtdOyAvLyBxdWV1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZXhlY3V0b3IgJiYgZXhlY3V0b3IobWFrZVJlc29sdmVyKHByb21pc2UsIFJFU09MVkVEKSwgbWFrZVJlc29sdmVyKHByb21pc2UsIFJFSkVDVEVEKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZShwcm9taXNlLCBmYWxzZSwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICAgICAgICAgIHJldHVybiAnUHJvbWlzZSc7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IFtTeW1ib2wuc3BlY2llc10oKSB7XG4gICAgICAgICAgICByZXR1cm4gWm9uZUF3YXJlUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgICAgICBsZXQgQyA9IHRoaXMuY29uc3RydWN0b3JbU3ltYm9sLnNwZWNpZXNdO1xuICAgICAgICAgICAgaWYgKCFDIHx8IHR5cGVvZiBDICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgQyA9IHRoaXMuY29uc3RydWN0b3IgfHwgWm9uZUF3YXJlUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNoYWluUHJvbWlzZSA9IG5ldyBDKG5vb3ApO1xuICAgICAgICAgICAgY29uc3Qgem9uZSA9IFpvbmUuY3VycmVudDtcbiAgICAgICAgICAgIGlmICh0aGlzW3N5bWJvbFN0YXRlXSA9PSBVTlJFU09MVkVEKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tzeW1ib2xWYWx1ZV0ucHVzaCh6b25lLCBjaGFpblByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlUmVzb2x2ZU9yUmVqZWN0KHRoaXMsIHpvbmUsIGNoYWluUHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNoYWluUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChvblJlamVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkob25GaW5hbGx5KSB7XG4gICAgICAgICAgICBsZXQgQyA9IHRoaXMuY29uc3RydWN0b3JbU3ltYm9sLnNwZWNpZXNdO1xuICAgICAgICAgICAgaWYgKCFDIHx8IHR5cGVvZiBDICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgQyA9IFpvbmVBd2FyZVByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaGFpblByb21pc2UgPSBuZXcgQyhub29wKTtcbiAgICAgICAgICAgIGNoYWluUHJvbWlzZVtzeW1ib2xGaW5hbGx5XSA9IHN5bWJvbEZpbmFsbHk7XG4gICAgICAgICAgICBjb25zdCB6b25lID0gWm9uZS5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKHRoaXNbc3ltYm9sU3RhdGVdID09IFVOUkVTT0xWRUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3N5bWJvbFZhbHVlXS5wdXNoKHpvbmUsIGNoYWluUHJvbWlzZSwgb25GaW5hbGx5LCBvbkZpbmFsbHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVSZXNvbHZlT3JSZWplY3QodGhpcywgem9uZSwgY2hhaW5Qcm9taXNlLCBvbkZpbmFsbHksIG9uRmluYWxseSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hhaW5Qcm9taXNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFByb3RlY3QgYWdhaW5zdCBhZ2dyZXNzaXZlIG9wdGltaXplcnMgZHJvcHBpbmcgc2VlbWluZ2x5IHVudXNlZCBwcm9wZXJ0aWVzLlxuICAgIC8vIEUuZy4gQ2xvc3VyZSBDb21waWxlciBpbiBhZHZhbmNlZCBtb2RlLlxuICAgIFpvbmVBd2FyZVByb21pc2VbJ3Jlc29sdmUnXSA9IFpvbmVBd2FyZVByb21pc2UucmVzb2x2ZTtcbiAgICBab25lQXdhcmVQcm9taXNlWydyZWplY3QnXSA9IFpvbmVBd2FyZVByb21pc2UucmVqZWN0O1xuICAgIFpvbmVBd2FyZVByb21pc2VbJ3JhY2UnXSA9IFpvbmVBd2FyZVByb21pc2UucmFjZTtcbiAgICBab25lQXdhcmVQcm9taXNlWydhbGwnXSA9IFpvbmVBd2FyZVByb21pc2UuYWxsO1xuICAgIGNvbnN0IE5hdGl2ZVByb21pc2UgPSBnbG9iYWxbc3ltYm9sUHJvbWlzZV0gPSBnbG9iYWxbJ1Byb21pc2UnXTtcbiAgICBnbG9iYWxbJ1Byb21pc2UnXSA9IFpvbmVBd2FyZVByb21pc2U7XG4gICAgY29uc3Qgc3ltYm9sVGhlblBhdGNoZWQgPSBfX3N5bWJvbF9fKCd0aGVuUGF0Y2hlZCcpO1xuICAgIGZ1bmN0aW9uIHBhdGNoVGhlbihDdG9yKSB7XG4gICAgICAgIGNvbnN0IHByb3RvID0gQ3Rvci5wcm90b3R5cGU7XG4gICAgICAgIGNvbnN0IHByb3AgPSBPYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sICd0aGVuJyk7XG4gICAgICAgIGlmIChwcm9wICYmIChwcm9wLndyaXRhYmxlID09PSBmYWxzZSB8fCAhcHJvcC5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBDdG9yLnByb3RvdHlwZS50aGVuIHByb3BlcnR5RGVzY3JpcHRvciBpcyB3cml0YWJsZSBvciBub3RcbiAgICAgICAgICAgIC8vIGluIG1ldGVvciBlbnYsIHdyaXRhYmxlIGlzIGZhbHNlLCB3ZSBzaG91bGQgaWdub3JlIHN1Y2ggY2FzZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsVGhlbiA9IHByb3RvLnRoZW47XG4gICAgICAgIC8vIEtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIG1ldGhvZC5cbiAgICAgICAgcHJvdG9bc3ltYm9sVGhlbl0gPSBvcmlnaW5hbFRoZW47XG4gICAgICAgIEN0b3IucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25SZXNvbHZlLCBvblJlamVjdCkge1xuICAgICAgICAgICAgY29uc3Qgd3JhcHBlZCA9IG5ldyBab25lQXdhcmVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFRoZW4uY2FsbCh0aGlzLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlZC50aGVuKG9uUmVzb2x2ZSwgb25SZWplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBDdG9yW3N5bWJvbFRoZW5QYXRjaGVkXSA9IHRydWU7XG4gICAgfVxuICAgIGFwaS5wYXRjaFRoZW4gPSBwYXRjaFRoZW47XG4gICAgZnVuY3Rpb24gem9uZWlmeShmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGYsIGFyZ3MpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHRQcm9taXNlID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0UHJvbWlzZSBpbnN0YW5jZW9mIFpvbmVBd2FyZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0UHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjdG9yID0gcmVzdWx0UHJvbWlzZS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGlmICghY3RvcltzeW1ib2xUaGVuUGF0Y2hlZF0pIHtcbiAgICAgICAgICAgICAgICBwYXRjaFRoZW4oY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0UHJvbWlzZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKE5hdGl2ZVByb21pc2UpIHtcbiAgICAgICAgcGF0Y2hUaGVuKE5hdGl2ZVByb21pc2UpO1xuICAgICAgICBwYXRjaE1ldGhvZChnbG9iYWwsICdmZXRjaCcsIGRlbGVnYXRlID0+IHpvbmVpZnkoZGVsZWdhdGUpKTtcbiAgICB9XG4gICAgLy8gVGhpcyBpcyBub3QgcGFydCBvZiBwdWJsaWMgQVBJLCBidXQgaXQgaXMgdXNlZnVsIGZvciB0ZXN0cywgc28gd2UgZXhwb3NlIGl0LlxuICAgIFByb21pc2VbWm9uZS5fX3N5bWJvbF9fKCd1bmNhdWdodFByb21pc2VFcnJvcnMnKV0gPSBfdW5jYXVnaHRQcm9taXNlRXJyb3JzO1xuICAgIHJldHVybiBab25lQXdhcmVQcm9taXNlO1xufSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gb3ZlcnJpZGUgRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nIHRvIG1ha2Ugem9uZS5qcyBwYXRjaGVkIGZ1bmN0aW9uXG4vLyBsb29rIGxpa2UgbmF0aXZlIGZ1bmN0aW9uXG5ab25lLl9fbG9hZF9wYXRjaCgndG9TdHJpbmcnLCAoZ2xvYmFsKSA9PiB7XG4gICAgLy8gcGF0Y2ggRnVuYy5wcm90b3R5cGUudG9TdHJpbmcgdG8gbGV0IHRoZW0gbG9vayBsaWtlIG5hdGl2ZVxuICAgIGNvbnN0IG9yaWdpbmFsRnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbiAgICBjb25zdCBPUklHSU5BTF9ERUxFR0FURV9TWU1CT0wgPSB6b25lU3ltYm9sKCdPcmlnaW5hbERlbGVnYXRlJyk7XG4gICAgY29uc3QgUFJPTUlTRV9TWU1CT0wgPSB6b25lU3ltYm9sKCdQcm9taXNlJyk7XG4gICAgY29uc3QgRVJST1JfU1lNQk9MID0gem9uZVN5bWJvbCgnRXJyb3InKTtcbiAgICBjb25zdCBuZXdGdW5jdGlvblRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxEZWxlZ2F0ZSA9IHRoaXNbT1JJR0lOQUxfREVMRUdBVEVfU1lNQk9MXTtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbERlbGVnYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbERlbGVnYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEZ1bmN0aW9uVG9TdHJpbmcuY2FsbChvcmlnaW5hbERlbGVnYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob3JpZ2luYWxEZWxlZ2F0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMgPT09IFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYXRpdmVQcm9taXNlID0gZ2xvYmFsW1BST01JU0VfU1lNQk9MXTtcbiAgICAgICAgICAgICAgICBpZiAobmF0aXZlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxGdW5jdGlvblRvU3RyaW5nLmNhbGwobmF0aXZlUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMgPT09IEVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmF0aXZlRXJyb3IgPSBnbG9iYWxbRVJST1JfU1lNQk9MXTtcbiAgICAgICAgICAgICAgICBpZiAobmF0aXZlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsRnVuY3Rpb25Ub1N0cmluZy5jYWxsKG5hdGl2ZUVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsRnVuY3Rpb25Ub1N0cmluZy5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgbmV3RnVuY3Rpb25Ub1N0cmluZ1tPUklHSU5BTF9ERUxFR0FURV9TWU1CT0xdID0gb3JpZ2luYWxGdW5jdGlvblRvU3RyaW5nO1xuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IG5ld0Z1bmN0aW9uVG9TdHJpbmc7XG4gICAgLy8gcGF0Y2ggT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyB0byBsZXQgdGhlbSBsb29rIGxpa2UgbmF0aXZlXG4gICAgY29uc3Qgb3JpZ2luYWxPYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgY29uc3QgUFJPTUlTRV9PQkpFQ1RfVE9fU1RSSU5HID0gJ1tvYmplY3QgUHJvbWlzZV0nO1xuICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIFBST01JU0VfT0JKRUNUX1RPX1NUUklORztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ2luYWxPYmplY3RUb1N0cmluZy5jYWxsKHRoaXMpO1xuICAgIH07XG59KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5sZXQgcGFzc2l2ZVN1cHBvcnRlZCA9IGZhbHNlO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwYXNzaXZlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5vdGU6IFdlIHBhc3MgdGhlIGBvcHRpb25zYCBvYmplY3QgYXMgdGhlIGV2ZW50IGhhbmRsZXIgdG9vLiBUaGlzIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlXG4gICAgICAgIC8vIHNpZ25hdHVyZSBvZiBgYWRkRXZlbnRMaXN0ZW5lcmAgb3IgYHJlbW92ZUV2ZW50TGlzdGVuZXJgIGJ1dCBlbmFibGVzIHVzIHRvIHJlbW92ZSB0aGUgaGFuZGxlclxuICAgICAgICAvLyB3aXRob3V0IGFuIGFjdHVhbCBoYW5kbGVyLlxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG59XG4vLyBhbiBpZGVudGlmaWVyIHRvIHRlbGwgWm9uZVRhc2sgZG8gbm90IGNyZWF0ZSBhIG5ldyBpbnZva2UgY2xvc3VyZVxuY29uc3QgT1BUSU1JWkVEX1pPTkVfRVZFTlRfVEFTS19EQVRBID0ge1xuICAgIHVzZUc6IHRydWVcbn07XG5jb25zdCB6b25lU3ltYm9sRXZlbnROYW1lcyA9IHt9O1xuY29uc3QgZ2xvYmFsU291cmNlcyA9IHt9O1xuY29uc3QgRVZFTlRfTkFNRV9TWU1CT0xfUkVHWCA9IG5ldyBSZWdFeHAoJ14nICsgWk9ORV9TWU1CT0xfUFJFRklYICsgJyhcXFxcdyspKHRydWV8ZmFsc2UpJCcpO1xuY29uc3QgSU1NRURJQVRFX1BST1BBR0FUSU9OX1NZTUJPTCA9IHpvbmVTeW1ib2woJ3Byb3BhZ2F0aW9uU3RvcHBlZCcpO1xuZnVuY3Rpb24gcHJlcGFyZUV2ZW50TmFtZXMoZXZlbnROYW1lLCBldmVudE5hbWVUb1N0cmluZykge1xuICAgIGNvbnN0IGZhbHNlRXZlbnROYW1lID0gKGV2ZW50TmFtZVRvU3RyaW5nID8gZXZlbnROYW1lVG9TdHJpbmcoZXZlbnROYW1lKSA6IGV2ZW50TmFtZSkgKyBGQUxTRV9TVFI7XG4gICAgY29uc3QgdHJ1ZUV2ZW50TmFtZSA9IChldmVudE5hbWVUb1N0cmluZyA/IGV2ZW50TmFtZVRvU3RyaW5nKGV2ZW50TmFtZSkgOiBldmVudE5hbWUpICsgVFJVRV9TVFI7XG4gICAgY29uc3Qgc3ltYm9sID0gWk9ORV9TWU1CT0xfUFJFRklYICsgZmFsc2VFdmVudE5hbWU7XG4gICAgY29uc3Qgc3ltYm9sQ2FwdHVyZSA9IFpPTkVfU1lNQk9MX1BSRUZJWCArIHRydWVFdmVudE5hbWU7XG4gICAgem9uZVN5bWJvbEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHt9O1xuICAgIHpvbmVTeW1ib2xFdmVudE5hbWVzW2V2ZW50TmFtZV1bRkFMU0VfU1RSXSA9IHN5bWJvbDtcbiAgICB6b25lU3ltYm9sRXZlbnROYW1lc1tldmVudE5hbWVdW1RSVUVfU1RSXSA9IHN5bWJvbENhcHR1cmU7XG59XG5mdW5jdGlvbiBwYXRjaEV2ZW50VGFyZ2V0KF9nbG9iYWwsIGFwaSwgYXBpcywgcGF0Y2hPcHRpb25zKSB7XG4gICAgY29uc3QgQUREX0VWRU5UX0xJU1RFTkVSID0gKHBhdGNoT3B0aW9ucyAmJiBwYXRjaE9wdGlvbnMuYWRkKSB8fCBBRERfRVZFTlRfTElTVEVORVJfU1RSO1xuICAgIGNvbnN0IFJFTU9WRV9FVkVOVF9MSVNURU5FUiA9IChwYXRjaE9wdGlvbnMgJiYgcGF0Y2hPcHRpb25zLnJtKSB8fCBSRU1PVkVfRVZFTlRfTElTVEVORVJfU1RSO1xuICAgIGNvbnN0IExJU1RFTkVSU19FVkVOVF9MSVNURU5FUiA9IChwYXRjaE9wdGlvbnMgJiYgcGF0Y2hPcHRpb25zLmxpc3RlbmVycykgfHwgJ2V2ZW50TGlzdGVuZXJzJztcbiAgICBjb25zdCBSRU1PVkVfQUxMX0xJU1RFTkVSU19FVkVOVF9MSVNURU5FUiA9IChwYXRjaE9wdGlvbnMgJiYgcGF0Y2hPcHRpb25zLnJtQWxsKSB8fCAncmVtb3ZlQWxsTGlzdGVuZXJzJztcbiAgICBjb25zdCB6b25lU3ltYm9sQWRkRXZlbnRMaXN0ZW5lciA9IHpvbmVTeW1ib2woQUREX0VWRU5UX0xJU1RFTkVSKTtcbiAgICBjb25zdCBBRERfRVZFTlRfTElTVEVORVJfU09VUkNFID0gJy4nICsgQUREX0VWRU5UX0xJU1RFTkVSICsgJzonO1xuICAgIGNvbnN0IFBSRVBFTkRfRVZFTlRfTElTVEVORVIgPSAncHJlcGVuZExpc3RlbmVyJztcbiAgICBjb25zdCBQUkVQRU5EX0VWRU5UX0xJU1RFTkVSX1NPVVJDRSA9ICcuJyArIFBSRVBFTkRfRVZFTlRfTElTVEVORVIgKyAnOic7XG4gICAgY29uc3QgaW52b2tlVGFzayA9IGZ1bmN0aW9uICh0YXNrLCB0YXJnZXQsIGV2ZW50KSB7XG4gICAgICAgIC8vIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UsIGNoZWNrIGlzUmVtb3ZlZCB3aGljaCBpcyBzZXRcbiAgICAgICAgLy8gYnkgcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgICAgICBpZiAodGFzay5pc1JlbW92ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWxlZ2F0ZSA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgZGVsZWdhdGUgPT09ICdvYmplY3QnICYmIGRlbGVnYXRlLmhhbmRsZUV2ZW50KSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGJpbmQgdmVyc2lvbiBvZiBoYW5kbGVFdmVudCB3aGVuIGludm9rZVxuICAgICAgICAgICAgdGFzay5jYWxsYmFjayA9IChldmVudCkgPT4gZGVsZWdhdGUuaGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgdGFzay5vcmlnaW5hbERlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW52b2tlIHN0YXRpYyB0YXNrLmludm9rZVxuICAgICAgICAvLyBuZWVkIHRvIHRyeS9jYXRjaCBlcnJvciBoZXJlLCBvdGhlcndpc2UsIHRoZSBlcnJvciBpbiBvbmUgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgLy8gd2lsbCBicmVhayB0aGUgZXhlY3V0aW9ucyBvZiB0aGUgb3RoZXIgZXZlbnQgbGlzdGVuZXJzLiBBbHNvIGVycm9yIHdpbGxcbiAgICAgICAgLy8gbm90IHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXIgd2hlbiBgb25jZWAgb3B0aW9ucyBpcyB0cnVlLlxuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0YXNrLmludm9rZSh0YXNrLCB0YXJnZXQsIFtldmVudF0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0YXNrLm9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zLm9uY2UpIHtcbiAgICAgICAgICAgIC8vIGlmIG9wdGlvbnMub25jZSBpcyB0cnVlLCBhZnRlciBpbnZva2Ugb25jZSByZW1vdmUgbGlzdGVuZXIgaGVyZVxuICAgICAgICAgICAgLy8gb25seSBicm93c2VyIG5lZWQgdG8gZG8gdGhpcywgbm9kZWpzIGV2ZW50RW1pdHRlciB3aWxsIGNhbCByZW1vdmVMaXN0ZW5lclxuICAgICAgICAgICAgLy8gaW5zaWRlIEV2ZW50RW1pdHRlci5vbmNlXG4gICAgICAgICAgICBjb25zdCBkZWxlZ2F0ZSA9IHRhc2sub3JpZ2luYWxEZWxlZ2F0ZSA/IHRhc2sub3JpZ2luYWxEZWxlZ2F0ZSA6IHRhc2suY2FsbGJhY2s7XG4gICAgICAgICAgICB0YXJnZXRbUkVNT1ZFX0VWRU5UX0xJU1RFTkVSXS5jYWxsKHRhcmdldCwgZXZlbnQudHlwZSwgZGVsZWdhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGdsb2JhbENhbGxiYWNrKGNvbnRleHQsIGV2ZW50LCBpc0NhcHR1cmUpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvem9uZS5qcy9pc3N1ZXMvOTExLCBpbiBJRSwgc29tZXRpbWVzXG4gICAgICAgIC8vIGV2ZW50IHdpbGwgYmUgdW5kZWZpbmVkLCBzbyB3ZSBuZWVkIHRvIHVzZSB3aW5kb3cuZXZlbnRcbiAgICAgICAgZXZlbnQgPSBldmVudCB8fCBfZ2xvYmFsLmV2ZW50O1xuICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXZlbnQudGFyZ2V0IGlzIG5lZWRlZCBmb3IgU2Ftc3VuZyBUViBhbmQgU291cmNlQnVmZmVyXG4gICAgICAgIC8vIHx8IGdsb2JhbCBpcyBuZWVkZWQgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvem9uZS5qcy9pc3N1ZXMvMTkwXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGNvbnRleHQgfHwgZXZlbnQudGFyZ2V0IHx8IF9nbG9iYWw7XG4gICAgICAgIGNvbnN0IHRhc2tzID0gdGFyZ2V0W3pvbmVTeW1ib2xFdmVudE5hbWVzW2V2ZW50LnR5cGVdW2lzQ2FwdHVyZSA/IFRSVUVfU1RSIDogRkFMU0VfU1RSXV07XG4gICAgICAgIGlmICh0YXNrcykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgICAgICAvLyBpbnZva2UgYWxsIHRhc2tzIHdoaWNoIGF0dGFjaGVkIHRvIGN1cnJlbnQgdGFyZ2V0IHdpdGggZ2l2ZW4gZXZlbnQudHlwZSBhbmQgY2FwdHVyZSA9IGZhbHNlXG4gICAgICAgICAgICAvLyBmb3IgcGVyZm9ybWFuY2UgY29uY2VybiwgaWYgdGFzay5sZW5ndGggPT09IDEsIGp1c3QgaW52b2tlXG4gICAgICAgICAgICBpZiAodGFza3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gaW52b2tlVGFzayh0YXNrc1swXSwgdGFyZ2V0LCBldmVudCk7XG4gICAgICAgICAgICAgICAgZXJyICYmIGVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci96b25lLmpzL2lzc3Vlcy84MzZcbiAgICAgICAgICAgICAgICAvLyBjb3B5IHRoZSB0YXNrcyBhcnJheSBiZWZvcmUgaW52b2tlLCB0byBhdm9pZFxuICAgICAgICAgICAgICAgIC8vIHRoZSBjYWxsYmFjayB3aWxsIHJlbW92ZSBpdHNlbGYgb3Igb3RoZXIgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICBjb25zdCBjb3B5VGFza3MgPSB0YXNrcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29weVRhc2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudCAmJiBldmVudFtJTU1FRElBVEVfUFJPUEFHQVRJT05fU1lNQk9MXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gaW52b2tlVGFzayhjb3B5VGFza3NbaV0sIHRhcmdldCwgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBlcnIgJiYgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGVyZSBpcyBvbmx5IG9uZSBlcnJvciwgd2UgZG9uJ3QgbmVlZCB0byBzY2hlZHVsZSBtaWNyb1Rhc2tcbiAgICAgICAgICAgIC8vIHRvIHRocm93IHRoZSBlcnJvci5cbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gZXJyb3JzW2ldO1xuICAgICAgICAgICAgICAgICAgICBhcGkubmF0aXZlU2NoZWR1bGVNaWNyb1Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZ2xvYmFsIHNoYXJlZCB6b25lQXdhcmVDYWxsYmFjayB0byBoYW5kbGUgYWxsIGV2ZW50IGNhbGxiYWNrIHdpdGggY2FwdHVyZSA9IGZhbHNlXG4gICAgY29uc3QgZ2xvYmFsWm9uZUF3YXJlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbENhbGxiYWNrKHRoaXMsIGV2ZW50LCBmYWxzZSk7XG4gICAgfTtcbiAgICAvLyBnbG9iYWwgc2hhcmVkIHpvbmVBd2FyZUNhbGxiYWNrIHRvIGhhbmRsZSBhbGwgZXZlbnQgY2FsbGJhY2sgd2l0aCBjYXB0dXJlID0gdHJ1ZVxuICAgIGNvbnN0IGdsb2JhbFpvbmVBd2FyZUNhcHR1cmVDYWxsYmFjayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsQ2FsbGJhY2sodGhpcywgZXZlbnQsIHRydWUpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcGF0Y2hFdmVudFRhcmdldE1ldGhvZHMob2JqLCBwYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdXNlR2xvYmFsQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBpZiAocGF0Y2hPcHRpb25zICYmIHBhdGNoT3B0aW9ucy51c2VHICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHVzZUdsb2JhbENhbGxiYWNrID0gcGF0Y2hPcHRpb25zLnVzZUc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWRhdGVIYW5kbGVyID0gcGF0Y2hPcHRpb25zICYmIHBhdGNoT3B0aW9ucy52aDtcbiAgICAgICAgbGV0IGNoZWNrRHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgICAgaWYgKHBhdGNoT3B0aW9ucyAmJiBwYXRjaE9wdGlvbnMuY2hrRHVwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlID0gcGF0Y2hPcHRpb25zLmNoa0R1cDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmV0dXJuVGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgIGlmIChwYXRjaE9wdGlvbnMgJiYgcGF0Y2hPcHRpb25zLnJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVyblRhcmdldCA9IHBhdGNoT3B0aW9ucy5ydDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJvdG8gPSBvYmo7XG4gICAgICAgIHdoaWxlIChwcm90byAmJiAhcHJvdG8uaGFzT3duUHJvcGVydHkoQUREX0VWRU5UX0xJU1RFTkVSKSkge1xuICAgICAgICAgICAgcHJvdG8gPSBPYmplY3RHZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm90byAmJiBvYmpbQUREX0VWRU5UX0xJU1RFTkVSXSkge1xuICAgICAgICAgICAgLy8gc29tZWhvdyB3ZSBkaWQgbm90IGZpbmQgaXQsIGJ1dCB3ZSBjYW4gc2VlIGl0LiBUaGlzIGhhcHBlbnMgb24gSUUgZm9yIFdpbmRvdyBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgcHJvdG8gPSBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm90bykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm90b1t6b25lU3ltYm9sQWRkRXZlbnRMaXN0ZW5lcl0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudE5hbWVUb1N0cmluZyA9IHBhdGNoT3B0aW9ucyAmJiBwYXRjaE9wdGlvbnMuZXZlbnROYW1lVG9TdHJpbmc7XG4gICAgICAgIC8vIGEgc2hhcmVkIGdsb2JhbCB0YXNrRGF0YSB0byBwYXNzIGRhdGEgZm9yIHNjaGVkdWxlRXZlbnRUYXNrXG4gICAgICAgIC8vIHNvIHdlIGRvIG5vdCBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3QganVzdCBmb3IgcGFzcyBzb21lIGRhdGFcbiAgICAgICAgY29uc3QgdGFza0RhdGEgPSB7fTtcbiAgICAgICAgY29uc3QgbmF0aXZlQWRkRXZlbnRMaXN0ZW5lciA9IHByb3RvW3pvbmVTeW1ib2xBZGRFdmVudExpc3RlbmVyXSA9IHByb3RvW0FERF9FVkVOVF9MSVNURU5FUl07XG4gICAgICAgIGNvbnN0IG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIgPSBwcm90b1t6b25lU3ltYm9sKFJFTU9WRV9FVkVOVF9MSVNURU5FUildID1cbiAgICAgICAgICAgIHByb3RvW1JFTU9WRV9FVkVOVF9MSVNURU5FUl07XG4gICAgICAgIGNvbnN0IG5hdGl2ZUxpc3RlbmVycyA9IHByb3RvW3pvbmVTeW1ib2woTElTVEVORVJTX0VWRU5UX0xJU1RFTkVSKV0gPVxuICAgICAgICAgICAgcHJvdG9bTElTVEVORVJTX0VWRU5UX0xJU1RFTkVSXTtcbiAgICAgICAgY29uc3QgbmF0aXZlUmVtb3ZlQWxsTGlzdGVuZXJzID0gcHJvdG9bem9uZVN5bWJvbChSRU1PVkVfQUxMX0xJU1RFTkVSU19FVkVOVF9MSVNURU5FUildID1cbiAgICAgICAgICAgIHByb3RvW1JFTU9WRV9BTExfTElTVEVORVJTX0VWRU5UX0xJU1RFTkVSXTtcbiAgICAgICAgbGV0IG5hdGl2ZVByZXBlbmRFdmVudExpc3RlbmVyO1xuICAgICAgICBpZiAocGF0Y2hPcHRpb25zICYmIHBhdGNoT3B0aW9ucy5wcmVwZW5kKSB7XG4gICAgICAgICAgICBuYXRpdmVQcmVwZW5kRXZlbnRMaXN0ZW5lciA9IHByb3RvW3pvbmVTeW1ib2wocGF0Y2hPcHRpb25zLnByZXBlbmQpXSA9XG4gICAgICAgICAgICAgICAgcHJvdG9bcGF0Y2hPcHRpb25zLnByZXBlbmRdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHV0aWwgZnVuY3Rpb24gd2lsbCBidWlsZCBhbiBvcHRpb24gb2JqZWN0IHdpdGggcGFzc2l2ZSBvcHRpb25cbiAgICAgICAgICogdG8gaGFuZGxlIGFsbCBwb3NzaWJsZSBpbnB1dCBmcm9tIHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gYnVpbGRFdmVudExpc3RlbmVyT3B0aW9ucyhvcHRpb25zLCBwYXNzaXZlKSB7XG4gICAgICAgICAgICBpZiAoIXBhc3NpdmVTdXBwb3J0ZWQgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAvLyBkb2Vzbid0IHN1cHBvcnQgcGFzc2l2ZSBidXQgdXNlciB3YW50IHRvIHBhc3MgYW4gb2JqZWN0IGFzIG9wdGlvbnMuXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIG5vdCB3b3JrIG9uIHNvbWUgb2xkIGJyb3dzZXIsIHNvIHdlIGp1c3QgcGFzcyBhIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAvLyBhcyB1c2VDYXB0dXJlIHBhcmFtZXRlclxuICAgICAgICAgICAgICAgIHJldHVybiAhIW9wdGlvbnMuY2FwdHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGFzc2l2ZVN1cHBvcnRlZCB8fCAhcGFzc2l2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjYXB0dXJlOiBvcHRpb25zLCBwYXNzaXZlOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBwYXNzaXZlOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMucGFzc2l2ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VzdG9tU2NoZWR1bGVHbG9iYWwgPSBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYWxyZWFkeSBhIHRhc2sgZm9yIHRoZSBldmVudE5hbWUgKyBjYXB0dXJlLFxuICAgICAgICAgICAgLy8ganVzdCByZXR1cm4sIGJlY2F1c2Ugd2UgdXNlIHRoZSBzaGFyZWQgZ2xvYmFsWm9uZUF3YXJlQ2FsbGJhY2sgaGVyZS5cbiAgICAgICAgICAgIGlmICh0YXNrRGF0YS5pc0V4aXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIuY2FsbCh0YXNrRGF0YS50YXJnZXQsIHRhc2tEYXRhLmV2ZW50TmFtZSwgdGFza0RhdGEuY2FwdHVyZSA/IGdsb2JhbFpvbmVBd2FyZUNhcHR1cmVDYWxsYmFjayA6IGdsb2JhbFpvbmVBd2FyZUNhbGxiYWNrLCB0YXNrRGF0YS5vcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY3VzdG9tQ2FuY2VsR2xvYmFsID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgICAgIC8vIGlmIHRhc2sgaXMgbm90IG1hcmtlZCBhcyBpc1JlbW92ZWQsIHRoaXMgY2FsbCBpcyBkaXJlY3RseVxuICAgICAgICAgICAgLy8gZnJvbSBab25lLnByb3RvdHlwZS5jYW5jZWxUYXNrLCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSB0YXNrXG4gICAgICAgICAgICAvLyBmcm9tIHRhc2tzTGlzdCBvZiB0YXJnZXQgZmlyc3RcbiAgICAgICAgICAgIGlmICghdGFzay5pc1JlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW1ib2xFdmVudE5hbWVzID0gem9uZVN5bWJvbEV2ZW50TmFtZXNbdGFzay5ldmVudE5hbWVdO1xuICAgICAgICAgICAgICAgIGxldCBzeW1ib2xFdmVudE5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbEV2ZW50TmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sRXZlbnROYW1lID0gc3ltYm9sRXZlbnROYW1lc1t0YXNrLmNhcHR1cmUgPyBUUlVFX1NUUiA6IEZBTFNFX1NUUl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVGFza3MgPSBzeW1ib2xFdmVudE5hbWUgJiYgdGFzay50YXJnZXRbc3ltYm9sRXZlbnROYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdUYXNrcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4aXN0aW5nVGFza3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVGFzayA9IGV4aXN0aW5nVGFza3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdUYXNrID09PSB0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdUYXNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGlzUmVtb3ZlZCB0byBkYXRhIGZvciBmYXN0ZXIgaW52b2tlVGFzayBjaGVja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suaXNSZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdUYXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIHRhc2tzIGZvciB0aGUgZXZlbnROYW1lICsgY2FwdHVyZSBoYXZlIGdvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBnbG9iYWxab25lQXdhcmVDYWxsYmFjayBhbmQgcmVtb3ZlIHRoZSB0YXNrIGNhY2hlIGZyb20gdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suYWxsUmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sudGFyZ2V0W3N5bWJvbEV2ZW50TmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGFsbCB0YXNrcyBmb3IgdGhlIGV2ZW50TmFtZSArIGNhcHR1cmUgaGF2ZSBnb25lLFxuICAgICAgICAgICAgLy8gd2Ugd2lsbCByZWFsbHkgcmVtb3ZlIHRoZSBnbG9iYWwgZXZlbnQgY2FsbGJhY2ssXG4gICAgICAgICAgICAvLyBpZiBub3QsIHJldHVyblxuICAgICAgICAgICAgaWYgKCF0YXNrLmFsbFJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKHRhc2sudGFyZ2V0LCB0YXNrLmV2ZW50TmFtZSwgdGFzay5jYXB0dXJlID8gZ2xvYmFsWm9uZUF3YXJlQ2FwdHVyZUNhbGxiYWNrIDogZ2xvYmFsWm9uZUF3YXJlQ2FsbGJhY2ssIHRhc2sub3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGN1c3RvbVNjaGVkdWxlTm9uR2xvYmFsID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVBZGRFdmVudExpc3RlbmVyLmNhbGwodGFza0RhdGEudGFyZ2V0LCB0YXNrRGF0YS5ldmVudE5hbWUsIHRhc2suaW52b2tlLCB0YXNrRGF0YS5vcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY3VzdG9tU2NoZWR1bGVQcmVwZW5kID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVQcmVwZW5kRXZlbnRMaXN0ZW5lci5jYWxsKHRhc2tEYXRhLnRhcmdldCwgdGFza0RhdGEuZXZlbnROYW1lLCB0YXNrLmludm9rZSwgdGFza0RhdGEub3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGN1c3RvbUNhbmNlbE5vbkdsb2JhbCA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKHRhc2sudGFyZ2V0LCB0YXNrLmV2ZW50TmFtZSwgdGFzay5pbnZva2UsIHRhc2sub3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGN1c3RvbVNjaGVkdWxlID0gdXNlR2xvYmFsQ2FsbGJhY2sgPyBjdXN0b21TY2hlZHVsZUdsb2JhbCA6IGN1c3RvbVNjaGVkdWxlTm9uR2xvYmFsO1xuICAgICAgICBjb25zdCBjdXN0b21DYW5jZWwgPSB1c2VHbG9iYWxDYWxsYmFjayA/IGN1c3RvbUNhbmNlbEdsb2JhbCA6IGN1c3RvbUNhbmNlbE5vbkdsb2JhbDtcbiAgICAgICAgY29uc3QgY29tcGFyZVRhc2tDYWxsYmFja1ZzRGVsZWdhdGUgPSBmdW5jdGlvbiAodGFzaywgZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVPZkRlbGVnYXRlID0gdHlwZW9mIGRlbGVnYXRlO1xuICAgICAgICAgICAgcmV0dXJuICh0eXBlT2ZEZWxlZ2F0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0YXNrLmNhbGxiYWNrID09PSBkZWxlZ2F0ZSkgfHxcbiAgICAgICAgICAgICAgICAodHlwZU9mRGVsZWdhdGUgPT09ICdvYmplY3QnICYmIHRhc2sub3JpZ2luYWxEZWxlZ2F0ZSA9PT0gZGVsZWdhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb21wYXJlID0gKHBhdGNoT3B0aW9ucyAmJiBwYXRjaE9wdGlvbnMuZGlmZikgPyBwYXRjaE9wdGlvbnMuZGlmZiA6IGNvbXBhcmVUYXNrQ2FsbGJhY2tWc0RlbGVnYXRlO1xuICAgICAgICBjb25zdCB1bnBhdGNoZWRFdmVudHMgPSBab25lW3pvbmVTeW1ib2woJ1VOUEFUQ0hFRF9FVkVOVFMnKV07XG4gICAgICAgIGNvbnN0IHBhc3NpdmVFdmVudHMgPSBfZ2xvYmFsW3pvbmVTeW1ib2woJ1BBU1NJVkVfRVZFTlRTJyldO1xuICAgICAgICBjb25zdCBtYWtlQWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAobmF0aXZlTGlzdGVuZXIsIGFkZFNvdXJjZSwgY3VzdG9tU2NoZWR1bGVGbiwgY3VzdG9tQ2FuY2VsRm4sIHJldHVyblRhcmdldCA9IGZhbHNlLCBwcmVwZW5kID0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcyB8fCBfZ2xvYmFsO1xuICAgICAgICAgICAgICAgIGxldCBldmVudE5hbWUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoT3B0aW9ucyAmJiBwYXRjaE9wdGlvbnMudHJhbnNmZXJFdmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lID0gcGF0Y2hPcHRpb25zLnRyYW5zZmVyRXZlbnROYW1lKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBkZWxlZ2F0ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICBpZiAoIWRlbGVnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYXRpdmVMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNOb2RlICYmIGV2ZW50TmFtZSA9PT0gJ3VuY2F1Z2h0RXhjZXB0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBwYXRjaCB1bmNhdWdodEV4Y2VwdGlvbiBvZiBub2RlanMgdG8gcHJldmVudCBlbmRsZXNzIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZUxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRvbid0IGNyZWF0ZSB0aGUgYmluZCBkZWxlZ2F0ZSBmdW5jdGlvbiBmb3IgaGFuZGxlRXZlbnRcbiAgICAgICAgICAgICAgICAvLyBjYXNlIGhlcmUgdG8gaW1wcm92ZSBhZGRFdmVudExpc3RlbmVyIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAgICAgLy8gd2Ugd2lsbCBjcmVhdGUgdGhlIGJpbmQgZGVsZWdhdGUgd2hlbiBpbnZva2VcbiAgICAgICAgICAgICAgICBsZXQgaXNIYW5kbGVFdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVsZWdhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWxlZ2F0ZS5oYW5kbGVFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZUxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXNIYW5kbGVFdmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZUhhbmRsZXIgJiYgIXZhbGlkYXRlSGFuZGxlcihuYXRpdmVMaXN0ZW5lciwgZGVsZWdhdGUsIHRhcmdldCwgYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBhc3NpdmUgPSBwYXNzaXZlU3VwcG9ydGVkICYmICEhcGFzc2l2ZUV2ZW50cyAmJiBwYXNzaXZlRXZlbnRzLmluZGV4T2YoZXZlbnROYW1lKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGJ1aWxkRXZlbnRMaXN0ZW5lck9wdGlvbnMoYXJndW1lbnRzWzJdLCBwYXNzaXZlKTtcbiAgICAgICAgICAgICAgICBpZiAodW5wYXRjaGVkRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHVwYXRjaGVkIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bnBhdGNoZWRFdmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09IHVucGF0Y2hlZEV2ZW50c1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXNzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYXRpdmVMaXN0ZW5lci5jYWxsKHRhcmdldCwgZXZlbnROYW1lLCBkZWxlZ2F0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmF0aXZlTGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2FwdHVyZSA9ICFvcHRpb25zID8gZmFsc2UgOiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8gdHJ1ZSA6IG9wdGlvbnMuY2FwdHVyZTtcbiAgICAgICAgICAgICAgICBjb25zdCBvbmNlID0gb3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgPyBvcHRpb25zLm9uY2UgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCB6b25lID0gWm9uZS5jdXJyZW50O1xuICAgICAgICAgICAgICAgIGxldCBzeW1ib2xFdmVudE5hbWVzID0gem9uZVN5bWJvbEV2ZW50TmFtZXNbZXZlbnROYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoIXN5bWJvbEV2ZW50TmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlcGFyZUV2ZW50TmFtZXMoZXZlbnROYW1lLCBldmVudE5hbWVUb1N0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbEV2ZW50TmFtZXMgPSB6b25lU3ltYm9sRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzeW1ib2xFdmVudE5hbWUgPSBzeW1ib2xFdmVudE5hbWVzW2NhcHR1cmUgPyBUUlVFX1NUUiA6IEZBTFNFX1NUUl07XG4gICAgICAgICAgICAgICAgbGV0IGV4aXN0aW5nVGFza3MgPSB0YXJnZXRbc3ltYm9sRXZlbnROYW1lXTtcbiAgICAgICAgICAgICAgICBsZXQgaXNFeGlzdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1Rhc2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgaGF2ZSB0YXNrIHJlZ2lzdGVyZWRcbiAgICAgICAgICAgICAgICAgICAgaXNFeGlzdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVja0R1cGxpY2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleGlzdGluZ1Rhc2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoZXhpc3RpbmdUYXNrc1tpXSwgZGVsZWdhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhbWUgY2FsbGJhY2ssIHNhbWUgY2FwdHVyZSwgc2FtZSBldmVudCBuYW1lLCBqdXN0IHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1Rhc2tzID0gdGFyZ2V0W3N5bWJvbEV2ZW50TmFtZV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25zdHJ1Y3Rvck5hbWUgPSB0YXJnZXQuY29uc3RydWN0b3JbJ25hbWUnXTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRTb3VyY2UgPSBnbG9iYWxTb3VyY2VzW2NvbnN0cnVjdG9yTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSB0YXJnZXRTb3VyY2VbZXZlbnROYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gY29uc3RydWN0b3JOYW1lICsgYWRkU291cmNlICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChldmVudE5hbWVUb1N0cmluZyA/IGV2ZW50TmFtZVRvU3RyaW5nKGV2ZW50TmFtZSkgOiBldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgY3JlYXRlIGEgbmV3IG9iamVjdCBhcyB0YXNrLmRhdGEgdG8gcGFzcyB0aG9zZSB0aGluZ3NcbiAgICAgICAgICAgICAgICAvLyBqdXN0IHVzZSB0aGUgZ2xvYmFsIHNoYXJlZCBvbmVcbiAgICAgICAgICAgICAgICB0YXNrRGF0YS5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAob25jZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBhZGRFdmVudExpc3RlbmVyIHdpdGggb25jZSBvcHRpb25zLCB3ZSBkb24ndCBwYXNzIGl0IHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIG5hdGl2ZSBhZGRFdmVudExpc3RlbmVyLCBpbnN0ZWFkIHdlIGtlZXAgdGhlIG9uY2Ugc2V0dGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgaGFuZGxlIG91cnNlbHZlcy5cbiAgICAgICAgICAgICAgICAgICAgdGFza0RhdGEub3B0aW9ucy5vbmNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhc2tEYXRhLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICB0YXNrRGF0YS5jYXB0dXJlID0gY2FwdHVyZTtcbiAgICAgICAgICAgICAgICB0YXNrRGF0YS5ldmVudE5hbWUgPSBldmVudE5hbWU7XG4gICAgICAgICAgICAgICAgdGFza0RhdGEuaXNFeGlzdGluZyA9IGlzRXhpc3Rpbmc7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHVzZUdsb2JhbENhbGxiYWNrID8gT1BUSU1JWkVEX1pPTkVfRVZFTlRfVEFTS19EQVRBIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIC8vIGtlZXAgdGFza0RhdGEgaW50byBkYXRhIHRvIGFsbG93IG9uU2NoZWR1bGVFdmVudFRhc2sgdG8gYWNjZXNzIHRoZSB0YXNrIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS50YXNrRGF0YSA9IHRhc2tEYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0YXNrID0gem9uZS5zY2hlZHVsZUV2ZW50VGFzayhzb3VyY2UsIGRlbGVnYXRlLCBkYXRhLCBjdXN0b21TY2hlZHVsZUZuLCBjdXN0b21DYW5jZWxGbik7XG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGNsZWFyIHRhc2tEYXRhLnRhcmdldCB0byBhdm9pZCBtZW1vcnkgbGVha1xuICAgICAgICAgICAgICAgIC8vIGlzc3VlLCBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8yMDQ0MlxuICAgICAgICAgICAgICAgIHRhc2tEYXRhLnRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byBjbGVhciB1cCB0YXNrRGF0YSBiZWNhdXNlIGl0IGlzIGEgZ2xvYmFsIG9iamVjdFxuICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEudGFza0RhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBoYXZlIHRvIHNhdmUgdGhvc2UgaW5mb3JtYXRpb24gdG8gdGFzayBpbiBjYXNlXG4gICAgICAgICAgICAgICAgLy8gYXBwbGljYXRpb24gbWF5IGNhbGwgdGFzay56b25lLmNhbmNlbFRhc2soKSBkaXJlY3RseVxuICAgICAgICAgICAgICAgIGlmIChvbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25jZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKCFwYXNzaXZlU3VwcG9ydGVkICYmIHR5cGVvZiB0YXNrLm9wdGlvbnMgPT09ICdib29sZWFuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm90IHN1cHBvcnQgcGFzc2l2ZSwgYW5kIHdlIHBhc3MgYW4gb3B0aW9uIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBhZGRFdmVudExpc3RlbmVyLCB3ZSBzaG91bGQgc2F2ZSB0aGUgb3B0aW9ucyB0byB0YXNrXG4gICAgICAgICAgICAgICAgICAgIHRhc2sub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhc2sudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIHRhc2suY2FwdHVyZSA9IGNhcHR1cmU7XG4gICAgICAgICAgICAgICAgdGFzay5ldmVudE5hbWUgPSBldmVudE5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzSGFuZGxlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBvcmlnaW5hbCBkZWxlZ2F0ZSBmb3IgY29tcGFyZSB0byBjaGVjayBkdXBsaWNhdGVcbiAgICAgICAgICAgICAgICAgICAgdGFzay5vcmlnaW5hbERlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcHJlcGVuZCkge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1Rhc2tzLnB1c2godGFzayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1Rhc2tzLnVuc2hpZnQodGFzayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5UYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBwcm90b1tBRERfRVZFTlRfTElTVEVORVJdID0gbWFrZUFkZExpc3RlbmVyKG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIsIEFERF9FVkVOVF9MSVNURU5FUl9TT1VSQ0UsIGN1c3RvbVNjaGVkdWxlLCBjdXN0b21DYW5jZWwsIHJldHVyblRhcmdldCk7XG4gICAgICAgIGlmIChuYXRpdmVQcmVwZW5kRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgcHJvdG9bUFJFUEVORF9FVkVOVF9MSVNURU5FUl0gPSBtYWtlQWRkTGlzdGVuZXIobmF0aXZlUHJlcGVuZEV2ZW50TGlzdGVuZXIsIFBSRVBFTkRfRVZFTlRfTElTVEVORVJfU09VUkNFLCBjdXN0b21TY2hlZHVsZVByZXBlbmQsIGN1c3RvbUNhbmNlbCwgcmV0dXJuVGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBwcm90b1tSRU1PVkVfRVZFTlRfTElTVEVORVJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcyB8fCBfZ2xvYmFsO1xuICAgICAgICAgICAgbGV0IGV2ZW50TmFtZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGlmIChwYXRjaE9wdGlvbnMgJiYgcGF0Y2hPcHRpb25zLnRyYW5zZmVyRXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgZXZlbnROYW1lID0gcGF0Y2hPcHRpb25zLnRyYW5zZmVyRXZlbnROYW1lKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgY29uc3QgY2FwdHVyZSA9ICFvcHRpb25zID8gZmFsc2UgOiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8gdHJ1ZSA6IG9wdGlvbnMuY2FwdHVyZTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGVnYXRlID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgaWYgKCFkZWxlZ2F0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsaWRhdGVIYW5kbGVyICYmXG4gICAgICAgICAgICAgICAgIXZhbGlkYXRlSGFuZGxlcihuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyLCBkZWxlZ2F0ZSwgdGFyZ2V0LCBhcmd1bWVudHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3ltYm9sRXZlbnROYW1lcyA9IHpvbmVTeW1ib2xFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICBsZXQgc3ltYm9sRXZlbnROYW1lO1xuICAgICAgICAgICAgaWYgKHN5bWJvbEV2ZW50TmFtZXMpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xFdmVudE5hbWUgPSBzeW1ib2xFdmVudE5hbWVzW2NhcHR1cmUgPyBUUlVFX1NUUiA6IEZBTFNFX1NUUl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1Rhc2tzID0gc3ltYm9sRXZlbnROYW1lICYmIHRhcmdldFtzeW1ib2xFdmVudE5hbWVdO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nVGFza3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4aXN0aW5nVGFza3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdUYXNrID0gZXhpc3RpbmdUYXNrc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoZXhpc3RpbmdUYXNrLCBkZWxlZ2F0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVGFza3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGlzUmVtb3ZlZCB0byBkYXRhIGZvciBmYXN0ZXIgaW52b2tlVGFzayBjaGVja1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdUYXNrLmlzUmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdUYXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGwgdGFza3MgZm9yIHRoZSBldmVudE5hbWUgKyBjYXB0dXJlIGhhdmUgZ29uZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZ2xvYmFsWm9uZUF3YXJlQ2FsbGJhY2sgYW5kIHJlbW92ZSB0aGUgdGFzayBjYWNoZSBmcm9tIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVGFzay5hbGxSZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbc3ltYm9sRXZlbnROYW1lXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIHRhcmdldCwgd2UgaGF2ZSBhbiBldmVudCBsaXN0ZW5lciB3aGljaCBpcyBhZGRlZCBieSBvbl9wcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1Y2ggYXMgdGFyZ2V0Lm9uY2xpY2sgPSBmdW5jdGlvbigpIHt9LCBzbyB3ZSBuZWVkIHRvIGNsZWFyIHRoaXMgaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0eSB0b28gaWYgYWxsIGRlbGVnYXRlcyBhbGwgcmVtb3ZlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvblByb3BlcnR5U3ltYm9sID0gWk9ORV9TWU1CT0xfUFJFRklYICsgJ09OX1BST1BFUlRZJyArIGV2ZW50TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W29uUHJvcGVydHlTeW1ib2xdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1Rhc2suem9uZS5jYW5jZWxUYXNrKGV4aXN0aW5nVGFzayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlzc3VlIDkzMCwgZGlkbid0IGZpbmQgdGhlIGV2ZW50IG5hbWUgb3IgY2FsbGJhY2tcbiAgICAgICAgICAgIC8vIGZyb20gem9uZSBrZXB0IGV4aXN0aW5nVGFza3MsIHRoZSBjYWxsYmFjayBtYXliZVxuICAgICAgICAgICAgLy8gYWRkZWQgb3V0c2lkZSBvZiB6b25lLCB3ZSBuZWVkIHRvIGNhbGwgbmF0aXZlIHJlbW92ZUV2ZW50TGlzdGVuZXJcbiAgICAgICAgICAgIC8vIHRvIHRyeSB0byByZW1vdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgICBwcm90b1tMSVNURU5FUlNfRVZFTlRfTElTVEVORVJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcyB8fCBfZ2xvYmFsO1xuICAgICAgICAgICAgbGV0IGV2ZW50TmFtZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGlmIChwYXRjaE9wdGlvbnMgJiYgcGF0Y2hPcHRpb25zLnRyYW5zZmVyRXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgZXZlbnROYW1lID0gcGF0Y2hPcHRpb25zLnRyYW5zZmVyRXZlbnROYW1lKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHRhc2tzID0gZmluZEV2ZW50VGFza3ModGFyZ2V0LCBldmVudE5hbWVUb1N0cmluZyA/IGV2ZW50TmFtZVRvU3RyaW5nKGV2ZW50TmFtZSkgOiBldmVudE5hbWUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhc2sgPSB0YXNrc1tpXTtcbiAgICAgICAgICAgICAgICBsZXQgZGVsZWdhdGUgPSB0YXNrLm9yaWdpbmFsRGVsZWdhdGUgPyB0YXNrLm9yaWdpbmFsRGVsZWdhdGUgOiB0YXNrLmNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKGRlbGVnYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnM7XG4gICAgICAgIH07XG4gICAgICAgIHByb3RvW1JFTU9WRV9BTExfTElTVEVORVJTX0VWRU5UX0xJU1RFTkVSXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMgfHwgX2dsb2JhbDtcbiAgICAgICAgICAgIGxldCBldmVudE5hbWUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBpZiAoIWV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBFVkVOVF9OQU1FX1NZTUJPTF9SRUdYLmV4ZWMocHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBldnROYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGluIG5vZGVqcyBFdmVudEVtaXR0ZXIsIHJlbW92ZUxpc3RlbmVyIGV2ZW50IGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgZm9yIG1vbml0b3JpbmcgdGhlIHJlbW92ZUxpc3RlbmVyIGNhbGwsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIGp1c3Qga2VlcCByZW1vdmVMaXN0ZW5lciBldmVudExpc3RlbmVyIHVudGlsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbCBvdGhlciBldmVudExpc3RlbmVycyBhcmUgcmVtb3ZlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZ0TmFtZSAmJiBldnROYW1lICE9PSAncmVtb3ZlTGlzdGVuZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1JFTU9WRV9BTExfTElTVEVORVJTX0VWRU5UX0xJU1RFTkVSXS5jYWxsKHRoaXMsIGV2dE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSByZW1vdmVMaXN0ZW5lciBsaXN0ZW5lciBmaW5hbGx5XG4gICAgICAgICAgICAgICAgdGhpc1tSRU1PVkVfQUxMX0xJU1RFTkVSU19FVkVOVF9MSVNURU5FUl0uY2FsbCh0aGlzLCAncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwYXRjaE9wdGlvbnMgJiYgcGF0Y2hPcHRpb25zLnRyYW5zZmVyRXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IHBhdGNoT3B0aW9ucy50cmFuc2ZlckV2ZW50TmFtZShldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzeW1ib2xFdmVudE5hbWVzID0gem9uZVN5bWJvbEV2ZW50TmFtZXNbZXZlbnROYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sRXZlbnROYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzeW1ib2xFdmVudE5hbWUgPSBzeW1ib2xFdmVudE5hbWVzW0ZBTFNFX1NUUl07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN5bWJvbENhcHR1cmVFdmVudE5hbWUgPSBzeW1ib2xFdmVudE5hbWVzW1RSVUVfU1RSXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFza3MgPSB0YXJnZXRbc3ltYm9sRXZlbnROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FwdHVyZVRhc2tzID0gdGFyZ2V0W3N5bWJvbENhcHR1cmVFdmVudE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFza3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW92ZVRhc2tzID0gdGFza3Muc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlVGFza3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXNrID0gcmVtb3ZlVGFza3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRlbGVnYXRlID0gdGFzay5vcmlnaW5hbERlbGVnYXRlID8gdGFzay5vcmlnaW5hbERlbGVnYXRlIDogdGFzay5jYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1JFTU9WRV9FVkVOVF9MSVNURU5FUl0uY2FsbCh0aGlzLCBldmVudE5hbWUsIGRlbGVnYXRlLCB0YXNrLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlVGFza3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW92ZVRhc2tzID0gY2FwdHVyZVRhc2tzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZVRhc2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFzayA9IHJlbW92ZVRhc2tzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZWxlZ2F0ZSA9IHRhc2sub3JpZ2luYWxEZWxlZ2F0ZSA/IHRhc2sub3JpZ2luYWxEZWxlZ2F0ZSA6IHRhc2suY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tSRU1PVkVfRVZFTlRfTElTVEVORVJdLmNhbGwodGhpcywgZXZlbnROYW1lLCBkZWxlZ2F0ZSwgdGFzay5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXR1cm5UYXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gZm9yIG5hdGl2ZSB0b1N0cmluZyBwYXRjaFxuICAgICAgICBhdHRhY2hPcmlnaW5Ub1BhdGNoZWQocHJvdG9bQUREX0VWRU5UX0xJU1RFTkVSXSwgbmF0aXZlQWRkRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgIGF0dGFjaE9yaWdpblRvUGF0Y2hlZChwcm90b1tSRU1PVkVfRVZFTlRfTElTVEVORVJdLCBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyKTtcbiAgICAgICAgaWYgKG5hdGl2ZVJlbW92ZUFsbExpc3RlbmVycykge1xuICAgICAgICAgICAgYXR0YWNoT3JpZ2luVG9QYXRjaGVkKHByb3RvW1JFTU9WRV9BTExfTElTVEVORVJTX0VWRU5UX0xJU1RFTkVSXSwgbmF0aXZlUmVtb3ZlQWxsTGlzdGVuZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmF0aXZlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBhdHRhY2hPcmlnaW5Ub1BhdGNoZWQocHJvdG9bTElTVEVORVJTX0VWRU5UX0xJU1RFTkVSXSwgbmF0aXZlTGlzdGVuZXJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFwaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0c1tpXSA9IHBhdGNoRXZlbnRUYXJnZXRNZXRob2RzKGFwaXNbaV0sIHBhdGNoT3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xufVxuZnVuY3Rpb24gZmluZEV2ZW50VGFza3ModGFyZ2V0LCBldmVudE5hbWUpIHtcbiAgICBpZiAoIWV2ZW50TmFtZSkge1xuICAgICAgICBjb25zdCBmb3VuZFRhc2tzID0gW107XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IEVWRU5UX05BTUVfU1lNQk9MX1JFR1guZXhlYyhwcm9wKTtcbiAgICAgICAgICAgIGxldCBldnROYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgICAgICAgICBpZiAoZXZ0TmFtZSAmJiAoIWV2ZW50TmFtZSB8fCBldnROYW1lID09PSBldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFza3MgPSB0YXJnZXRbcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKHRhc2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFza3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kVGFza3MucHVzaCh0YXNrc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kVGFza3M7XG4gICAgfVxuICAgIGxldCBzeW1ib2xFdmVudE5hbWUgPSB6b25lU3ltYm9sRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICAgIGlmICghc3ltYm9sRXZlbnROYW1lKSB7XG4gICAgICAgIHByZXBhcmVFdmVudE5hbWVzKGV2ZW50TmFtZSk7XG4gICAgICAgIHN5bWJvbEV2ZW50TmFtZSA9IHpvbmVTeW1ib2xFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gICAgfVxuICAgIGNvbnN0IGNhcHR1cmVGYWxzZVRhc2tzID0gdGFyZ2V0W3N5bWJvbEV2ZW50TmFtZVtGQUxTRV9TVFJdXTtcbiAgICBjb25zdCBjYXB0dXJlVHJ1ZVRhc2tzID0gdGFyZ2V0W3N5bWJvbEV2ZW50TmFtZVtUUlVFX1NUUl1dO1xuICAgIGlmICghY2FwdHVyZUZhbHNlVGFza3MpIHtcbiAgICAgICAgcmV0dXJuIGNhcHR1cmVUcnVlVGFza3MgPyBjYXB0dXJlVHJ1ZVRhc2tzLnNsaWNlKCkgOiBbXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjYXB0dXJlVHJ1ZVRhc2tzID8gY2FwdHVyZUZhbHNlVGFza3MuY29uY2F0KGNhcHR1cmVUcnVlVGFza3MpIDpcbiAgICAgICAgICAgIGNhcHR1cmVGYWxzZVRhc2tzLnNsaWNlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGF0Y2hFdmVudFByb3RvdHlwZShnbG9iYWwsIGFwaSkge1xuICAgIGNvbnN0IEV2ZW50ID0gZ2xvYmFsWydFdmVudCddO1xuICAgIGlmIChFdmVudCAmJiBFdmVudC5wcm90b3R5cGUpIHtcbiAgICAgICAgYXBpLnBhdGNoTWV0aG9kKEV2ZW50LnByb3RvdHlwZSwgJ3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbicsIChkZWxlZ2F0ZSkgPT4gZnVuY3Rpb24gKHNlbGYsIGFyZ3MpIHtcbiAgICAgICAgICAgIHNlbGZbSU1NRURJQVRFX1BST1BBR0FUSU9OX1NZTUJPTF0gPSB0cnVlO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBjYWxsIHRoZSBuYXRpdmUgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXG4gICAgICAgICAgICAvLyBpbiBjYXNlIGluIHNvbWUgaHlicmlkIGFwcGxpY2F0aW9uLCBzb21lIHBhcnQgb2ZcbiAgICAgICAgICAgIC8vIGFwcGxpY2F0aW9uIHdpbGwgYmUgY29udHJvbGxlZCBieSB6b25lLCBzb21lIGFyZSBub3RcbiAgICAgICAgICAgIGRlbGVnYXRlICYmIGRlbGVnYXRlLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gcGF0Y2hDYWxsYmFja3MoYXBpLCB0YXJnZXQsIHRhcmdldE5hbWUsIG1ldGhvZCwgY2FsbGJhY2tzKSB7XG4gICAgY29uc3Qgc3ltYm9sID0gWm9uZS5fX3N5bWJvbF9fKG1ldGhvZCk7XG4gICAgaWYgKHRhcmdldFtzeW1ib2xdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmF0aXZlRGVsZWdhdGUgPSB0YXJnZXRbc3ltYm9sXSA9IHRhcmdldFttZXRob2RdO1xuICAgIHRhcmdldFttZXRob2RdID0gZnVuY3Rpb24gKG5hbWUsIG9wdHMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdHMgJiYgb3B0cy5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGAke3RhcmdldE5hbWV9LiR7bWV0aG9kfTo6YCArIGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3RvdHlwZSA9IG9wdHMucHJvdG90eXBlO1xuICAgICAgICAgICAgICAgIGlmIChwcm90b3R5cGUuaGFzT3duUHJvcGVydHkoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBhcGkuT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvdHlwZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gYXBpLndyYXBXaXRoQ3VycmVudFpvbmUoZGVzY3JpcHRvci52YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5fcmVkZWZpbmVQcm9wZXJ0eShvcHRzLnByb3RvdHlwZSwgY2FsbGJhY2ssIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3RvdHlwZVtjYWxsYmFja10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3RvdHlwZVtjYWxsYmFja10gPSBhcGkud3JhcFdpdGhDdXJyZW50Wm9uZShwcm90b3R5cGVbY2FsbGJhY2tdLCBzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3RvdHlwZVtjYWxsYmFja10pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdG90eXBlW2NhbGxiYWNrXSA9IGFwaS53cmFwV2l0aEN1cnJlbnRab25lKHByb3RvdHlwZVtjYWxsYmFja10sIHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hdGl2ZURlbGVnYXRlLmNhbGwodGFyZ2V0LCBuYW1lLCBvcHRzLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGFwaS5hdHRhY2hPcmlnaW5Ub1BhdGNoZWQodGFyZ2V0W21ldGhvZF0sIG5hdGl2ZURlbGVnYXRlKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBmaWx0ZXJQcm9wZXJ0aWVzKHRhcmdldCwgb25Qcm9wZXJ0aWVzLCBpZ25vcmVQcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFpZ25vcmVQcm9wZXJ0aWVzIHx8IGlnbm9yZVByb3BlcnRpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBvblByb3BlcnRpZXM7XG4gICAgfVxuICAgIGNvbnN0IHRpcCA9IGlnbm9yZVByb3BlcnRpZXMuZmlsdGVyKGlwID0+IGlwLnRhcmdldCA9PT0gdGFyZ2V0KTtcbiAgICBpZiAoIXRpcCB8fCB0aXAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBvblByb3BlcnRpZXM7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldElnbm9yZVByb3BlcnRpZXMgPSB0aXBbMF0uaWdub3JlUHJvcGVydGllcztcbiAgICByZXR1cm4gb25Qcm9wZXJ0aWVzLmZpbHRlcihvcCA9PiB0YXJnZXRJZ25vcmVQcm9wZXJ0aWVzLmluZGV4T2Yob3ApID09PSAtMSk7XG59XG5mdW5jdGlvbiBwYXRjaEZpbHRlcmVkUHJvcGVydGllcyh0YXJnZXQsIG9uUHJvcGVydGllcywgaWdub3JlUHJvcGVydGllcywgcHJvdG90eXBlKSB7XG4gICAgLy8gY2hlY2sgd2hldGhlciB0YXJnZXQgaXMgYXZhaWxhYmxlLCBzb21ldGltZXMgdGFyZ2V0IHdpbGwgYmUgdW5kZWZpbmVkXG4gICAgLy8gYmVjYXVzZSBkaWZmZXJlbnQgYnJvd3NlciBvciBzb21lIDNyZCBwYXJ0eSBwbHVnaW4uXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJlZFByb3BlcnRpZXMgPSBmaWx0ZXJQcm9wZXJ0aWVzKHRhcmdldCwgb25Qcm9wZXJ0aWVzLCBpZ25vcmVQcm9wZXJ0aWVzKTtcbiAgICBwYXRjaE9uUHJvcGVydGllcyh0YXJnZXQsIGZpbHRlcmVkUHJvcGVydGllcywgcHJvdG90eXBlKTtcbn1cbi8qKlxuICogR2V0IGFsbCBldmVudCBuYW1lIHByb3BlcnRpZXMgd2hpY2ggdGhlIGV2ZW50IG5hbWUgc3RhcnRzV2l0aCBgb25gXG4gKiBmcm9tIHRoZSB0YXJnZXQgb2JqZWN0IGl0c2VsZiwgaW5oZXJpdGVkIHByb3BlcnRpZXMgYXJlIG5vdCBjb25zaWRlcmVkLlxuICovXG5mdW5jdGlvbiBnZXRPbkV2ZW50TmFtZXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgICAgLmZpbHRlcihuYW1lID0+IG5hbWUuc3RhcnRzV2l0aCgnb24nKSAmJiBuYW1lLmxlbmd0aCA+IDIpXG4gICAgICAgIC5tYXAobmFtZSA9PiBuYW1lLnN1YnN0cmluZygyKSk7XG59XG5mdW5jdGlvbiBwcm9wZXJ0eURlc2NyaXB0b3JQYXRjaChhcGksIF9nbG9iYWwpIHtcbiAgICBpZiAoaXNOb2RlICYmICFpc01peCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChab25lW2FwaS5zeW1ib2woJ3BhdGNoRXZlbnRzJyldKSB7XG4gICAgICAgIC8vIGV2ZW50cyBhcmUgYWxyZWFkeSBiZWVuIHBhdGNoZWQgYnkgbGVnYWN5IHBhdGNoLlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlnbm9yZVByb3BlcnRpZXMgPSBfZ2xvYmFsWydfX1pvbmVfaWdub3JlX29uX3Byb3BlcnRpZXMnXTtcbiAgICAvLyBmb3IgYnJvd3NlcnMgdGhhdCB3ZSBjYW4gcGF0Y2ggdGhlIGRlc2NyaXB0b3I6ICBDaHJvbWUgJiBGaXJlZm94XG4gICAgbGV0IHBhdGNoVGFyZ2V0cyA9IFtdO1xuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxXaW5kb3cgPSB3aW5kb3c7XG4gICAgICAgIHBhdGNoVGFyZ2V0cyA9IHBhdGNoVGFyZ2V0cy5jb25jYXQoW1xuICAgICAgICAgICAgJ0RvY3VtZW50JywgJ1NWR0VsZW1lbnQnLCAnRWxlbWVudCcsICdIVE1MRWxlbWVudCcsICdIVE1MQm9keUVsZW1lbnQnLCAnSFRNTE1lZGlhRWxlbWVudCcsXG4gICAgICAgICAgICAnSFRNTEZyYW1lU2V0RWxlbWVudCcsICdIVE1MRnJhbWVFbGVtZW50JywgJ0hUTUxJRnJhbWVFbGVtZW50JywgJ0hUTUxNYXJxdWVlRWxlbWVudCcsICdXb3JrZXInXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBpZ25vcmVFcnJvclByb3BlcnRpZXMgPSBpc0lFKCkgPyBbeyB0YXJnZXQ6IGludGVybmFsV2luZG93LCBpZ25vcmVQcm9wZXJ0aWVzOiBbJ2Vycm9yJ10gfV0gOiBbXTtcbiAgICAgICAgLy8gaW4gSUUvRWRnZSwgb25Qcm9wIG5vdCBleGlzdCBpbiB3aW5kb3cgb2JqZWN0LCBidXQgaW4gV2luZG93UHJvdG90eXBlXG4gICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gcGFzcyBXaW5kb3dQcm90b3R5cGUgdG8gY2hlY2sgb25Qcm9wIGV4aXN0IG9yIG5vdFxuICAgICAgICBwYXRjaEZpbHRlcmVkUHJvcGVydGllcyhpbnRlcm5hbFdpbmRvdywgZ2V0T25FdmVudE5hbWVzKGludGVybmFsV2luZG93KSwgaWdub3JlUHJvcGVydGllcyA/IGlnbm9yZVByb3BlcnRpZXMuY29uY2F0KGlnbm9yZUVycm9yUHJvcGVydGllcykgOiBpZ25vcmVQcm9wZXJ0aWVzLCBPYmplY3RHZXRQcm90b3R5cGVPZihpbnRlcm5hbFdpbmRvdykpO1xuICAgIH1cbiAgICBwYXRjaFRhcmdldHMgPSBwYXRjaFRhcmdldHMuY29uY2F0KFtcbiAgICAgICAgJ1hNTEh0dHBSZXF1ZXN0JywgJ1hNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQnLCAnSURCSW5kZXgnLCAnSURCUmVxdWVzdCcsICdJREJPcGVuREJSZXF1ZXN0JyxcbiAgICAgICAgJ0lEQkRhdGFiYXNlJywgJ0lEQlRyYW5zYWN0aW9uJywgJ0lEQkN1cnNvcicsICdXZWJTb2NrZXQnXG4gICAgXSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRjaFRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gX2dsb2JhbFtwYXRjaFRhcmdldHNbaV1dO1xuICAgICAgICB0YXJnZXQgJiYgdGFyZ2V0LnByb3RvdHlwZSAmJlxuICAgICAgICAgICAgcGF0Y2hGaWx0ZXJlZFByb3BlcnRpZXModGFyZ2V0LnByb3RvdHlwZSwgZ2V0T25FdmVudE5hbWVzKHRhcmdldC5wcm90b3R5cGUpLCBpZ25vcmVQcm9wZXJ0aWVzKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuWm9uZS5fX2xvYWRfcGF0Y2goJ3V0aWwnLCAoZ2xvYmFsLCBab25lLCBhcGkpID0+IHtcbiAgICAvLyBDb2xsZWN0IG5hdGl2ZSBldmVudCBuYW1lcyBieSBsb29raW5nIGF0IHByb3BlcnRpZXNcbiAgICAvLyBvbiB0aGUgZ2xvYmFsIG5hbWVzcGFjZSwgZS5nLiAnb25jbGljaycuXG4gICAgY29uc3QgZXZlbnROYW1lcyA9IGdldE9uRXZlbnROYW1lcyhnbG9iYWwpO1xuICAgIGFwaS5wYXRjaE9uUHJvcGVydGllcyA9IHBhdGNoT25Qcm9wZXJ0aWVzO1xuICAgIGFwaS5wYXRjaE1ldGhvZCA9IHBhdGNoTWV0aG9kO1xuICAgIGFwaS5iaW5kQXJndW1lbnRzID0gYmluZEFyZ3VtZW50cztcbiAgICBhcGkucGF0Y2hNYWNyb1Rhc2sgPSBwYXRjaE1hY3JvVGFzaztcbiAgICAvLyBJbiBlYXJsaWVyIHZlcnNpb24gb2Ygem9uZS5qcyAoPDAuOS4wKSwgd2UgdXNlIGVudiBuYW1lIGBfX3pvbmVfc3ltYm9sX19CTEFDS19MSVNURURfRVZFTlRTYCB0b1xuICAgIC8vIGRlZmluZSB3aGljaCBldmVudHMgd2lsbCBub3QgYmUgcGF0Y2hlZCBieSBgWm9uZS5qc2AuXG4gICAgLy8gSW4gbmV3ZXIgdmVyc2lvbiAoPj0wLjkuMCksIHdlIGNoYW5nZSB0aGUgZW52IG5hbWUgdG8gYF9fem9uZV9zeW1ib2xfX1VOUEFUQ0hFRF9FVkVOVFNgIHRvIGtlZXBcbiAgICAvLyB0aGUgbmFtZSBjb25zaXN0ZW50IHdpdGggYW5ndWxhciByZXBvLlxuICAgIC8vIFRoZSAgYF9fem9uZV9zeW1ib2xfX0JMQUNLX0xJU1RFRF9FVkVOVFNgIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdCBpcyBzdGlsbCBiZSBzdXBwb3J0ZWQgZm9yXG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgY29uc3QgU1lNQk9MX0JMQUNLX0xJU1RFRF9FVkVOVFMgPSBab25lLl9fc3ltYm9sX18oJ0JMQUNLX0xJU1RFRF9FVkVOVFMnKTtcbiAgICBjb25zdCBTWU1CT0xfVU5QQVRDSEVEX0VWRU5UUyA9IFpvbmUuX19zeW1ib2xfXygnVU5QQVRDSEVEX0VWRU5UUycpO1xuICAgIGlmIChnbG9iYWxbU1lNQk9MX1VOUEFUQ0hFRF9FVkVOVFNdKSB7XG4gICAgICAgIGdsb2JhbFtTWU1CT0xfQkxBQ0tfTElTVEVEX0VWRU5UU10gPSBnbG9iYWxbU1lNQk9MX1VOUEFUQ0hFRF9FVkVOVFNdO1xuICAgIH1cbiAgICBpZiAoZ2xvYmFsW1NZTUJPTF9CTEFDS19MSVNURURfRVZFTlRTXSkge1xuICAgICAgICBab25lW1NZTUJPTF9CTEFDS19MSVNURURfRVZFTlRTXSA9IFpvbmVbU1lNQk9MX1VOUEFUQ0hFRF9FVkVOVFNdID1cbiAgICAgICAgICAgIGdsb2JhbFtTWU1CT0xfQkxBQ0tfTElTVEVEX0VWRU5UU107XG4gICAgfVxuICAgIGFwaS5wYXRjaEV2ZW50UHJvdG90eXBlID0gcGF0Y2hFdmVudFByb3RvdHlwZTtcbiAgICBhcGkucGF0Y2hFdmVudFRhcmdldCA9IHBhdGNoRXZlbnRUYXJnZXQ7XG4gICAgYXBpLmlzSUVPckVkZ2UgPSBpc0lFT3JFZGdlO1xuICAgIGFwaS5PYmplY3REZWZpbmVQcm9wZXJ0eSA9IE9iamVjdERlZmluZVByb3BlcnR5O1xuICAgIGFwaS5PYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgYXBpLk9iamVjdENyZWF0ZSA9IE9iamVjdENyZWF0ZTtcbiAgICBhcGkuQXJyYXlTbGljZSA9IEFycmF5U2xpY2U7XG4gICAgYXBpLnBhdGNoQ2xhc3MgPSBwYXRjaENsYXNzO1xuICAgIGFwaS53cmFwV2l0aEN1cnJlbnRab25lID0gd3JhcFdpdGhDdXJyZW50Wm9uZTtcbiAgICBhcGkuZmlsdGVyUHJvcGVydGllcyA9IGZpbHRlclByb3BlcnRpZXM7XG4gICAgYXBpLmF0dGFjaE9yaWdpblRvUGF0Y2hlZCA9IGF0dGFjaE9yaWdpblRvUGF0Y2hlZDtcbiAgICBhcGkuX3JlZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gICAgYXBpLnBhdGNoQ2FsbGJhY2tzID0gcGF0Y2hDYWxsYmFja3M7XG4gICAgYXBpLmdldEdsb2JhbE9iamVjdHMgPSAoKSA9PiAoe1xuICAgICAgICBnbG9iYWxTb3VyY2VzLFxuICAgICAgICB6b25lU3ltYm9sRXZlbnROYW1lcyxcbiAgICAgICAgZXZlbnROYW1lcyxcbiAgICAgICAgaXNCcm93c2VyLFxuICAgICAgICBpc01peCxcbiAgICAgICAgaXNOb2RlLFxuICAgICAgICBUUlVFX1NUUixcbiAgICAgICAgRkFMU0VfU1RSLFxuICAgICAgICBaT05FX1NZTUJPTF9QUkVGSVgsXG4gICAgICAgIEFERF9FVkVOVF9MSVNURU5FUl9TVFIsXG4gICAgICAgIFJFTU9WRV9FVkVOVF9MSVNURU5FUl9TVFJcbiAgICB9KTtcbn0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNvbnN0IHRhc2tTeW1ib2wgPSB6b25lU3ltYm9sKCd6b25lVGFzaycpO1xuZnVuY3Rpb24gcGF0Y2hUaW1lcih3aW5kb3csIHNldE5hbWUsIGNhbmNlbE5hbWUsIG5hbWVTdWZmaXgpIHtcbiAgICBsZXQgc2V0TmF0aXZlID0gbnVsbDtcbiAgICBsZXQgY2xlYXJOYXRpdmUgPSBudWxsO1xuICAgIHNldE5hbWUgKz0gbmFtZVN1ZmZpeDtcbiAgICBjYW5jZWxOYW1lICs9IG5hbWVTdWZmaXg7XG4gICAgY29uc3QgdGFza3NCeUhhbmRsZUlkID0ge307XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVUYXNrKHRhc2spIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRhc2suZGF0YTtcbiAgICAgICAgZGF0YS5hcmdzWzBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhc2suaW52b2tlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIGRhdGEuaGFuZGxlSWQgPSBzZXROYXRpdmUuYXBwbHkod2luZG93LCBkYXRhLmFyZ3MpO1xuICAgICAgICByZXR1cm4gdGFzaztcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYXJUYXNrKHRhc2spIHtcbiAgICAgICAgcmV0dXJuIGNsZWFyTmF0aXZlLmNhbGwod2luZG93LCB0YXNrLmRhdGEuaGFuZGxlSWQpO1xuICAgIH1cbiAgICBzZXROYXRpdmUgPVxuICAgICAgICBwYXRjaE1ldGhvZCh3aW5kb3csIHNldE5hbWUsIChkZWxlZ2F0ZSkgPT4gZnVuY3Rpb24gKHNlbGYsIGFyZ3MpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlzUGVyaW9kaWM6IG5hbWVTdWZmaXggPT09ICdJbnRlcnZhbCcsXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5OiAobmFtZVN1ZmZpeCA9PT0gJ1RpbWVvdXQnIHx8IG5hbWVTdWZmaXggPT09ICdJbnRlcnZhbCcpID8gYXJnc1sxXSB8fCAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGFyZ3NbMF0gPSBmdW5jdGlvbiB0aW1lcigpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXNzdWUtOTM0LCB0YXNrIHdpbGwgYmUgY2FuY2VsbGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBldmVuIGl0IGlzIGEgcGVyaW9kaWMgdGFzayBzdWNoIGFzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXRJbnRlcnZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvNDAzODdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsZWFudXAgdGFza3NCeUhhbmRsZUlkIHNob3VsZCBiZSBoYW5kbGVkIGJlZm9yZSBzY2hlZHVsZVRhc2tcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHNvbWUgem9uZVNwZWMgbWF5IGludGVyY2VwdCBhbmQgZG9lc24ndCB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzY2hlZHVsZUZuKHNjaGVkdWxlVGFzaykgcHJvdmlkZWQgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG9wdGlvbnMuaXNQZXJpb2RpYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuaGFuZGxlSWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIG5vbi1ub2RlanMgZW52LCB3ZSByZW1vdmUgdGltZXJJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIGxvY2FsIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlSWRbb3B0aW9ucy5oYW5kbGVJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaGFuZGxlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9kZSByZXR1cm5zIGNvbXBsZXggb2JqZWN0cyBhcyBoYW5kbGVJZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgcmVtb3ZlIHRhc2sgcmVmZXJlbmNlIGZyb20gdGltZXIgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaGFuZGxlSWRbdGFza1N5bWJvbF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFzayA9IHNjaGVkdWxlTWFjcm9UYXNrV2l0aEN1cnJlbnRab25lKHNldE5hbWUsIGFyZ3NbMF0sIG9wdGlvbnMsIHNjaGVkdWxlVGFzaywgY2xlYXJUYXNrKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE5vZGUuanMgbXVzdCBhZGRpdGlvbmFsbHkgc3VwcG9ydCB0aGUgcmVmIGFuZCB1bnJlZiBmdW5jdGlvbnMuXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gdGFzay5kYXRhLmhhbmRsZUlkO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3Igbm9uIG5vZGVqcyBlbnYsIHdlIHNhdmUgaGFuZGxlSWQ6IHRhc2tcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFwcGluZyBpbiBsb2NhbCBjYWNoZSBmb3IgY2xlYXJUaW1lb3V0XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzQnlIYW5kbGVJZFtoYW5kbGVdID0gdGFzaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBub2RlanMgZW52LCB3ZSBzYXZlIHRhc2tcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVmZXJlbmNlIGluIHRpbWVySWQgT2JqZWN0IGZvciBjbGVhclRpbWVvdXRcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlW3Rhc2tTeW1ib2xdID0gdGFzaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgd2hldGhlciBoYW5kbGUgaXMgbnVsbCwgYmVjYXVzZSBzb21lIHBvbHlmaWxsIG9yIGJyb3dzZXJcbiAgICAgICAgICAgICAgICAvLyBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmcm9tIHNldFRpbWVvdXQvc2V0SW50ZXJ2YWwvc2V0SW1tZWRpYXRlL3JlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGUgJiYgaGFuZGxlLnJlZiAmJiBoYW5kbGUudW5yZWYgJiYgdHlwZW9mIGhhbmRsZS5yZWYgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGhhbmRsZS51bnJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnJlZiA9IGhhbmRsZS5yZWYuYmluZChoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnVucmVmID0gaGFuZGxlLnVucmVmLmJpbmQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGUgPT09ICdudW1iZXInIHx8IGhhbmRsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFzaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNhdXNlIGFuIGVycm9yIGJ5IGNhbGxpbmcgaXQgZGlyZWN0bHkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmFwcGx5KHdpbmRvdywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIGNsZWFyTmF0aXZlID1cbiAgICAgICAgcGF0Y2hNZXRob2Qod2luZG93LCBjYW5jZWxOYW1lLCAoZGVsZWdhdGUpID0+IGZ1bmN0aW9uIChzZWxmLCBhcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGFyZ3NbMF07XG4gICAgICAgICAgICBsZXQgdGFzaztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gbm9uIG5vZGVqcyBlbnYuXG4gICAgICAgICAgICAgICAgdGFzayA9IHRhc2tzQnlIYW5kbGVJZFtpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBub2RlanMgZW52LlxuICAgICAgICAgICAgICAgIHRhc2sgPSBpZCAmJiBpZFt0YXNrU3ltYm9sXTtcbiAgICAgICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICAgICAgaWYgKCF0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sgPSBpZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFzayAmJiB0eXBlb2YgdGFzay50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICh0YXNrLnN0YXRlICE9PSAnbm90U2NoZWR1bGVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAodGFzay5jYW5jZWxGbiAmJiB0YXNrLmRhdGEuaXNQZXJpb2RpYyB8fCB0YXNrLnJ1bkNvdW50ID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlkID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVJZFtpZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkW3Rhc2tTeW1ib2xdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgY2FuY2VsIGFscmVhZHkgY2FuY2VsZWQgZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIHRhc2suem9uZS5jYW5jZWxUYXNrKHRhc2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNhdXNlIGFuIGVycm9yIGJ5IGNhbGxpbmcgaXQgZGlyZWN0bHkuXG4gICAgICAgICAgICAgICAgZGVsZWdhdGUuYXBwbHkod2luZG93LCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gcGF0Y2hDdXN0b21FbGVtZW50cyhfZ2xvYmFsLCBhcGkpIHtcbiAgICBjb25zdCB7IGlzQnJvd3NlciwgaXNNaXggfSA9IGFwaS5nZXRHbG9iYWxPYmplY3RzKCk7XG4gICAgaWYgKCghaXNCcm93c2VyICYmICFpc01peCkgfHwgIV9nbG9iYWxbJ2N1c3RvbUVsZW1lbnRzJ10gfHwgISgnY3VzdG9tRWxlbWVudHMnIGluIF9nbG9iYWwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2FsbGJhY2tzID0gWydjb25uZWN0ZWRDYWxsYmFjaycsICdkaXNjb25uZWN0ZWRDYWxsYmFjaycsICdhZG9wdGVkQ2FsbGJhY2snLCAnYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJ107XG4gICAgYXBpLnBhdGNoQ2FsbGJhY2tzKGFwaSwgX2dsb2JhbC5jdXN0b21FbGVtZW50cywgJ2N1c3RvbUVsZW1lbnRzJywgJ2RlZmluZScsIGNhbGxiYWNrcyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gZXZlbnRUYXJnZXRQYXRjaChfZ2xvYmFsLCBhcGkpIHtcbiAgICBpZiAoWm9uZVthcGkuc3ltYm9sKCdwYXRjaEV2ZW50VGFyZ2V0JyldKSB7XG4gICAgICAgIC8vIEV2ZW50VGFyZ2V0IGlzIGFscmVhZHkgcGF0Y2hlZC5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGV2ZW50TmFtZXMsIHpvbmVTeW1ib2xFdmVudE5hbWVzLCBUUlVFX1NUUiwgRkFMU0VfU1RSLCBaT05FX1NZTUJPTF9QUkVGSVggfSA9IGFwaS5nZXRHbG9iYWxPYmplY3RzKCk7XG4gICAgLy8gIHByZWRlZmluZSBhbGwgX196b25lX3N5bWJvbF9fICsgZXZlbnROYW1lICsgdHJ1ZS9mYWxzZSBzdHJpbmdcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZXZlbnROYW1lID0gZXZlbnROYW1lc1tpXTtcbiAgICAgICAgY29uc3QgZmFsc2VFdmVudE5hbWUgPSBldmVudE5hbWUgKyBGQUxTRV9TVFI7XG4gICAgICAgIGNvbnN0IHRydWVFdmVudE5hbWUgPSBldmVudE5hbWUgKyBUUlVFX1NUUjtcbiAgICAgICAgY29uc3Qgc3ltYm9sID0gWk9ORV9TWU1CT0xfUFJFRklYICsgZmFsc2VFdmVudE5hbWU7XG4gICAgICAgIGNvbnN0IHN5bWJvbENhcHR1cmUgPSBaT05FX1NZTUJPTF9QUkVGSVggKyB0cnVlRXZlbnROYW1lO1xuICAgICAgICB6b25lU3ltYm9sRXZlbnROYW1lc1tldmVudE5hbWVdID0ge307XG4gICAgICAgIHpvbmVTeW1ib2xFdmVudE5hbWVzW2V2ZW50TmFtZV1bRkFMU0VfU1RSXSA9IHN5bWJvbDtcbiAgICAgICAgem9uZVN5bWJvbEV2ZW50TmFtZXNbZXZlbnROYW1lXVtUUlVFX1NUUl0gPSBzeW1ib2xDYXB0dXJlO1xuICAgIH1cbiAgICBjb25zdCBFVkVOVF9UQVJHRVQgPSBfZ2xvYmFsWydFdmVudFRhcmdldCddO1xuICAgIGlmICghRVZFTlRfVEFSR0VUIHx8ICFFVkVOVF9UQVJHRVQucHJvdG90eXBlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXBpLnBhdGNoRXZlbnRUYXJnZXQoX2dsb2JhbCwgYXBpLCBbRVZFTlRfVEFSR0VUICYmIEVWRU5UX1RBUkdFVC5wcm90b3R5cGVdKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHBhdGNoRXZlbnQoZ2xvYmFsLCBhcGkpIHtcbiAgICBhcGkucGF0Y2hFdmVudFByb3RvdHlwZShnbG9iYWwsIGFwaSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuWm9uZS5fX2xvYWRfcGF0Y2goJ2xlZ2FjeScsIChnbG9iYWwpID0+IHtcbiAgICBjb25zdCBsZWdhY3lQYXRjaCA9IGdsb2JhbFtab25lLl9fc3ltYm9sX18oJ2xlZ2FjeVBhdGNoJyldO1xuICAgIGlmIChsZWdhY3lQYXRjaCkge1xuICAgICAgICBsZWdhY3lQYXRjaCgpO1xuICAgIH1cbn0pO1xuWm9uZS5fX2xvYWRfcGF0Y2goJ3F1ZXVlTWljcm90YXNrJywgKGdsb2JhbCwgWm9uZSwgYXBpKSA9PiB7XG4gICAgYXBpLnBhdGNoTWV0aG9kKGdsb2JhbCwgJ3F1ZXVlTWljcm90YXNrJywgZGVsZWdhdGUgPT4ge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGYsIGFyZ3MpIHtcbiAgICAgICAgICAgIFpvbmUuY3VycmVudC5zY2hlZHVsZU1pY3JvVGFzaygncXVldWVNaWNyb3Rhc2snLCBhcmdzWzBdKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbn0pO1xuWm9uZS5fX2xvYWRfcGF0Y2goJ3RpbWVycycsIChnbG9iYWwpID0+IHtcbiAgICBjb25zdCBzZXQgPSAnc2V0JztcbiAgICBjb25zdCBjbGVhciA9ICdjbGVhcic7XG4gICAgcGF0Y2hUaW1lcihnbG9iYWwsIHNldCwgY2xlYXIsICdUaW1lb3V0Jyk7XG4gICAgcGF0Y2hUaW1lcihnbG9iYWwsIHNldCwgY2xlYXIsICdJbnRlcnZhbCcpO1xuICAgIHBhdGNoVGltZXIoZ2xvYmFsLCBzZXQsIGNsZWFyLCAnSW1tZWRpYXRlJyk7XG59KTtcblpvbmUuX19sb2FkX3BhdGNoKCdyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnLCAoZ2xvYmFsKSA9PiB7XG4gICAgcGF0Y2hUaW1lcihnbG9iYWwsICdyZXF1ZXN0JywgJ2NhbmNlbCcsICdBbmltYXRpb25GcmFtZScpO1xuICAgIHBhdGNoVGltZXIoZ2xvYmFsLCAnbW96UmVxdWVzdCcsICdtb3pDYW5jZWwnLCAnQW5pbWF0aW9uRnJhbWUnKTtcbiAgICBwYXRjaFRpbWVyKGdsb2JhbCwgJ3dlYmtpdFJlcXVlc3QnLCAnd2Via2l0Q2FuY2VsJywgJ0FuaW1hdGlvbkZyYW1lJyk7XG59KTtcblpvbmUuX19sb2FkX3BhdGNoKCdibG9ja2luZycsIChnbG9iYWwsIFpvbmUpID0+IHtcbiAgICBjb25zdCBibG9ja2luZ01ldGhvZHMgPSBbJ2FsZXJ0JywgJ3Byb21wdCcsICdjb25maXJtJ107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja2luZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGJsb2NraW5nTWV0aG9kc1tpXTtcbiAgICAgICAgcGF0Y2hNZXRob2QoZ2xvYmFsLCBuYW1lLCAoZGVsZWdhdGUsIHN5bWJvbCwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvbmUuY3VycmVudC5ydW4oZGVsZWdhdGUsIGdsb2JhbCwgYXJncywgbmFtZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblpvbmUuX19sb2FkX3BhdGNoKCdFdmVudFRhcmdldCcsIChnbG9iYWwsIFpvbmUsIGFwaSkgPT4ge1xuICAgIHBhdGNoRXZlbnQoZ2xvYmFsLCBhcGkpO1xuICAgIGV2ZW50VGFyZ2V0UGF0Y2goZ2xvYmFsLCBhcGkpO1xuICAgIC8vIHBhdGNoIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQncyBhZGRFdmVudExpc3RlbmVyL3JlbW92ZUV2ZW50TGlzdGVuZXJcbiAgICBjb25zdCBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0ID0gZ2xvYmFsWydYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0J107XG4gICAgaWYgKFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQgJiYgWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgYXBpLnBhdGNoRXZlbnRUYXJnZXQoZ2xvYmFsLCBhcGksIFtYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZV0pO1xuICAgIH1cbn0pO1xuWm9uZS5fX2xvYWRfcGF0Y2goJ011dGF0aW9uT2JzZXJ2ZXInLCAoZ2xvYmFsLCBab25lLCBhcGkpID0+IHtcbiAgICBwYXRjaENsYXNzKCdNdXRhdGlvbk9ic2VydmVyJyk7XG4gICAgcGF0Y2hDbGFzcygnV2ViS2l0TXV0YXRpb25PYnNlcnZlcicpO1xufSk7XG5ab25lLl9fbG9hZF9wYXRjaCgnSW50ZXJzZWN0aW9uT2JzZXJ2ZXInLCAoZ2xvYmFsLCBab25lLCBhcGkpID0+IHtcbiAgICBwYXRjaENsYXNzKCdJbnRlcnNlY3Rpb25PYnNlcnZlcicpO1xufSk7XG5ab25lLl9fbG9hZF9wYXRjaCgnRmlsZVJlYWRlcicsIChnbG9iYWwsIFpvbmUsIGFwaSkgPT4ge1xuICAgIHBhdGNoQ2xhc3MoJ0ZpbGVSZWFkZXInKTtcbn0pO1xuWm9uZS5fX2xvYWRfcGF0Y2goJ29uX3Byb3BlcnR5JywgKGdsb2JhbCwgWm9uZSwgYXBpKSA9PiB7XG4gICAgcHJvcGVydHlEZXNjcmlwdG9yUGF0Y2goYXBpLCBnbG9iYWwpO1xufSk7XG5ab25lLl9fbG9hZF9wYXRjaCgnY3VzdG9tRWxlbWVudHMnLCAoZ2xvYmFsLCBab25lLCBhcGkpID0+IHtcbiAgICBwYXRjaEN1c3RvbUVsZW1lbnRzKGdsb2JhbCwgYXBpKTtcbn0pO1xuWm9uZS5fX2xvYWRfcGF0Y2goJ1hIUicsIChnbG9iYWwsIFpvbmUpID0+IHtcbiAgICAvLyBUcmVhdCBYTUxIdHRwUmVxdWVzdCBhcyBhIG1hY3JvdGFzay5cbiAgICBwYXRjaFhIUihnbG9iYWwpO1xuICAgIGNvbnN0IFhIUl9UQVNLID0gem9uZVN5bWJvbCgneGhyVGFzaycpO1xuICAgIGNvbnN0IFhIUl9TWU5DID0gem9uZVN5bWJvbCgneGhyU3luYycpO1xuICAgIGNvbnN0IFhIUl9MSVNURU5FUiA9IHpvbmVTeW1ib2woJ3hockxpc3RlbmVyJyk7XG4gICAgY29uc3QgWEhSX1NDSEVEVUxFRCA9IHpvbmVTeW1ib2woJ3hoclNjaGVkdWxlZCcpO1xuICAgIGNvbnN0IFhIUl9VUkwgPSB6b25lU3ltYm9sKCd4aHJVUkwnKTtcbiAgICBjb25zdCBYSFJfRVJST1JfQkVGT1JFX1NDSEVEVUxFRCA9IHpvbmVTeW1ib2woJ3hockVycm9yQmVmb3JlU2NoZWR1bGVkJyk7XG4gICAgZnVuY3Rpb24gcGF0Y2hYSFIod2luZG93KSB7XG4gICAgICAgIGNvbnN0IFhNTEh0dHBSZXF1ZXN0ID0gd2luZG93WydYTUxIdHRwUmVxdWVzdCddO1xuICAgICAgICBpZiAoIVhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgICAgICAvLyBYTUxIdHRwUmVxdWVzdCBpcyBub3QgYXZhaWxhYmxlIGluIHNlcnZpY2Ugd29ya2VyXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgWE1MSHR0cFJlcXVlc3RQcm90b3R5cGUgPSBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGU7XG4gICAgICAgIGZ1bmN0aW9uIGZpbmRQZW5kaW5nVGFzayh0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRbWEhSX1RBU0tdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcmlBZGRMaXN0ZW5lciA9IFhNTEh0dHBSZXF1ZXN0UHJvdG90eXBlW1pPTkVfU1lNQk9MX0FERF9FVkVOVF9MSVNURU5FUl07XG4gICAgICAgIGxldCBvcmlSZW1vdmVMaXN0ZW5lciA9IFhNTEh0dHBSZXF1ZXN0UHJvdG90eXBlW1pPTkVfU1lNQk9MX1JFTU9WRV9FVkVOVF9MSVNURU5FUl07XG4gICAgICAgIGlmICghb3JpQWRkTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQgPSB3aW5kb3dbJ1hNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQnXTtcbiAgICAgICAgICAgIGlmIChYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldFByb3RvdHlwZSA9IFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQucHJvdG90eXBlO1xuICAgICAgICAgICAgICAgIG9yaUFkZExpc3RlbmVyID0gWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldFByb3RvdHlwZVtaT05FX1NZTUJPTF9BRERfRVZFTlRfTElTVEVORVJdO1xuICAgICAgICAgICAgICAgIG9yaVJlbW92ZUxpc3RlbmVyID0gWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldFByb3RvdHlwZVtaT05FX1NZTUJPTF9SRU1PVkVfRVZFTlRfTElTVEVORVJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFJFQURZX1NUQVRFX0NIQU5HRSA9ICdyZWFkeXN0YXRlY2hhbmdlJztcbiAgICAgICAgY29uc3QgU0NIRURVTEVEID0gJ3NjaGVkdWxlZCc7XG4gICAgICAgIGZ1bmN0aW9uIHNjaGVkdWxlVGFzayh0YXNrKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdGFzay5kYXRhO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZGF0YS50YXJnZXQ7XG4gICAgICAgICAgICB0YXJnZXRbWEhSX1NDSEVEVUxFRF0gPSBmYWxzZTtcbiAgICAgICAgICAgIHRhcmdldFtYSFJfRVJST1JfQkVGT1JFX1NDSEVEVUxFRF0gPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBleGlzdGluZyBldmVudCBsaXN0ZW5lclxuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSB0YXJnZXRbWEhSX0xJU1RFTkVSXTtcbiAgICAgICAgICAgIGlmICghb3JpQWRkTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBvcmlBZGRMaXN0ZW5lciA9IHRhcmdldFtaT05FX1NZTUJPTF9BRERfRVZFTlRfTElTVEVORVJdO1xuICAgICAgICAgICAgICAgIG9yaVJlbW92ZUxpc3RlbmVyID0gdGFyZ2V0W1pPTkVfU1lNQk9MX1JFTU9WRV9FVkVOVF9MSVNURU5FUl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBvcmlSZW1vdmVMaXN0ZW5lci5jYWxsKHRhcmdldCwgUkVBRFlfU1RBVEVfQ0hBTkdFLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdMaXN0ZW5lciA9IHRhcmdldFtYSFJfTElTVEVORVJdID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQucmVhZHlTdGF0ZSA9PT0gdGFyZ2V0LkRPTkUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc29tZXRpbWVzIG9uIHNvbWUgYnJvd3NlcnMgWE1MSHR0cFJlcXVlc3Qgd2lsbCBmaXJlIG9ucmVhZHlzdGF0ZWNoYW5nZSB3aXRoXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWR5U3RhdGU9NCBtdWx0aXBsZSB0aW1lcywgc28gd2UgbmVlZCB0byBjaGVjayB0YXNrIHN0YXRlIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLmFib3J0ZWQgJiYgdGFyZ2V0W1hIUl9TQ0hFRFVMRURdICYmIHRhc2suc3RhdGUgPT09IFNDSEVEVUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgeGhyIGhhcyByZWdpc3RlcmVkIG9ubG9hZCBsaXN0ZW5lclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhhdCBpcyB0aGUgY2FzZSwgdGhlIHRhc2sgc2hvdWxkIGludm9rZSBhZnRlciBhbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubG9hZCBsaXN0ZW5lcnMgZmluaXNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxzbyBpZiB0aGUgcmVxdWVzdCBmYWlsZWQgd2l0aG91dCByZXNwb25zZSAoc3RhdHVzID0gMCksIHRoZSBsb2FkIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgbm90IGJlIHRyaWdnZXJlZCwgaW4gdGhhdCBjYXNlLCB3ZSBzaG91bGQgYWxzbyBpbnZva2UgdGhlIHBsYWNlaG9sZGVyIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBjbG9zZSB0aGUgWE1MSHR0cFJlcXVlc3Q6OnNlbmQgbWFjcm9UYXNrLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMzg3OTVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRUYXNrcyA9IHRhcmdldFtab25lLl9fc3ltYm9sX18oJ2xvYWRmYWxzZScpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuc3RhdHVzICE9PSAwICYmIGxvYWRUYXNrcyAmJiBsb2FkVGFza3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaUludm9rZSA9IHRhc2suaW52b2tlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suaW52b2tlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGxvYWQgdGhlIHRhc2tzIGFnYWluLCBiZWNhdXNlIGluIG90aGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvYWQgbGlzdGVuZXIsIHRoZXkgbWF5IHJlbW92ZSB0aGVtc2VsdmVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRUYXNrcyA9IHRhcmdldFtab25lLl9fc3ltYm9sX18oJ2xvYWRmYWxzZScpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2FkVGFza3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2FkVGFza3NbaV0gPT09IHRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkVGFza3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGF0YS5hYm9ydGVkICYmIHRhc2suc3RhdGUgPT09IFNDSEVEVUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpSW52b2tlLmNhbGwodGFzayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRUYXNrcy5wdXNoKHRhc2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5pbnZva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghZGF0YS5hYm9ydGVkICYmIHRhcmdldFtYSFJfU0NIRURVTEVEXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVycm9yIG9jY3VycyB3aGVuIHhoci5zZW5kKClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtYSFJfRVJST1JfQkVGT1JFX1NDSEVEVUxFRF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9yaUFkZExpc3RlbmVyLmNhbGwodGFyZ2V0LCBSRUFEWV9TVEFURV9DSEFOR0UsIG5ld0xpc3RlbmVyKTtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZFRhc2sgPSB0YXJnZXRbWEhSX1RBU0tdO1xuICAgICAgICAgICAgaWYgKCFzdG9yZWRUYXNrKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W1hIUl9UQVNLXSA9IHRhc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZW5kTmF0aXZlLmFwcGx5KHRhcmdldCwgZGF0YS5hcmdzKTtcbiAgICAgICAgICAgIHRhcmdldFtYSFJfU0NIRURVTEVEXSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGFzaztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwbGFjZWhvbGRlckNhbGxiYWNrKCkgeyB9XG4gICAgICAgIGZ1bmN0aW9uIGNsZWFyVGFzayh0YXNrKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdGFzay5kYXRhO1xuICAgICAgICAgICAgLy8gTm90ZSAtIGlkZWFsbHksIHdlIHdvdWxkIGNhbGwgZGF0YS50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciBoZXJlLCBidXQgaXQncyB0b28gbGF0ZVxuICAgICAgICAgICAgLy8gdG8gcHJldmVudCBpdCBmcm9tIGZpcmluZy4gU28gaW5zdGVhZCwgd2Ugc3RvcmUgaW5mbyBmb3IgdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICAgICAgZGF0YS5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBhYm9ydE5hdGl2ZS5hcHBseShkYXRhLnRhcmdldCwgZGF0YS5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcGVuTmF0aXZlID0gcGF0Y2hNZXRob2QoWE1MSHR0cFJlcXVlc3RQcm90b3R5cGUsICdvcGVuJywgKCkgPT4gZnVuY3Rpb24gKHNlbGYsIGFyZ3MpIHtcbiAgICAgICAgICAgIHNlbGZbWEhSX1NZTkNdID0gYXJnc1syXSA9PSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGZbWEhSX1VSTF0gPSBhcmdzWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG9wZW5OYXRpdmUuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBYTUxIVFRQUkVRVUVTVF9TT1VSQ0UgPSAnWE1MSHR0cFJlcXVlc3Quc2VuZCc7XG4gICAgICAgIGNvbnN0IGZldGNoVGFza0Fib3J0aW5nID0gem9uZVN5bWJvbCgnZmV0Y2hUYXNrQWJvcnRpbmcnKTtcbiAgICAgICAgY29uc3QgZmV0Y2hUYXNrU2NoZWR1bGluZyA9IHpvbmVTeW1ib2woJ2ZldGNoVGFza1NjaGVkdWxpbmcnKTtcbiAgICAgICAgY29uc3Qgc2VuZE5hdGl2ZSA9IHBhdGNoTWV0aG9kKFhNTEh0dHBSZXF1ZXN0UHJvdG90eXBlLCAnc2VuZCcsICgpID0+IGZ1bmN0aW9uIChzZWxmLCBhcmdzKSB7XG4gICAgICAgICAgICBpZiAoWm9uZS5jdXJyZW50W2ZldGNoVGFza1NjaGVkdWxpbmddID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gYSBmZXRjaCBpcyBzY2hlZHVsaW5nLCBzbyB3ZSBhcmUgdXNpbmcgeGhyIHRvIHBvbHlmaWxsIGZldGNoXG4gICAgICAgICAgICAgICAgLy8gYW5kIGJlY2F1c2Ugd2UgYWxyZWFkeSBzY2hlZHVsZSBtYWNyb1Rhc2sgZm9yIGZldGNoLCB3ZSBzaG91bGRcbiAgICAgICAgICAgICAgICAvLyBub3Qgc2NoZWR1bGUgYSBtYWNyb1Rhc2sgZm9yIHhociBhZ2FpblxuICAgICAgICAgICAgICAgIHJldHVybiBzZW5kTmF0aXZlLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGZbWEhSX1NZTkNdKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIFhIUiBpcyBzeW5jIHRoZXJlIGlzIG5vIHRhc2sgdG8gc2NoZWR1bGUsIGp1c3QgZXhlY3V0ZSB0aGUgY29kZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VuZE5hdGl2ZS5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IHRhcmdldDogc2VsZiwgdXJsOiBzZWxmW1hIUl9VUkxdLCBpc1BlcmlvZGljOiBmYWxzZSwgYXJnczogYXJncywgYWJvcnRlZDogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXNrID0gc2NoZWR1bGVNYWNyb1Rhc2tXaXRoQ3VycmVudFpvbmUoWE1MSFRUUFJFUVVFU1RfU09VUkNFLCBwbGFjZWhvbGRlckNhbGxiYWNrLCBvcHRpb25zLCBzY2hlZHVsZVRhc2ssIGNsZWFyVGFzayk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYgJiYgc2VsZltYSFJfRVJST1JfQkVGT1JFX1NDSEVEVUxFRF0gPT09IHRydWUgJiYgIW9wdGlvbnMuYWJvcnRlZCAmJlxuICAgICAgICAgICAgICAgICAgICB0YXNrLnN0YXRlID09PSBTQ0hFRFVMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8geGhyIHJlcXVlc3QgdGhyb3cgZXJyb3Igd2hlbiBzZW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHNob3VsZCBpbnZva2UgdGFzayBpbnN0ZWFkIG9mIGxlYXZpbmcgYSBzY2hlZHVsZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gcGVuZGluZyBtYWNyb1Rhc2tcbiAgICAgICAgICAgICAgICAgICAgdGFzay5pbnZva2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhYm9ydE5hdGl2ZSA9IHBhdGNoTWV0aG9kKFhNTEh0dHBSZXF1ZXN0UHJvdG90eXBlLCAnYWJvcnQnLCAoKSA9PiBmdW5jdGlvbiAoc2VsZiwgYXJncykge1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IGZpbmRQZW5kaW5nVGFzayhzZWxmKTtcbiAgICAgICAgICAgIGlmICh0YXNrICYmIHR5cGVvZiB0YXNrLnR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgWEhSIGhhcyBhbHJlYWR5IGNvbXBsZXRlZCwgZG8gbm90aGluZy5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgWEhSIGhhcyBhbHJlYWR5IGJlZW4gYWJvcnRlZCwgZG8gbm90aGluZy5cbiAgICAgICAgICAgICAgICAvLyBGaXggIzU2OSwgY2FsbCBhYm9ydCBtdWx0aXBsZSB0aW1lcyBiZWZvcmUgZG9uZSB3aWxsIGNhdXNlXG4gICAgICAgICAgICAgICAgLy8gbWFjcm9UYXNrIHRhc2sgY291bnQgYmUgbmVnYXRpdmUgbnVtYmVyXG4gICAgICAgICAgICAgICAgaWYgKHRhc2suY2FuY2VsRm4gPT0gbnVsbCB8fCAodGFzay5kYXRhICYmIHRhc2suZGF0YS5hYm9ydGVkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhc2suem9uZS5jYW5jZWxUYXNrKHRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoWm9uZS5jdXJyZW50W2ZldGNoVGFza0Fib3J0aW5nXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBhYm9ydCBpcyBjYWxsZWQgZnJvbSBmZXRjaCBwb2x5ZmlsbCwgd2UgbmVlZCB0byBjYWxsIG5hdGl2ZSBhYm9ydCBvZiBYSFIuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFib3J0TmF0aXZlLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBhcmUgdHJ5aW5nIHRvIGFib3J0IGFuIFhIUiB3aGljaCBoYXMgbm90IHlldCBiZWVuIHNlbnQsIHNvIHRoZXJlIGlzIG5vXG4gICAgICAgICAgICAvLyB0YXNrXG4gICAgICAgICAgICAvLyB0byBjYW5jZWwuIERvIG5vdGhpbmcuXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuWm9uZS5fX2xvYWRfcGF0Y2goJ2dlb2xvY2F0aW9uJywgKGdsb2JhbCkgPT4ge1xuICAgIC8vLyBHRU9fTE9DQVRJT05cbiAgICBpZiAoZ2xvYmFsWyduYXZpZ2F0b3InXSAmJiBnbG9iYWxbJ25hdmlnYXRvciddLmdlb2xvY2F0aW9uKSB7XG4gICAgICAgIHBhdGNoUHJvdG90eXBlKGdsb2JhbFsnbmF2aWdhdG9yJ10uZ2VvbG9jYXRpb24sIFsnZ2V0Q3VycmVudFBvc2l0aW9uJywgJ3dhdGNoUG9zaXRpb24nXSk7XG4gICAgfVxufSk7XG5ab25lLl9fbG9hZF9wYXRjaCgnUHJvbWlzZVJlamVjdGlvbkV2ZW50JywgKGdsb2JhbCwgWm9uZSkgPT4ge1xuICAgIC8vIGhhbmRsZSB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb25cbiAgICBmdW5jdGlvbiBmaW5kUHJvbWlzZVJlamVjdGlvbkhhbmRsZXIoZXZ0TmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50VGFza3MgPSBmaW5kRXZlbnRUYXNrcyhnbG9iYWwsIGV2dE5hbWUpO1xuICAgICAgICAgICAgZXZlbnRUYXNrcy5mb3JFYWNoKGV2ZW50VGFzayA9PiB7XG4gICAgICAgICAgICAgICAgLy8gd2luZG93cyBoYXMgYWRkZWQgdW5oYW5kbGVkcmVqZWN0aW9uIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlciB0aGUgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICBjb25zdCBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPSBnbG9iYWxbJ1Byb21pc2VSZWplY3Rpb25FdmVudCddO1xuICAgICAgICAgICAgICAgIGlmIChQcm9taXNlUmVqZWN0aW9uRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZ0ID0gbmV3IFByb21pc2VSZWplY3Rpb25FdmVudChldnROYW1lLCB7IHByb21pc2U6IGUucHJvbWlzZSwgcmVhc29uOiBlLnJlamVjdGlvbiB9KTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRUYXNrLmludm9rZShldnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoZ2xvYmFsWydQcm9taXNlUmVqZWN0aW9uRXZlbnQnXSkge1xuICAgICAgICBab25lW3pvbmVTeW1ib2woJ3VuaGFuZGxlZFByb21pc2VSZWplY3Rpb25IYW5kbGVyJyldID1cbiAgICAgICAgICAgIGZpbmRQcm9taXNlUmVqZWN0aW9uSGFuZGxlcigndW5oYW5kbGVkcmVqZWN0aW9uJyk7XG4gICAgICAgIFpvbmVbem9uZVN5bWJvbCgncmVqZWN0aW9uSGFuZGxlZEhhbmRsZXInKV0gPVxuICAgICAgICAgICAgZmluZFByb21pc2VSZWplY3Rpb25IYW5kbGVyKCdyZWplY3Rpb25oYW5kbGVkJyk7XG4gICAgfVxufSk7XG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwicGVyZm9ybWFuY2UiLCJtYXJrIiwibmFtZSIsInBlcmZvcm1hbmNlTWVhc3VyZSIsImxhYmVsIiwic3ltYm9sUHJlZml4IiwiX19zeW1ib2xfXyIsImNoZWNrRHVwbGljYXRlIiwiRXJyb3IiLCJab25lIiwiY29uc3RydWN0b3IiLCJwYXJlbnQiLCJ6b25lU3BlYyIsIl9wYXJlbnQiLCJfbmFtZSIsIl9wcm9wZXJ0aWVzIiwicHJvcGVydGllcyIsIl96b25lRGVsZWdhdGUiLCJfWm9uZURlbGVnYXRlIiwiYXNzZXJ0Wm9uZVBhdGNoZWQiLCJwYXRjaGVzIiwicm9vdCIsInpvbmUiLCJjdXJyZW50IiwiX2N1cnJlbnRab25lRnJhbWUiLCJjdXJyZW50VGFzayIsIl9jdXJyZW50VGFzayIsIl9fbG9hZF9wYXRjaCIsImZuIiwiaWdub3JlRHVwbGljYXRlIiwiaGFzT3duUHJvcGVydHkiLCJwZXJmTmFtZSIsIl9hcGkiLCJnZXQiLCJrZXkiLCJnZXRab25lV2l0aCIsImZvcmsiLCJ3cmFwIiwiY2FsbGJhY2siLCJzb3VyY2UiLCJfY2FsbGJhY2siLCJpbnRlcmNlcHQiLCJydW5HdWFyZGVkIiwiYXJndW1lbnRzIiwicnVuIiwiYXBwbHlUaGlzIiwiYXBwbHlBcmdzIiwiaW52b2tlIiwiZXJyb3IiLCJoYW5kbGVFcnJvciIsInJ1blRhc2siLCJ0YXNrIiwiTk9fWk9ORSIsInN0YXRlIiwibm90U2NoZWR1bGVkIiwidHlwZSIsImV2ZW50VGFzayIsIm1hY3JvVGFzayIsInJlRW50cnlHdWFyZCIsInJ1bm5pbmciLCJfdHJhbnNpdGlvblRvIiwic2NoZWR1bGVkIiwicnVuQ291bnQiLCJwcmV2aW91c1Rhc2siLCJkYXRhIiwiaXNQZXJpb2RpYyIsImNhbmNlbEZuIiwidW5kZWZpbmVkIiwiaW52b2tlVGFzayIsInVua25vd24iLCJfdXBkYXRlVGFza0NvdW50Iiwic2NoZWR1bGVUYXNrIiwibmV3Wm9uZSIsInNjaGVkdWxpbmciLCJ6b25lRGVsZWdhdGVzIiwiX3pvbmVEZWxlZ2F0ZXMiLCJfem9uZSIsImVyciIsInNjaGVkdWxlTWljcm9UYXNrIiwiY3VzdG9tU2NoZWR1bGUiLCJab25lVGFzayIsIm1pY3JvVGFzayIsInNjaGVkdWxlTWFjcm9UYXNrIiwiY3VzdG9tQ2FuY2VsIiwic2NoZWR1bGVFdmVudFRhc2siLCJjYW5jZWxUYXNrIiwiY2FuY2VsaW5nIiwiY291bnQiLCJpIiwibGVuZ3RoIiwiREVMRUdBVEVfWlMiLCJvbkhhc1Rhc2siLCJkZWxlZ2F0ZSIsIl8iLCJ0YXJnZXQiLCJoYXNUYXNrU3RhdGUiLCJoYXNUYXNrIiwib25TY2hlZHVsZVRhc2siLCJvbkludm9rZVRhc2siLCJvbkNhbmNlbFRhc2siLCJwYXJlbnREZWxlZ2F0ZSIsIl90YXNrQ291bnRzIiwiX3BhcmVudERlbGVnYXRlIiwiX2ZvcmtaUyIsIm9uRm9yayIsIl9mb3JrRGxndCIsIl9mb3JrQ3VyclpvbmUiLCJfaW50ZXJjZXB0WlMiLCJvbkludGVyY2VwdCIsIl9pbnRlcmNlcHREbGd0IiwiX2ludGVyY2VwdEN1cnJab25lIiwiX2ludm9rZVpTIiwib25JbnZva2UiLCJfaW52b2tlRGxndCIsIl9pbnZva2VDdXJyWm9uZSIsIl9oYW5kbGVFcnJvclpTIiwib25IYW5kbGVFcnJvciIsIl9oYW5kbGVFcnJvckRsZ3QiLCJfaGFuZGxlRXJyb3JDdXJyWm9uZSIsIl9zY2hlZHVsZVRhc2taUyIsIl9zY2hlZHVsZVRhc2tEbGd0IiwiX3NjaGVkdWxlVGFza0N1cnJab25lIiwiX2ludm9rZVRhc2taUyIsIl9pbnZva2VUYXNrRGxndCIsIl9pbnZva2VUYXNrQ3VyclpvbmUiLCJfY2FuY2VsVGFza1pTIiwiX2NhbmNlbFRhc2tEbGd0IiwiX2NhbmNlbFRhc2tDdXJyWm9uZSIsIl9oYXNUYXNrWlMiLCJfaGFzVGFza0RsZ3QiLCJfaGFzVGFza0RsZ3RPd25lciIsIl9oYXNUYXNrQ3VyclpvbmUiLCJ6b25lU3BlY0hhc1Rhc2siLCJwYXJlbnRIYXNUYXNrIiwidGFyZ2V0Wm9uZSIsImFwcGx5IiwicmV0dXJuVGFzayIsInB1c2giLCJzY2hlZHVsZUZuIiwidmFsdWUiLCJpc0VtcHR5IiwiY291bnRzIiwicHJldiIsIm5leHQiLCJjaGFuZ2UiLCJvcHRpb25zIiwiX3N0YXRlIiwic2VsZiIsInVzZUciLCJjYWxsIiwiYXJncyIsIl9udW1iZXJPZk5lc3RlZFRhc2tGcmFtZXMiLCJkcmFpbk1pY3JvVGFza1F1ZXVlIiwiY2FuY2VsU2NoZWR1bGVSZXF1ZXN0IiwidG9TdGF0ZSIsImZyb21TdGF0ZTEiLCJmcm9tU3RhdGUyIiwidG9TdHJpbmciLCJoYW5kbGVJZCIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvSlNPTiIsInN5bWJvbFNldFRpbWVvdXQiLCJzeW1ib2xQcm9taXNlIiwic3ltYm9sVGhlbiIsIl9taWNyb1Rhc2tRdWV1ZSIsIl9pc0RyYWluaW5nTWljcm90YXNrUXVldWUiLCJuYXRpdmVNaWNyb1Rhc2tRdWV1ZVByb21pc2UiLCJuYXRpdmVTY2hlZHVsZU1pY3JvVGFzayIsImZ1bmMiLCJyZXNvbHZlIiwibmF0aXZlVGhlbiIsInF1ZXVlIiwib25VbmhhbmRsZWRFcnJvciIsIm1pY3JvdGFza0RyYWluRG9uZSIsInN5bWJvbCIsImN1cnJlbnRab25lRnJhbWUiLCJub29wIiwic2hvd1VuY2F1Z2h0RXJyb3IiLCJwYXRjaEV2ZW50VGFyZ2V0IiwicGF0Y2hPblByb3BlcnRpZXMiLCJwYXRjaE1ldGhvZCIsImJpbmRBcmd1bWVudHMiLCJwYXRjaFRoZW4iLCJwYXRjaE1hY3JvVGFzayIsInBhdGNoRXZlbnRQcm90b3R5cGUiLCJpc0lFT3JFZGdlIiwiZ2V0R2xvYmFsT2JqZWN0cyIsIk9iamVjdERlZmluZVByb3BlcnR5IiwiT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiT2JqZWN0Q3JlYXRlIiwiQXJyYXlTbGljZSIsInBhdGNoQ2xhc3MiLCJ3cmFwV2l0aEN1cnJlbnRab25lIiwiZmlsdGVyUHJvcGVydGllcyIsImF0dGFjaE9yaWdpblRvUGF0Y2hlZCIsIl9yZWRlZmluZVByb3BlcnR5IiwicGF0Y2hDYWxsYmFja3MiLCJ3aW5kb3ciLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJkZWZpbmVQcm9wZXJ0eSIsIk9iamVjdEdldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJjcmVhdGUiLCJBcnJheSIsInNsaWNlIiwiQUREX0VWRU5UX0xJU1RFTkVSX1NUUiIsIlJFTU9WRV9FVkVOVF9MSVNURU5FUl9TVFIiLCJaT05FX1NZTUJPTF9BRERfRVZFTlRfTElTVEVORVIiLCJaT05FX1NZTUJPTF9SRU1PVkVfRVZFTlRfTElTVEVORVIiLCJUUlVFX1NUUiIsIkZBTFNFX1NUUiIsIlpPTkVfU1lNQk9MX1BSRUZJWCIsInNjaGVkdWxlTWFjcm9UYXNrV2l0aEN1cnJlbnRab25lIiwiem9uZVN5bWJvbCIsImlzV2luZG93RXhpc3RzIiwiaW50ZXJuYWxXaW5kb3ciLCJfZ2xvYmFsIiwiUkVNT1ZFX0FUVFJJQlVURSIsInBhdGNoUHJvdG90eXBlIiwiZm5OYW1lcyIsInByb3RvdHlwZURlc2MiLCJpc1Byb3BlcnR5V3JpdGFibGUiLCJwYXRjaGVkIiwicHJvcGVydHlEZXNjIiwid3JpdGFibGUiLCJzZXQiLCJpc1dlYldvcmtlciIsIldvcmtlckdsb2JhbFNjb3BlIiwiaXNOb2RlIiwicHJvY2VzcyIsImlzQnJvd3NlciIsImlzTWl4Iiwiem9uZVN5bWJvbEV2ZW50TmFtZXMkMSIsIndyYXBGbiIsImV2ZW50IiwiZXZlbnROYW1lU3ltYm9sIiwibGlzdGVuZXIiLCJyZXN1bHQiLCJlcnJvckV2ZW50IiwibWVzc2FnZSIsImZpbGVuYW1lIiwibGluZW5vIiwiY29sbm8iLCJwcmV2ZW50RGVmYXVsdCIsInBhdGNoUHJvcGVydHkiLCJvYmoiLCJwcm9wIiwiZGVzYyIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJvblByb3BQYXRjaGVkU3ltYm9sIiwib3JpZ2luYWxEZXNjR2V0Iiwib3JpZ2luYWxEZXNjU2V0IiwiZXZlbnROYW1lIiwic3Vic3RyIiwibmV3VmFsdWUiLCJwcmV2aW91c1ZhbHVlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVBdHRyaWJ1dGUiLCJvblByb3BlcnRpZXMiLCJqIiwib3JpZ2luYWxJbnN0YW5jZUtleSIsImNsYXNzTmFtZSIsIk9yaWdpbmFsQ2xhc3MiLCJhIiwiaW5zdGFuY2UiLCJwYXRjaEZuIiwicHJvdG8iLCJkZWxlZ2F0ZU5hbWUiLCJwYXRjaERlbGVnYXRlIiwiZnVuY05hbWUiLCJtZXRhQ3JlYXRvciIsInNldE5hdGl2ZSIsImNiSWR4IiwibWV0YSIsIm9yaWdpbmFsIiwiaXNEZXRlY3RlZElFT3JFZGdlIiwiaWVPckVkZ2UiLCJpc0lFIiwidWEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpbmRleE9mIiwiYXBpIiwicmVhZGFibGVPYmplY3RUb1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJfdW5jYXVnaHRQcm9taXNlRXJyb3JzIiwiaXNEaXNhYmxlV3JhcHBpbmdVbmNhdWdodFByb21pc2VSZWplY3Rpb24iLCJjcmVhdGlvblRyYWNlIiwiZSIsInJlamVjdGlvbiIsImNvbnNvbGUiLCJzdGFjayIsInVuY2F1Z2h0UHJvbWlzZUVycm9yIiwic2hpZnQiLCJ0aHJvd09yaWdpbmFsIiwiaGFuZGxlVW5oYW5kbGVkUmVqZWN0aW9uIiwiVU5IQU5ETEVEX1BST01JU0VfUkVKRUNUSU9OX0hBTkRMRVJfU1lNQk9MIiwiaGFuZGxlciIsImlzVGhlbmFibGUiLCJ0aGVuIiwiZm9yd2FyZFJlc29sdXRpb24iLCJmb3J3YXJkUmVqZWN0aW9uIiwiWm9uZUF3YXJlUHJvbWlzZSIsInJlamVjdCIsInN5bWJvbFN0YXRlIiwic3ltYm9sVmFsdWUiLCJzeW1ib2xGaW5hbGx5Iiwic3ltYm9sUGFyZW50UHJvbWlzZVZhbHVlIiwic3ltYm9sUGFyZW50UHJvbWlzZVN0YXRlIiwiVU5SRVNPTFZFRCIsIlJFU09MVkVEIiwiUkVKRUNURUQiLCJSRUpFQ1RFRF9OT19DQVRDSCIsIm1ha2VSZXNvbHZlciIsInByb21pc2UiLCJ2IiwicmVzb2x2ZVByb21pc2UiLCJvbmNlIiwid2FzQ2FsbGVkIiwid3JhcHBlciIsIndyYXBwZWRGdW5jdGlvbiIsIlRZUEVfRVJST1IiLCJDVVJSRU5UX1RBU0tfVFJBQ0VfU1lNQk9MIiwib25jZVdyYXBwZXIiLCJUeXBlRXJyb3IiLCJjbGVhclJlamVjdGVkTm9DYXRjaCIsInRyYWNlIiwic2NoZWR1bGVSZXNvbHZlT3JSZWplY3QiLCJSRUpFQ1RJT05fSEFORExFRF9IQU5ETEVSIiwic3BsaWNlIiwiY2hhaW5Qcm9taXNlIiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwicHJvbWlzZVN0YXRlIiwicGFyZW50UHJvbWlzZVZhbHVlIiwiaXNGaW5hbGx5UHJvbWlzZSIsIlpPTkVfQVdBUkVfUFJPTUlTRV9UT19TVFJJTkciLCJBZ2dyZWdhdGVFcnJvciIsImFueSIsInZhbHVlcyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiUHJvbWlzZSIsInByb21pc2VzIiwiZmluaXNoZWQiLCJlcnJvcnMiLCJyYWNlIiwicmVzIiwicmVqIiwib25SZXNvbHZlIiwib25SZWplY3QiLCJhbGwiLCJhbGxXaXRoQ2FsbGJhY2siLCJhbGxTZXR0bGVkIiwiUCIsInRoZW5DYWxsYmFjayIsInN0YXR1cyIsImVycm9yQ2FsbGJhY2siLCJyZWFzb24iLCJ1bnJlc29sdmVkQ291bnQiLCJ2YWx1ZUluZGV4IiwicmVzb2x2ZWRWYWx1ZXMiLCJjdXJWYWx1ZUluZGV4IiwidGhlbkVyciIsImV4ZWN1dG9yIiwidG9TdHJpbmdUYWciLCJzcGVjaWVzIiwiQyIsImNhdGNoIiwiZmluYWxseSIsIm9uRmluYWxseSIsIk5hdGl2ZVByb21pc2UiLCJzeW1ib2xUaGVuUGF0Y2hlZCIsIkN0b3IiLCJvcmlnaW5hbFRoZW4iLCJ3cmFwcGVkIiwiem9uZWlmeSIsInJlc3VsdFByb21pc2UiLCJjdG9yIiwib3JpZ2luYWxGdW5jdGlvblRvU3RyaW5nIiwiRnVuY3Rpb24iLCJPUklHSU5BTF9ERUxFR0FURV9TWU1CT0wiLCJQUk9NSVNFX1NZTUJPTCIsIkVSUk9SX1NZTUJPTCIsIm5ld0Z1bmN0aW9uVG9TdHJpbmciLCJvcmlnaW5hbERlbGVnYXRlIiwibmF0aXZlUHJvbWlzZSIsIm5hdGl2ZUVycm9yIiwib3JpZ2luYWxPYmplY3RUb1N0cmluZyIsIlBST01JU0VfT0JKRUNUX1RPX1NUUklORyIsInBhc3NpdmVTdXBwb3J0ZWQiLCJPUFRJTUlaRURfWk9ORV9FVkVOVF9UQVNLX0RBVEEiLCJ6b25lU3ltYm9sRXZlbnROYW1lcyIsImdsb2JhbFNvdXJjZXMiLCJFVkVOVF9OQU1FX1NZTUJPTF9SRUdYIiwiUmVnRXhwIiwiSU1NRURJQVRFX1BST1BBR0FUSU9OX1NZTUJPTCIsInByZXBhcmVFdmVudE5hbWVzIiwiZXZlbnROYW1lVG9TdHJpbmciLCJmYWxzZUV2ZW50TmFtZSIsInRydWVFdmVudE5hbWUiLCJzeW1ib2xDYXB0dXJlIiwiYXBpcyIsInBhdGNoT3B0aW9ucyIsIkFERF9FVkVOVF9MSVNURU5FUiIsImFkZCIsIlJFTU9WRV9FVkVOVF9MSVNURU5FUiIsInJtIiwiTElTVEVORVJTX0VWRU5UX0xJU1RFTkVSIiwibGlzdGVuZXJzIiwiUkVNT1ZFX0FMTF9MSVNURU5FUlNfRVZFTlRfTElTVEVORVIiLCJybUFsbCIsInpvbmVTeW1ib2xBZGRFdmVudExpc3RlbmVyIiwiQUREX0VWRU5UX0xJU1RFTkVSX1NPVVJDRSIsIlBSRVBFTkRfRVZFTlRfTElTVEVORVIiLCJQUkVQRU5EX0VWRU5UX0xJU1RFTkVSX1NPVVJDRSIsImlzUmVtb3ZlZCIsImhhbmRsZUV2ZW50IiwiZ2xvYmFsQ2FsbGJhY2siLCJjb250ZXh0IiwiaXNDYXB0dXJlIiwidGFza3MiLCJjb3B5VGFza3MiLCJnbG9iYWxab25lQXdhcmVDYWxsYmFjayIsImdsb2JhbFpvbmVBd2FyZUNhcHR1cmVDYWxsYmFjayIsInBhdGNoRXZlbnRUYXJnZXRNZXRob2RzIiwidXNlR2xvYmFsQ2FsbGJhY2siLCJ2YWxpZGF0ZUhhbmRsZXIiLCJ2aCIsImNoa0R1cCIsInJldHVyblRhcmdldCIsInJ0IiwidGFza0RhdGEiLCJuYXRpdmVBZGRFdmVudExpc3RlbmVyIiwibmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm5hdGl2ZUxpc3RlbmVycyIsIm5hdGl2ZVJlbW92ZUFsbExpc3RlbmVycyIsIm5hdGl2ZVByZXBlbmRFdmVudExpc3RlbmVyIiwicHJlcGVuZCIsImJ1aWxkRXZlbnRMaXN0ZW5lck9wdGlvbnMiLCJwYXNzaXZlIiwiY2FwdHVyZSIsImFzc2lnbiIsImN1c3RvbVNjaGVkdWxlR2xvYmFsIiwiaXNFeGlzdGluZyIsImN1c3RvbUNhbmNlbEdsb2JhbCIsInN5bWJvbEV2ZW50TmFtZXMiLCJzeW1ib2xFdmVudE5hbWUiLCJleGlzdGluZ1Rhc2tzIiwiZXhpc3RpbmdUYXNrIiwiYWxsUmVtb3ZlZCIsImN1c3RvbVNjaGVkdWxlTm9uR2xvYmFsIiwiY3VzdG9tU2NoZWR1bGVQcmVwZW5kIiwiY3VzdG9tQ2FuY2VsTm9uR2xvYmFsIiwiY29tcGFyZVRhc2tDYWxsYmFja1ZzRGVsZWdhdGUiLCJ0eXBlT2ZEZWxlZ2F0ZSIsImNvbXBhcmUiLCJkaWZmIiwidW5wYXRjaGVkRXZlbnRzIiwicGFzc2l2ZUV2ZW50cyIsIm1ha2VBZGRMaXN0ZW5lciIsIm5hdGl2ZUxpc3RlbmVyIiwiYWRkU291cmNlIiwiY3VzdG9tU2NoZWR1bGVGbiIsImN1c3RvbUNhbmNlbEZuIiwidHJhbnNmZXJFdmVudE5hbWUiLCJpc0hhbmRsZUV2ZW50IiwiY29uc3RydWN0b3JOYW1lIiwidGFyZ2V0U291cmNlIiwidW5zaGlmdCIsIm9uUHJvcGVydHlTeW1ib2wiLCJmaW5kRXZlbnRUYXNrcyIsImtleXMiLCJtYXRjaCIsImV4ZWMiLCJldnROYW1lIiwic3ltYm9sQ2FwdHVyZUV2ZW50TmFtZSIsImNhcHR1cmVUYXNrcyIsInJlbW92ZVRhc2tzIiwicmVzdWx0cyIsImZvdW5kVGFza3MiLCJjYXB0dXJlRmFsc2VUYXNrcyIsImNhcHR1cmVUcnVlVGFza3MiLCJjb25jYXQiLCJFdmVudCIsInRhcmdldE5hbWUiLCJtZXRob2QiLCJjYWxsYmFja3MiLCJuYXRpdmVEZWxlZ2F0ZSIsIm9wdHMiLCJmb3JFYWNoIiwiZGVzY3JpcHRvciIsImlnbm9yZVByb3BlcnRpZXMiLCJ0aXAiLCJmaWx0ZXIiLCJpcCIsInRhcmdldElnbm9yZVByb3BlcnRpZXMiLCJvcCIsInBhdGNoRmlsdGVyZWRQcm9wZXJ0aWVzIiwiZmlsdGVyZWRQcm9wZXJ0aWVzIiwiZ2V0T25FdmVudE5hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInN0YXJ0c1dpdGgiLCJtYXAiLCJzdWJzdHJpbmciLCJwcm9wZXJ0eURlc2NyaXB0b3JQYXRjaCIsInBhdGNoVGFyZ2V0cyIsImlnbm9yZUVycm9yUHJvcGVydGllcyIsImV2ZW50TmFtZXMiLCJTWU1CT0xfQkxBQ0tfTElTVEVEX0VWRU5UUyIsIlNZTUJPTF9VTlBBVENIRURfRVZFTlRTIiwidGFza1N5bWJvbCIsInBhdGNoVGltZXIiLCJzZXROYW1lIiwiY2FuY2VsTmFtZSIsIm5hbWVTdWZmaXgiLCJjbGVhck5hdGl2ZSIsInRhc2tzQnlIYW5kbGVJZCIsImNsZWFyVGFzayIsImRlbGF5IiwidGltZXIiLCJoYW5kbGUiLCJyZWYiLCJ1bnJlZiIsImJpbmQiLCJpZCIsInBhdGNoQ3VzdG9tRWxlbWVudHMiLCJjdXN0b21FbGVtZW50cyIsImV2ZW50VGFyZ2V0UGF0Y2giLCJFVkVOVF9UQVJHRVQiLCJwYXRjaEV2ZW50IiwibGVnYWN5UGF0Y2giLCJjbGVhciIsImJsb2NraW5nTWV0aG9kcyIsInMiLCJYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0IiwicGF0Y2hYSFIiLCJYSFJfVEFTSyIsIlhIUl9TWU5DIiwiWEhSX0xJU1RFTkVSIiwiWEhSX1NDSEVEVUxFRCIsIlhIUl9VUkwiLCJYSFJfRVJST1JfQkVGT1JFX1NDSEVEVUxFRCIsIlhNTEh0dHBSZXF1ZXN0IiwiWE1MSHR0cFJlcXVlc3RQcm90b3R5cGUiLCJmaW5kUGVuZGluZ1Rhc2siLCJvcmlBZGRMaXN0ZW5lciIsIm9yaVJlbW92ZUxpc3RlbmVyIiwiWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldFByb3RvdHlwZSIsIlJFQURZX1NUQVRFX0NIQU5HRSIsIlNDSEVEVUxFRCIsIm5ld0xpc3RlbmVyIiwicmVhZHlTdGF0ZSIsIkRPTkUiLCJhYm9ydGVkIiwibG9hZFRhc2tzIiwib3JpSW52b2tlIiwic3RvcmVkVGFzayIsInNlbmROYXRpdmUiLCJwbGFjZWhvbGRlckNhbGxiYWNrIiwiYWJvcnROYXRpdmUiLCJvcGVuTmF0aXZlIiwiWE1MSFRUUFJFUVVFU1RfU09VUkNFIiwiZmV0Y2hUYXNrQWJvcnRpbmciLCJmZXRjaFRhc2tTY2hlZHVsaW5nIiwidXJsIiwiZ2VvbG9jYXRpb24iLCJmaW5kUHJvbWlzZVJlamVjdGlvbkhhbmRsZXIiLCJldmVudFRhc2tzIiwiUHJvbWlzZVJlamVjdGlvbkV2ZW50IiwiZXZ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2014\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__(6258);
/******/ 	
/******/ })()
;